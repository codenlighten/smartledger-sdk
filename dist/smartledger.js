(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SmartLedger = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./src/primitives/index.js"), exports);
__exportStar(require("./src/script/index.js"), exports);
__exportStar(require("./src/script/templates/index.js"), exports);
__exportStar(require("./src/transaction/index.js"), exports);
__exportStar(require("./src/transaction/fee-models/index.js"), exports);
__exportStar(require("./src/transaction/broadcasters/index.js"), exports);
__exportStar(require("./src/transaction/chaintrackers/index.js"), exports);
__exportStar(require("./src/transaction/http/index.js"), exports);
__exportStar(require("./src/messages/index.js"), exports);
__exportStar(require("./src/compat/index.js"), exports);
__exportStar(require("./src/totp/index.js"), exports);
__exportStar(require("./src/wallet/index.js"), exports);
__exportStar(require("./src/wallet/substrates/index.js"), exports);
__exportStar(require("./src/auth/index.js"), exports);
__exportStar(require("./src/overlay-tools/index.js"), exports);
__exportStar(require("./src/storage/index.js"), exports);
__exportStar(require("./src/identity/index.js"), exports);
__exportStar(require("./src/registry/index.js"), exports);
__exportStar(require("./src/kvstore/index.js"), exports);

},{"./src/auth/index.js":11,"./src/compat/index.js":26,"./src/identity/index.js":29,"./src/kvstore/index.js":32,"./src/messages/index.js":35,"./src/overlay-tools/index.js":39,"./src/primitives/index.js":61,"./src/registry/index.js":64,"./src/script/index.js":72,"./src/script/templates/index.js":76,"./src/storage/index.js":80,"./src/totp/index.js":81,"./src/transaction/broadcasters/index.js":93,"./src/transaction/chaintrackers/index.js":97,"./src/transaction/fee-models/index.js":99,"./src/transaction/http/index.js":104,"./src/transaction/index.js":105,"./src/wallet/index.js":113,"./src/wallet/substrates/index.js":122}],2:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Peer = void 0;
const SessionManager_js_1 = require("./SessionManager.js");
const index_js_1 = require("./utils/index.js");
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
const Utils = __importStar(require("../primitives/utils.js"));
const AUTH_VERSION = '0.1';
/**
 * Represents a peer capable of performing mutual authentication.
 * Manages sessions, handles authentication handshakes, certificate requests and responses,
 * and sending and receiving general messages over a transport layer.
 *
 * This version supports multiple concurrent sessions per peer identityKey.
 */
class Peer {
    /**
     * Creates a new Peer instance
     *
     * @param {WalletInterface} wallet - The wallet instance used for cryptographic operations.
     * @param {Transport} transport - The transport mechanism used for sending and receiving messages.
     * @param {RequestedCertificateSet} [certificatesToRequest] - Optional set of certificates to request from a peer during the initial handshake.
     * @param {SessionManager} [sessionManager] - Optional SessionManager to be used for managing peer sessions.
     * @param {boolean} [autoPersistLastSession] - Whether to auto-persist the session with the last-interacted-with peer. Defaults to true.
     */
    constructor(wallet, transport, certificatesToRequest, sessionManager, autoPersistLastSession, originator) {
        this.onGeneralMessageReceivedCallbacks = new Map();
        this.onCertificatesReceivedCallbacks = new Map();
        this.onCertificateRequestReceivedCallbacks = new Map();
        this.onInitialResponseReceivedCallbacks = new Map();
        // Single shared counter for all callback types
        this.callbackIdCounter = 0;
        // Whether to auto-persist the session with the last-interacted-with peer
        this.autoPersistLastSession = true;
        this.wallet = wallet;
        this.originator = originator;
        this.transport = transport;
        this.certificatesToRequest = certificatesToRequest ?? {
            certifiers: [],
            types: {}
        };
        this.transport.onData(this.handleIncomingMessage.bind(this)).catch(e => {
            throw e;
        });
        this.sessionManager =
            sessionManager != null ? sessionManager : new SessionManager_js_1.SessionManager();
        if (autoPersistLastSession === false) {
            this.autoPersistLastSession = false;
        }
        else {
            this.autoPersistLastSession = true;
        }
    }
    /**
     * Sends a general message to a peer, and initiates a handshake if necessary.
     *
     * @param {number[]} message - The message payload to send.
     * @param {string} [identityKey] - The identity public key of the peer. If not provided, uses lastInteractedWithPeer (if any).
     * @param {number} [maxWaitTime] - optional max wait time in ms
     * @returns {Promise<void>}
     * @throws Will throw an error if the message fails to send.
     */
    async toPeer(message, identityKey, maxWaitTime) {
        if (this.autoPersistLastSession &&
            typeof this.lastInteractedWithPeer === 'string' &&
            typeof identityKey !== 'string') {
            identityKey = this.lastInteractedWithPeer;
        }
        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);
        // Prepare the general message
        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));
        const { signature } = await this.wallet.createSignature({
            data: message,
            protocolID: [2, 'auth message signature'],
            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,
            counterparty: peerSession.peerIdentityKey
        }, this.originator);
        const generalMessage = {
            version: AUTH_VERSION,
            messageType: 'general',
            identityKey: (await this.wallet.getPublicKey({ identityKey: true }, this.originator))
                .publicKey,
            nonce: requestNonce,
            yourNonce: peerSession.peerNonce,
            payload: message,
            signature
        };
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        try {
            await this.transport.send(generalMessage);
        }
        catch (error) {
            const e = new Error(`Failed to send message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);
            e.stack = error.stack;
            throw e;
        }
    }
    /**
     * Sends a request for certificates to a peer.
     * This method allows a peer to dynamically request specific certificates after
     * an initial handshake or message has been exchanged.
     *
     * @param {RequestedCertificateSet} certificatesToRequest - Specifies the certifiers and types of certificates required from the peer.
     * @param {string} [identityKey] - The identity public key of the peer. If not provided, the current or last session identity is used.
     * @param {number} [maxWaitTime=10000] - Maximum time in milliseconds to wait for the peer session to be authenticated.
     * @returns {Promise<void>} Resolves if the certificate request message is successfully sent.
     * @throws Will throw an error if the peer session is not authenticated or if sending the request fails.
     */
    async requestCertificates(certificatesToRequest, identityKey, maxWaitTime = 10000) {
        if (this.autoPersistLastSession &&
            typeof this.lastInteractedWithPeer === 'string' &&
            typeof identityKey !== 'string') {
            identityKey = this.lastInteractedWithPeer;
        }
        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);
        // Prepare the message
        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));
        const { signature } = await this.wallet.createSignature({
            data: Utils.toArray(JSON.stringify(certificatesToRequest), 'utf8'),
            protocolID: [2, 'auth message signature'],
            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,
            counterparty: peerSession.peerIdentityKey
        }, this.originator);
        const certRequestMessage = {
            version: AUTH_VERSION,
            messageType: 'certificateRequest',
            identityKey: (await this.wallet.getPublicKey({ identityKey: true }, this.originator))
                .publicKey,
            nonce: requestNonce,
            initialNonce: peerSession.sessionNonce,
            yourNonce: peerSession.peerNonce,
            requestedCertificates: certificatesToRequest,
            signature
        };
        // Update last-used timestamp
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        try {
            await this.transport.send(certRequestMessage);
        }
        catch (error) {
            throw new Error(`Failed to send certificate request message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);
        }
    }
    /**
     * Retrieves an authenticated session for a given peer identity. If no session exists
     * or the session is not authenticated, initiates a handshake to create or authenticate the session.
     *
     * - If `identityKey` is provided, we look up any existing session for that identity key.
     * - If none is found or not authenticated, we do a new handshake.
     * - If `identityKey` is not provided, but we have a `lastInteractedWithPeer`, we try that key.
     *
     * @param {string} [identityKey] - The identity public key of the peer.
     * @param {number} [maxWaitTime] - The maximum time in milliseconds to wait for the handshake.
     * @returns {Promise<PeerSession>} - A promise that resolves with an authenticated `PeerSession`.
     */
    async getAuthenticatedSession(identityKey, maxWaitTime) {
        if (this.transport === undefined) {
            throw new Error('Peer transport is not connected!');
        }
        let peerSession;
        if (typeof identityKey === 'string') {
            peerSession = this.sessionManager.getSession(identityKey);
        }
        // If that session doesn't exist or isn't authenticated, initiate handshake
        if ((peerSession == null) || !peerSession.isAuthenticated) {
            // This will create a brand-new session
            const sessionNonce = await this.initiateHandshake(identityKey, maxWaitTime);
            // Now retrieve it by the sessionNonce
            peerSession = this.sessionManager.getSession(sessionNonce);
            if ((peerSession == null) || !peerSession.isAuthenticated) {
                throw new Error('Unable to establish mutual authentication with peer!');
            }
        }
        return peerSession;
    }
    /**
     * Registers a callback to listen for general messages from peers.
     *
     * @param {(senderPublicKey: string, payload: number[]) => void} callback - The function to call when a general message is received.
     * @returns {number} The ID of the callback listener.
     */
    listenForGeneralMessages(callback) {
        const callbackID = this.callbackIdCounter++;
        this.onGeneralMessageReceivedCallbacks.set(callbackID, callback);
        return callbackID;
    }
    /**
     * Removes a general message listener.
     *
     * @param {number} callbackID - The ID of the callback to remove.
     */
    stopListeningForGeneralMessages(callbackID) {
        this.onGeneralMessageReceivedCallbacks.delete(callbackID);
    }
    /**
     * Registers a callback to listen for certificates received from peers.
     *
     * @param {(senderPublicKey: string, certs: VerifiableCertificate[]) => void} callback - The function to call when certificates are received.
     * @returns {number} The ID of the callback listener.
     */
    listenForCertificatesReceived(callback) {
        const callbackID = this.callbackIdCounter++;
        this.onCertificatesReceivedCallbacks.set(callbackID, callback);
        return callbackID;
    }
    /**
     * Cancels and unsubscribes a certificatesReceived listener.
     *
     * @param {number} callbackID - The ID of the certificates received callback to cancel.
     */
    stopListeningForCertificatesReceived(callbackID) {
        this.onCertificatesReceivedCallbacks.delete(callbackID);
    }
    /**
     * Registers a callback to listen for certificates requested from peers.
     *
     * @param {(requestedCertificates: RequestedCertificateSet) => void} callback - The function to call when a certificate request is received
     * @returns {number} The ID of the callback listener.
     */
    listenForCertificatesRequested(callback) {
        const callbackID = this.callbackIdCounter++;
        this.onCertificateRequestReceivedCallbacks.set(callbackID, callback);
        return callbackID;
    }
    /**
     * Cancels and unsubscribes a certificatesRequested listener.
     *
     * @param {number} callbackID - The ID of the requested certificates callback to cancel.
     */
    stopListeningForCertificatesRequested(callbackID) {
        this.onCertificateRequestReceivedCallbacks.delete(callbackID);
    }
    /**
     * Initiates the mutual authentication handshake with a peer.
     *
     * @private
     * @param {string} [identityKey] - The identity public key of the peer.
     * @param {number} [maxWaitTime=10000] - how long to wait for handshake
     * @returns {Promise<string>} A promise that resolves to the session nonce.
     */
    async initiateHandshake(identityKey, maxWaitTime = 10000) {
        const sessionNonce = await (0, index_js_1.createNonce)(this.wallet, undefined, this.originator); // Initial request nonce
        // Create the preliminary session (not yet authenticated)
        const now = Date.now();
        this.sessionManager.addSession({
            isAuthenticated: false,
            sessionNonce,
            peerIdentityKey: identityKey,
            lastUpdate: now
        });
        const initialRequest = {
            version: AUTH_VERSION,
            messageType: 'initialRequest',
            identityKey: (await this.wallet.getPublicKey({ identityKey: true }, this.originator))
                .publicKey,
            initialNonce: sessionNonce,
            requestedCertificates: this.certificatesToRequest
        };
        await this.transport.send(initialRequest);
        return await this.waitForInitialResponse(sessionNonce, maxWaitTime);
    }
    /**
     * Waits for the initial response from the peer after sending an initial handshake request message.
     *
     * @param {string} sessionNonce - The session nonce created in the initial request.
     * @returns {Promise<string>} A promise that resolves with the session nonce when the initial response is received.
     */
    async waitForInitialResponse(sessionNonce, maxWaitTime = 10000) {
        return await new Promise((resolve, reject) => {
            const callbackID = this.listenForInitialResponse(sessionNonce, nonce => {
                clearTimeout(timeoutHandle);
                this.stopListeningForInitialResponses(callbackID);
                resolve(nonce);
            });
            const timeoutHandle = setTimeout(() => {
                this.stopListeningForInitialResponses(callbackID);
                reject(new Error('Initial response timed out.'));
            }, maxWaitTime);
        });
    }
    /**
     * Adds a listener for an initial response message matching a specific initial nonce.
     *
     * @private
     * @param {string} sessionNonce - The session nonce to match.
     * @param {(sessionNonce: string) => void} callback - The callback to invoke when the initial response is received.
     * @returns {number} The ID of the callback listener.
     */
    listenForInitialResponse(sessionNonce, callback) {
        const callbackID = this.callbackIdCounter++;
        this.onInitialResponseReceivedCallbacks.set(callbackID, {
            callback,
            sessionNonce
        });
        return callbackID;
    }
    /**
     * Removes a listener for initial responses.
     *
     * @private
     * @param {number} callbackID - The ID of the callback to remove.
     */
    stopListeningForInitialResponses(callbackID) {
        this.onInitialResponseReceivedCallbacks.delete(callbackID);
    }
    /**
     * Handles incoming messages from the transport.
     *
     * @param {AuthMessage} message - The incoming message to process.
     * @returns {Promise<void>}
     */
    async handleIncomingMessage(message) {
        if (typeof message.version !== 'string' || message.version !== AUTH_VERSION) {
            throw new Error(`Invalid or unsupported message auth version! Received: ${message.version}, expected: ${AUTH_VERSION}`);
        }
        switch (message.messageType) {
            case 'initialRequest':
                await this.processInitialRequest(message);
                break;
            case 'initialResponse':
                await this.processInitialResponse(message);
                break;
            case 'certificateRequest':
                await this.processCertificateRequest(message);
                break;
            case 'certificateResponse':
                await this.processCertificateResponse(message);
                break;
            case 'general':
                await this.processGeneralMessage(message);
                break;
            default:
                throw new Error(`Unknown message type of ${String(message.messageType)} from ${String(message.identityKey)}`);
        }
    }
    /**
     * Processes an initial request message from a peer.
     *
     * @param {AuthMessage} message - The incoming initial request message.
     */
    async processInitialRequest(message) {
        if (typeof message.identityKey !== 'string' ||
            typeof message.initialNonce !== 'string' ||
            message.initialNonce === '') {
            throw new Error('Missing required fields in initialRequest message.');
        }
        // Create a new sessionNonce for our side
        const sessionNonce = await (0, index_js_1.createNonce)(this.wallet, undefined, this.originator);
        const now = Date.now();
        // We'll treat this as fully authenticated from *our* perspective (the responding side).
        this.sessionManager.addSession({
            isAuthenticated: true,
            sessionNonce,
            peerNonce: message.initialNonce,
            peerIdentityKey: message.identityKey,
            lastUpdate: now
        });
        // Possibly handle the peer's requested certs
        let certificatesToInclude;
        if ((message.requestedCertificates != null) &&
            Array.isArray(message.requestedCertificates.certifiers) &&
            message.requestedCertificates.certifiers.length > 0) {
            if (this.onCertificateRequestReceivedCallbacks.size > 0) {
                // Let the application handle it
                this.onCertificateRequestReceivedCallbacks.forEach(cb => {
                    cb(message.identityKey, message.requestedCertificates);
                });
            }
            else {
                // Attempt to find automatically
                certificatesToInclude = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey, this.originator);
            }
        }
        // Create signature
        const { signature } = await this.wallet.createSignature({
            data: Utils.toArray(message.initialNonce + sessionNonce, 'base64'),
            protocolID: [2, 'auth message signature'],
            keyID: `${message.initialNonce} ${sessionNonce}`,
            counterparty: message.identityKey
        }, this.originator);
        const initialResponseMessage = {
            version: AUTH_VERSION,
            messageType: 'initialResponse',
            identityKey: (await this.wallet.getPublicKey({ identityKey: true }, this.originator))
                .publicKey,
            initialNonce: sessionNonce,
            yourNonce: message.initialNonce,
            certificates: certificatesToInclude,
            requestedCertificates: this.certificatesToRequest,
            signature
        };
        // If we haven't interacted with a peer yet, store this identity as "lastInteracted"
        if (this.lastInteractedWithPeer === undefined) {
            this.lastInteractedWithPeer = message.identityKey;
        }
        // Send the response
        await this.transport.send(initialResponseMessage);
    }
    /**
     * Processes an initial response message from a peer.
     *
     * @private
     * @param {AuthMessage} message - The incoming initial response message.
     * @throws Will throw an error if nonce or signature verification fails.
     */
    async processInitialResponse(message) {
        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet, undefined, this.originator);
        if (!validNonce) {
            throw new Error(`Initial response nonce verification failed from peer: ${message.identityKey}`);
        }
        // This is the session we previously created by calling initiateHandshake
        const peerSession = this.sessionManager.getSession(message.yourNonce);
        if (peerSession == null) {
            throw new Error(`Peer session not found for peer: ${message.identityKey}`);
        }
        // Validate message signature
        const dataToVerify = Utils.toArray((peerSession.sessionNonce ?? '') + (message.initialNonce ?? ''), 'base64');
        const { valid } = await this.wallet.verifySignature({
            data: dataToVerify,
            signature: message.signature,
            protocolID: [2, 'auth message signature'],
            keyID: `${peerSession.sessionNonce ?? ''} ${message.initialNonce ?? ''}`,
            counterparty: message.identityKey
        }, this.originator);
        if (!valid) {
            throw new Error(`Unable to verify initial response signature for peer: ${message.identityKey}`);
        }
        // Now mark the session as authenticated
        peerSession.peerNonce = message.initialNonce;
        peerSession.peerIdentityKey = message.identityKey;
        peerSession.isAuthenticated = true;
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        // If the handshake had requested certificates, validate them
        if (this.certificatesToRequest?.certifiers?.length > 0 &&
            message.certificates?.length > 0) {
            await (0, index_js_1.validateCertificates)(this.wallet, message, this.certificatesToRequest, this.originator);
            // Notify listeners
            this.onCertificatesReceivedCallbacks.forEach(cb => cb(message.identityKey, message.certificates));
        }
        // Update lastInteractedWithPeer
        this.lastInteractedWithPeer = message.identityKey;
        // Let the handshake wait-latch know we got our response
        this.onInitialResponseReceivedCallbacks.forEach(entry => {
            if (entry.sessionNonce === peerSession.sessionNonce) {
                entry.callback(peerSession.sessionNonce);
            }
        });
        // The peer might also request certificates from us
        if ((message.requestedCertificates != null) &&
            Array.isArray(message.requestedCertificates.certifiers) &&
            message.requestedCertificates.certifiers.length > 0) {
            if (this.onCertificateRequestReceivedCallbacks.size > 0) {
                // Let the application handle it
                this.onCertificateRequestReceivedCallbacks.forEach(cb => {
                    cb(message.identityKey, message.requestedCertificates);
                });
            }
            else {
                // Attempt auto
                const verifiableCertificates = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey, this.originator);
                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);
            }
        }
    }
    /**
     * Processes an incoming certificate request message from a peer.
     * Verifies nonce/signature and then possibly sends a certificateResponse.
     *
     * @param {AuthMessage} message - The certificate request message received from the peer.
     * @throws {Error} if nonce or signature is invalid.
     */
    async processCertificateRequest(message) {
        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet, undefined, this.originator);
        if (!validNonce) {
            throw new Error(`Unable to verify nonce for certificate request message from: ${message.identityKey}`);
        }
        const peerSession = this.sessionManager.getSession(message.yourNonce);
        if (peerSession == null) {
            throw new Error(`Session not found for nonce: ${message.yourNonce}`);
        }
        const { valid } = await this.wallet.verifySignature({
            data: Utils.toArray(JSON.stringify(message.requestedCertificates), 'utf8'),
            signature: message.signature,
            protocolID: [2, 'auth message signature'],
            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,
            counterparty: peerSession.peerIdentityKey
        }, this.originator);
        if (!valid) {
            throw new Error(`Invalid signature in certificate request message from ${peerSession.peerIdentityKey}`);
        }
        // Update usage
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        if ((message.requestedCertificates != null) &&
            Array.isArray(message.requestedCertificates.certifiers) &&
            message.requestedCertificates.certifiers.length > 0) {
            if (this.onCertificateRequestReceivedCallbacks.size > 0) {
                // Let the application handle it
                this.onCertificateRequestReceivedCallbacks.forEach(cb => {
                    cb(message.identityKey, message.requestedCertificates);
                });
            }
            else {
                // Attempt auto
                const verifiableCertificates = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey, this.originator);
                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);
            }
        }
    }
    /**
     * Sends a certificate response message containing the specified certificates to a peer.
     *
     * @param {string} verifierIdentityKey - The identity key of the peer requesting the certificates.
     * @param {VerifiableCertificate[]} certificates - The list of certificates to include in the response.
     * @throws Will throw an error if the transport fails to send the message.
     */
    async sendCertificateResponse(verifierIdentityKey, certificates) {
        const peerSession = await this.getAuthenticatedSession(verifierIdentityKey);
        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));
        const { signature } = await this.wallet.createSignature({
            data: Utils.toArray(JSON.stringify(certificates), 'utf8'),
            protocolID: [2, 'auth message signature'],
            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,
            counterparty: peerSession.peerIdentityKey
        }, this.originator);
        const certificateResponse = {
            version: AUTH_VERSION,
            messageType: 'certificateResponse',
            identityKey: (await this.wallet.getPublicKey({ identityKey: true }, this.originator))
                .publicKey,
            nonce: requestNonce,
            initialNonce: peerSession.sessionNonce,
            yourNonce: peerSession.peerNonce,
            certificates,
            signature
        };
        // Update usage
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        try {
            await this.transport.send(certificateResponse);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to send certificate response message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${errorMessage}`);
        }
    }
    /**
     * Processes a certificate response message from a peer.
     *
     * @private
     * @param {AuthMessage} message - The incoming certificate response message.
     * @throws Will throw an error if nonce verification or signature verification fails.
     */
    async processCertificateResponse(message) {
        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet, undefined, this.originator);
        if (!validNonce) {
            throw new Error(`Unable to verify nonce for certificate response from: ${message.identityKey}`);
        }
        const peerSession = this.sessionManager.getSession(message.yourNonce);
        if (peerSession == null) {
            throw new Error(`Session not found for nonce: ${message.yourNonce}`);
        }
        // Validate message signature
        const { valid } = await this.wallet.verifySignature({
            data: Utils.toArray(JSON.stringify(message.certificates), 'utf8'),
            signature: message.signature,
            protocolID: [2, 'auth message signature'],
            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,
            counterparty: message.identityKey
        }, this.originator);
        if (!valid) {
            throw new Error(`Unable to verify certificate response signature for peer: ${message.identityKey}`);
        }
        // We also handle optional validation if there's a requestedCertificates field
        await (0, index_js_1.validateCertificates)(this.wallet, message, message.requestedCertificates, this.originator);
        // Notify any listeners
        this.onCertificatesReceivedCallbacks.forEach(cb => {
            cb(message.identityKey, message.certificates ?? []);
        });
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
    }
    /**
     * Processes a general message from a peer.
     *
     * @private
     * @param {AuthMessage} message - The incoming general message.
     * @throws Will throw an error if nonce or signature verification fails.
     */
    async processGeneralMessage(message) {
        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet, undefined, this.originator);
        if (!validNonce) {
            throw new Error(`Unable to verify nonce for general message from: ${message.identityKey}`);
        }
        const peerSession = this.sessionManager.getSession(message.yourNonce);
        if (peerSession == null) {
            throw new Error(`Session not found for nonce: ${message.yourNonce}`);
        }
        const { valid } = await this.wallet.verifySignature({
            data: message.payload,
            signature: message.signature,
            protocolID: [2, 'auth message signature'],
            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,
            counterparty: peerSession.peerIdentityKey
        }, this.originator);
        if (!valid) {
            throw new Error(`Invalid signature in generalMessage from ${peerSession.peerIdentityKey}`);
        }
        // Mark last usage
        peerSession.lastUpdate = Date.now();
        this.sessionManager.updateSession(peerSession);
        // Update lastInteractedWithPeer
        this.lastInteractedWithPeer = message.identityKey;
        // Dispatch callbacks
        this.onGeneralMessageReceivedCallbacks.forEach(cb => {
            cb(message.identityKey, message.payload ?? []);
        });
    }
}
exports.Peer = Peer;

},{"../primitives/Random.js":55,"../primitives/utils.js":62,"./SessionManager.js":3,"./utils/index.js":17}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
/**
 * Manages sessions for peers, allowing multiple concurrent sessions
 * per identity key. Primary lookup is always by `sessionNonce`.
 */
class SessionManager {
    constructor() {
        this.sessionNonceToSession = new Map();
        this.identityKeyToNonces = new Map();
    }
    /**
     * Adds a session to the manager, associating it with its sessionNonce,
     * and also with its peerIdentityKey (if any).
     *
     * This does NOT overwrite existing sessions for the same peerIdentityKey,
     * allowing multiple concurrent sessions for the same peer.
     *
     * @param {PeerSession} session - The peer session to add.
     */
    addSession(session) {
        if (typeof session.sessionNonce !== 'string') {
            throw new Error('Invalid session: sessionNonce is required to add a session.');
        }
        // Use the sessionNonce as the primary key
        this.sessionNonceToSession.set(session.sessionNonce, session);
        // Also track it by identity key if present
        if (typeof session.peerIdentityKey === 'string') {
            let nonces = this.identityKeyToNonces.get(session.peerIdentityKey);
            if (nonces == null) {
                nonces = new Set();
                this.identityKeyToNonces.set(session.peerIdentityKey, nonces);
            }
            nonces.add(session.sessionNonce);
        }
    }
    /**
     * Updates a session in the manager (primarily by re-adding it),
     * ensuring we record the latest data (e.g., isAuthenticated, lastUpdate, etc.).
     *
     * @param {PeerSession} session - The peer session to update.
     */
    updateSession(session) {
        // Remove the old references (if any) and re-add
        this.removeSession(session);
        this.addSession(session);
    }
    /**
     * Retrieves a session based on a given identifier, which can be:
     *  - A sessionNonce, or
     *  - A peerIdentityKey.
     *
     * If it is a `sessionNonce`, returns that exact session.
     * If it is a `peerIdentityKey`, returns the "best" (e.g. most recently updated,
     * authenticated) session associated with that peer, if any.
     *
     * @param {string} identifier - The identifier for the session (sessionNonce or peerIdentityKey).
     * @returns {PeerSession | undefined} - The matching peer session, or undefined if not found.
     */
    getSession(identifier) {
        // Check if this identifier is directly a sessionNonce
        const direct = this.sessionNonceToSession.get(identifier);
        if (direct != null) {
            return direct;
        }
        // Otherwise, interpret the identifier as an identity key
        const nonces = this.identityKeyToNonces.get(identifier);
        if ((nonces == null) || nonces.size === 0) {
            return undefined;
        }
        // Pick the "best" session. One sensible approach:
        // - Choose an authenticated session if available
        // - Among them, pick the most recently updated
        let best;
        for (const nonce of nonces) {
            const s = this.sessionNonceToSession.get(nonce);
            if (s == null)
                continue;
            // We can prefer authenticated sessions
            if (best == null) {
                best = s;
            }
            else {
                // If we want the "most recently updated" AND isAuthenticated
                if ((s.lastUpdate ?? 0) > (best.lastUpdate ?? 0)) {
                    best = s;
                }
            }
        }
        // Optionally, you could also filter out isAuthenticated===false if you only want
        // an authenticated session. But for our usage, let's return the latest any session.
        return best;
    }
    /**
     * Removes a session from the manager by clearing all associated identifiers.
     *
     * @param {PeerSession} session - The peer session to remove.
     */
    removeSession(session) {
        if (typeof session.sessionNonce === 'string') {
            this.sessionNonceToSession.delete(session.sessionNonce);
        }
        if (typeof session.peerIdentityKey === 'string') {
            const nonces = this.identityKeyToNonces.get(session.peerIdentityKey);
            if (nonces != null) {
                nonces.delete(session.sessionNonce ?? '');
                if (nonces.size === 0) {
                    this.identityKeyToNonces.delete(session.peerIdentityKey);
                }
            }
        }
    }
    /**
     * Checks if a session exists for a given identifier (either sessionNonce or identityKey).
     *
     * @param {string} identifier - The identifier to check.
     * @returns {boolean} - True if the session exists, false otherwise.
     */
    hasSession(identifier) {
        const direct = this.sessionNonceToSession.has(identifier);
        if (direct)
            return true;
        // if not directly a nonce, interpret as identityKey
        const nonces = this.identityKeyToNonces.get(identifier);
        return !(nonces == null) && nonces.size > 0;
    }
}
exports.SessionManager = SessionManager;

},{}],4:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils = __importStar(require("../../primitives/utils.js"));
const ProtoWallet_js_1 = __importDefault(require("../../wallet/ProtoWallet.js"));
const Signature_js_1 = __importDefault(require("../../primitives/Signature.js"));
/**
 * Represents an Identity Certificate as per the Wallet interface specifications.
 *
 * This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.
 */
class Certificate {
    /**
     * Constructs a new Certificate.
     *
     * @param {Base64String} type - Type identifier for the certificate, base64 encoded string, 32 bytes.
     * @param {Base64String} serialNumber - Unique serial number of the certificate, base64 encoded string, 32 bytes.
     * @param {PubKeyHex} subject - The public key belonging to the certificate's subject, compressed public key hex string.
     * @param {PubKeyHex} certifier - Public key of the certifier who issued the certificate, compressed public key hex string.
     * @param {OutpointString} revocationOutpoint - The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.
     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - All the fields present in the certificate.
     * @param {HexString} signature - Certificate signature by the certifier's private key, DER encoded hex string.
     */
    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature) {
        this.type = type;
        this.serialNumber = serialNumber;
        this.subject = subject;
        this.certifier = certifier;
        this.revocationOutpoint = revocationOutpoint;
        this.fields = fields;
        this.signature = signature;
    }
    /**
     * Serializes the certificate into binary format, with or without a signature.
     *
     * @param {boolean} [includeSignature=true] - Whether to include the signature in the serialization.
     * @returns {number[]} - The serialized certificate in binary format.
     */
    toBinary(includeSignature = true) {
        const writer = new Utils.Writer();
        // Write type (Base64String, 32 bytes)
        const typeBytes = Utils.toArray(this.type, 'base64');
        writer.write(typeBytes);
        // Write serialNumber (Base64String, 32 bytes)
        const serialNumberBytes = Utils.toArray(this.serialNumber, 'base64');
        writer.write(serialNumberBytes);
        // Write subject (33 bytes compressed PubKeyHex)
        const subjectBytes = Utils.toArray(this.subject, 'hex');
        writer.write(subjectBytes);
        // Write certifier (33 bytes compressed PubKeyHex)
        const certifierBytes = Utils.toArray(this.certifier, 'hex');
        writer.write(certifierBytes);
        // Write revocationOutpoint (TXID + OutputIndex)
        const [txid, outputIndex] = this.revocationOutpoint.split('.');
        const txidBytes = Utils.toArray(txid, 'hex');
        writer.write(txidBytes);
        writer.writeVarIntNum(Number(outputIndex));
        // Write fields
        // Sort field names lexicographically
        const fieldNames = Object.keys(this.fields).sort();
        writer.writeVarIntNum(fieldNames.length);
        for (const fieldName of fieldNames) {
            const fieldValue = this.fields[fieldName];
            // Field name
            const fieldNameBytes = Utils.toArray(fieldName, 'utf8');
            writer.writeVarIntNum(fieldNameBytes.length);
            writer.write(fieldNameBytes);
            // Field value
            const fieldValueBytes = Utils.toArray(fieldValue, 'utf8');
            writer.writeVarIntNum(fieldValueBytes.length);
            writer.write(fieldValueBytes);
        }
        // Write signature if included
        if (includeSignature && (this.signature ?? '').length > 0) { // ✅ Explicitly handle nullish signature
            const signatureBytes = Utils.toArray(this.signature, 'hex'); // ✅ Type assertion ensures it's a string
            writer.write(signatureBytes);
        }
        return writer.toArray();
    }
    /**
     * Deserializes a certificate from binary format.
     *
     * @param {number[]} bin - The binary data representing the certificate.
     * @returns {Certificate} - The deserialized Certificate object.
     */
    static fromBinary(bin) {
        const reader = new Utils.Reader(bin);
        // Read type
        const typeBytes = reader.read(32);
        const type = Utils.toBase64(typeBytes);
        // Read serialNumber
        const serialNumberBytes = reader.read(32);
        const serialNumber = Utils.toBase64(serialNumberBytes);
        // Read subject (33 bytes)
        const subjectBytes = reader.read(33);
        const subject = Utils.toHex(subjectBytes);
        // Read certifier (33 bytes)
        const certifierBytes = reader.read(33);
        const certifier = Utils.toHex(certifierBytes);
        // Read revocationOutpoint
        const txidBytes = reader.read(32);
        const txid = Utils.toHex(txidBytes);
        const outputIndex = reader.readVarIntNum();
        const revocationOutpoint = `${txid}.${outputIndex}`;
        // Read fields
        const numFields = reader.readVarIntNum();
        const fields = {};
        for (let i = 0; i < numFields; i++) {
            // Field name
            const fieldNameLength = reader.readVarIntNum();
            const fieldNameBytes = reader.read(fieldNameLength);
            const fieldName = Utils.toUTF8(fieldNameBytes);
            // Field value
            const fieldValueLength = reader.readVarIntNum();
            const fieldValueBytes = reader.read(fieldValueLength);
            const fieldValue = Utils.toUTF8(fieldValueBytes);
            fields[fieldName] = fieldValue;
        }
        // Read signature if present
        let signature;
        if (!reader.eof()) {
            const signatureBytes = reader.read();
            const sig = Signature_js_1.default.fromDER(signatureBytes);
            signature = sig.toString('hex');
        }
        return new Certificate(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);
    }
    /**
     * Verifies the certificate's signature.
     *
     * @returns {Promise<boolean>} - A promise that resolves to true if the signature is valid.
     */
    async verify() {
        // A verifier can be any wallet capable of verifying signatures
        const verifier = new ProtoWallet_js_1.default('anyone');
        const verificationData = this.toBinary(false); // Exclude the signature from the verification data
        const signatureHex = this.signature ?? ''; // Provide a fallback value (empty string)
        const { valid } = await verifier.verifySignature({
            signature: Utils.toArray(signatureHex, 'hex'),
            data: verificationData,
            protocolID: [2, 'certificate signature'],
            keyID: `${this.type} ${this.serialNumber}`,
            counterparty: this.certifier // The certifier is the one who signed the certificate
        });
        return valid;
    }
    /**
   * Signs the certificate using the provided certifier wallet.
   *
   * @param {Wallet} certifierWallet - The wallet representing the certifier.
   * @returns {Promise<void>}
   */
    async sign(certifierWallet) {
        if (this.signature != null && this.signature.length > 0) { // ✅ Explicitly checking for null/undefined
            throw new Error(`Certificate has already been signed! Signature present: ${this.signature}`);
        }
        // Ensure the certifier declared is the one actually signing
        this.certifier = (await certifierWallet.getPublicKey({ identityKey: true })).publicKey;
        const preimage = this.toBinary(false); // Exclude the signature when signing
        const { signature } = await certifierWallet.createSignature({
            data: preimage,
            protocolID: [2, 'certificate signature'],
            keyID: `${this.type} ${this.serialNumber}`
        });
        this.signature = Utils.toHex(signature);
    }
    /**
     * Helper function which retrieves the protocol ID and key ID for certificate field encryption.
     *
     * For master certificate creation, no serial number is provided because entropy is required
     * from both the client and the certifier. In this case, the `keyID` is simply the `fieldName`.
     *
     * For VerifiableCertificates verifier keyring creation, both the serial number and field name are available,
     * so the `keyID` is formed by concatenating the `serialNumber` and `fieldName`.
     *
     * @param fieldName - The name of the field within the certificate to be encrypted.
     * @param serialNumber - (Optional) The serial number of the certificate.
     * @returns An object containing:
     *   - `protocolID` (WalletProtocol): The protocol ID for certificate field encryption.
     *   - `keyID` (string): A unique key identifier. It is the `fieldName` if `serialNumber` is undefined,
     *     otherwise it is a combination of `serialNumber` and `fieldName`.
     */
    static getCertificateFieldEncryptionDetails(fieldName, serialNumber) {
        return {
            protocolID: [2, 'certificate field encryption'],
            keyID: serialNumber ? `${serialNumber} ${fieldName}` : fieldName
        };
    }
}
exports.default = Certificate;

},{"../../primitives/Signature.js":58,"../../primitives/utils.js":62,"../../wallet/ProtoWallet.js":108}],5:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MasterCertificate = void 0;
const Certificate_js_1 = __importDefault(require("./Certificate.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
const SymmetricKey_js_1 = __importDefault(require("../../primitives/SymmetricKey.js"));
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
/**
 * MasterCertificate extends the base Certificate class to manage a master keyring, enabling the creation of verifiable certificates.
 *
 * It allows for the selective disclosure of certificate fields by creating a `VerifiableCertificate` for a specific verifier.
 * The `MasterCertificate` can securely decrypt each master key and re-encrypt it for a verifier, creating a customized
 * keyring containing only the keys necessary for the verifier to access designated fields.
 *
 */
class MasterCertificate extends Certificate_js_1.default {
    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, masterKeyring, signature) {
        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);
        // Ensure every field in `fields` is a string and has a corresponding key in `masterKeyring`
        for (const fieldName of Object.keys(fields)) {
            if (masterKeyring[fieldName] === undefined || masterKeyring[fieldName] === '') {
                throw new Error(`Master keyring must contain a value for every field. Missing or empty key for field: "${fieldName}".`);
            }
        }
        this.masterKeyring = masterKeyring;
    }
    /**
     * Encrypts certificate fields for a subject and generates a master keyring.
     * This method returns a master keyring tied to a specific certifier or subject who will validate
     * and sign off on the fields, along with the encrypted certificate fields.
     *
     * @param {ProtoWallet} creatorWallet - The wallet of the creator responsible for encrypting the fields.
     * @param {WalletCounterparty} certifierOrSubject - The certifier or subject who will validate the certificate fields.
     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - A record of certificate field names (under 50 bytes) mapped to their values.
     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.
     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *
     * @returns {Promise<CreateCertificateFieldsResult>} A promise resolving to an object containing:
     *   - `certificateFields` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:
     *     The encrypted certificate fields.
     *   - `masterKeyring` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:
     *     The master keyring containing encrypted revelation keys for each field.
     */
    static async createCertificateFields(creatorWallet, certifierOrSubject, fields, privileged, privilegedReason) {
        const certificateFields = {};
        const masterKeyring = {};
        for (const [fieldName, fieldValue] of Object.entries(fields)) {
            const fieldSymmetricKey = SymmetricKey_js_1.default.fromRandom();
            const encryptedFieldValue = fieldSymmetricKey.encrypt(Utils.toArray(fieldValue, 'utf8'));
            certificateFields[fieldName] = Utils.toBase64(encryptedFieldValue);
            const { ciphertext: encryptedFieldRevelationKey } = await creatorWallet.encrypt({
                plaintext: fieldSymmetricKey.toArray(),
                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName),
                counterparty: certifierOrSubject,
                privileged,
                privilegedReason
            });
            masterKeyring[fieldName] = Utils.toBase64(encryptedFieldRevelationKey);
        }
        return {
            certificateFields,
            masterKeyring
        };
    }
    /**
     * Creates a keyring for a verifier, enabling them to decrypt specific certificate fields.
     * This method decrypts the master field keys for the specified fields and re-encrypts them
     * for the verifier's identity key. The result is a keyring containing the keys necessary
     * for the verifier to access the designated fields.
     *
     * @param {ProtoWallet} subjectWallet - The wallet instance of the subject, used to decrypt and re-encrypt field keys.
     * @param {WalletCounterparty} verifier - The verifier who will receive access to the selectively revealed fields. Can be an identity key as hex, 'anyone', or 'self'.
     * @param {string[]} fieldsToReveal - An array of field names to be revealed to the verifier. Must be a subset of the certificate's fields.
     * @param {string} [originator] - Optional originator identifier, used if additional context is needed for decryption and encryption operations.
     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A keyring mapping field names to encrypted field revelation keys, allowing the verifier to decrypt specified fields.
     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.
     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *
     * @throws {Error} Throws an error if:
     *   - fieldsToReveal is not an array of strings.
     *   - A field in `fieldsToReveal` does not exist in the certificate.
     *   - The decrypted master field key fails to decrypt the corresponding field (indicating an invalid key).
     */
    static async createKeyringForVerifier(subjectWallet, certifier, verifier, fields, fieldsToReveal, masterKeyring, serialNumber, privileged, privilegedReason) {
        if (!Array.isArray(fieldsToReveal)) {
            throw new Error('fieldsToReveal must be an array of strings');
        }
        const fieldRevelationKeyring = {};
        for (const fieldName of fieldsToReveal) {
            // Make sure that fields to reveal is a subset of the certificate fields
            if (fields[fieldName] === undefined || fields[fieldName] === null || fields[fieldName] === '') {
                throw new Error(`Fields to reveal must be a subset of the certificate fields. Missing the "${fieldName}" field.`);
            }
            // Decrypt the master field key and verify that derived key actually decrypts requested field
            const masterFieldKey = (await this.decryptField(subjectWallet, masterKeyring, fieldName, fields[fieldName], certifier, privileged, privilegedReason)).fieldRevelationKey;
            // Encrypt derived fieldRevelationKey for verifier
            const { ciphertext: encryptedFieldRevelationKey } = await subjectWallet.encrypt({
                plaintext: masterFieldKey,
                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName, serialNumber),
                counterparty: verifier,
                privileged,
                privilegedReason
            });
            // Add encryptedFieldRevelationKey to fieldRevelationKeyring
            fieldRevelationKeyring[fieldName] = Utils.toBase64(encryptedFieldRevelationKey);
        }
        // Return the field revelation keyring which can be used to create a verifiable certificate for a verifier.
        return fieldRevelationKeyring;
    }
    /**
     * Issues a new MasterCertificate for a specified subject.
     *
     * This method generates a certificate containing encrypted fields and a keyring
     * for the subject to decrypt all fields. Each field is encrypted with a randomly
     * generated symmetric key, which is then encrypted for the subject. The certificate
     * can also includes a revocation outpoint to manage potential revocation.
     *
     * @param {ProtoWallet} certifierWallet - The wallet of the certifier, used to sign the certificate and encrypt field keys.
     * @param {WalletCounterparty} subject - The subject for whom the certificate is issued.
     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - Unencrypted certificate fields to include, with their names and values.
     * @param {string} certificateType - The type of certificate being issued.
     * @param {function(string, Record<CertificateFieldNameUnder50Bytes, string>?): Promise<string>} getRevocationOutpoint -
     *   Optional function to obtain a revocation outpoint for the certificate. Defaults to a placeholder.
     * @param {function(string): Promise<void>} updateProgress - Optional callback for reporting progress updates during the operation. Defaults to a no-op.
     * @returns {Promise<MasterCertificate>} - A signed MasterCertificate instance containing the encrypted fields and subject specific keyring.
     *
     * @throws {Error} Throws an error if any operation (e.g., encryption, signing) fails during certificate issuance.
     */
    static async issueCertificateForSubject(certifierWallet, subject, fields, certificateType, getRevocationOutpoint = async (_serial) => {
        void _serial; // Explicitly acknowledge unused parameter
        return 'Certificate revocation not tracked.';
    }, serialNumber) {
        // 1. Generate a random serialNumber if not provided
        const finalSerialNumber = serialNumber ?? Utils.toBase64((0, Random_js_1.default)(32));
        // 2. Create encrypted certificate fields and associated master keyring
        const { certificateFields, masterKeyring } = await this.createCertificateFields(certifierWallet, subject, fields);
        // 3. Obtain a revocation outpoint
        const revocationOutpoint = await getRevocationOutpoint(finalSerialNumber);
        // 4. Create new MasterCertificate instance
        const certificate = new MasterCertificate(certificateType, finalSerialNumber, subject, (await certifierWallet.getPublicKey({ identityKey: true })).publicKey, revocationOutpoint, certificateFields, masterKeyring);
        // 5. Sign and return the new MasterCertificate certifying the subject.
        await certificate.sign(certifierWallet);
        return certificate;
    }
    /**
     * Decrypts all fields in the MasterCertificate using the subject's or certifier's wallet.
     *
     * This method allows the subject or certifier to decrypt the `masterKeyring` and retrieve
     * the encryption keys for each field, which are then used to decrypt the corresponding field values.
     * The counterparty used for decryption depends on how the certificate fields were created:
     * - If the certificate is self-signed, the counterparty should be set to 'self'.
     * - Otherwise, the counterparty should always be the other party involved in the certificate issuance process (the subject or certifier).
     *
     * @param {ProtoWallet} subjectOrCertifierWallet - The wallet of the subject or certifier, used to decrypt the master keyring and field values.
     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} masterKeyring - A record containing encrypted keys for each field.
     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} fields - A record of encrypted field names and their values.
     * @param {WalletCounterparty} counterparty - The counterparty responsible for creating or signing the certificate. For self-signed certificates, use 'self'.
     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.
     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} A promise resolving to a record of field names and their decrypted values in plaintext.
     *
     * @throws {Error} Throws an error if the `masterKeyring` is invalid or if decryption fails for any field.
     */
    static async decryptFields(subjectOrCertifierWallet, masterKeyring, fields, counterparty, privileged, privilegedReason) {
        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {
            throw new Error('A MasterCertificate must have a valid masterKeyring!');
        }
        try {
            const decryptedFields = {};
            // Note: we want to iterate through all fields, not just masterKeyring keys/value pairs.
            for (const fieldName of Object.keys(fields)) {
                decryptedFields[fieldName] = (await this.decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fields[fieldName], counterparty, privileged, privilegedReason)).decryptedFieldValue;
            }
            return decryptedFields;
        }
        catch {
            throw new Error('Failed to decrypt all master certificate fields.');
        }
    }
    static async decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fieldValue, counterparty, privileged, privilegedReason) {
        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {
            throw new Error('A MasterCertificate must have a valid masterKeyring!');
        }
        try {
            const { plaintext: fieldRevelationKey } = await subjectOrCertifierWallet.decrypt({
                ciphertext: Utils.toArray(masterKeyring[fieldName], 'base64'),
                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName),
                counterparty,
                privileged,
                privilegedReason
            });
            const decryptedFieldValue = new SymmetricKey_js_1.default(fieldRevelationKey).decrypt(Utils.toArray(fieldValue, 'base64'));
            return {
                fieldRevelationKey,
                decryptedFieldValue: Utils.toUTF8(decryptedFieldValue)
            };
        }
        catch {
            throw new Error('Failed to decrypt certificate field!');
        }
    }
}
exports.MasterCertificate = MasterCertificate;

},{"../../primitives/Random.js":55,"../../primitives/SymmetricKey.js":59,"../../primitives/utils.js":62,"./Certificate.js":4}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifiableCertificate = void 0;
const SymmetricKey_js_1 = __importDefault(require("../../primitives/SymmetricKey.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
const Certificate_js_1 = __importDefault(require("./Certificate.js"));
/**
 * VerifiableCertificate extends the Certificate class, adding functionality to manage a verifier-specific keyring.
 * This keyring allows selective decryption of certificate fields for authorized verifiers.
 */
class VerifiableCertificate extends Certificate_js_1.default {
    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, keyring, signature, decryptedFields) {
        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);
        this.keyring = keyring;
        this.decryptedFields = decryptedFields;
    }
    /**
     *
     * @param {WalletCertificate} certificate – The source certificate that was issued and signed by the certifier.
     * @param {Record<CertificateFieldNameUnder50Bytes, string>} keyring – A allows the verifier to decrypt selected certificate fields.
     * @returns {VerifiableCertificate} – A fully-formed instance containing the
     *   original certificate data plus the supplied keyring.
     */
    static fromCertificate(certificate, keyring) {
        return new VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyring, certificate.signature);
    }
    /**
     * Decrypts selectively revealed certificate fields using the provided keyring and verifier wallet
     * @param {ProtoWallet} verifierWallet - The wallet instance of the certificate's verifier, used to decrypt field keys.
     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A promise that resolves to an object where each key is a field name and each value is the decrypted field value as a string.
     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.
     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.
     * @throws {Error} Throws an error if any of the decryption operations fail, with a message indicating the failure context.
     */
    async decryptFields(verifierWallet, privileged, privilegedReason, originator) {
        if (this.keyring == null || Object.keys(this.keyring).length === 0) {
            throw new Error('A keyring is required to decrypt certificate fields for the verifier.');
        }
        try {
            const decryptedFields = {};
            for (const fieldName in this.keyring) {
                const { plaintext: fieldRevelationKey } = await verifierWallet.decrypt({
                    ciphertext: Utils.toArray(this.keyring[fieldName], 'base64'),
                    ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName, this.serialNumber),
                    counterparty: this.subject,
                    privileged,
                    privilegedReason
                }, originator);
                const fieldValue = new SymmetricKey_js_1.default(fieldRevelationKey).decrypt(Utils.toArray(this.fields[fieldName], 'base64'));
                decryptedFields[fieldName] = Utils.toUTF8(fieldValue);
            }
            return decryptedFields;
        }
        catch (error) {
            throw new Error(`Failed to decrypt selectively revealed certificate fields using keyring: ${String(error instanceof Error ? error.message : error)}`);
        }
    }
}
exports.VerifiableCertificate = VerifiableCertificate;

},{"../../primitives/SymmetricKey.js":59,"../../primitives/utils.js":62,"./Certificate.js":4}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletedProtoWallet = void 0;
//@ts-nocheck
const PrivateKey_js_1 = __importDefault(require("../../../primitives/PrivateKey.js"));
const index_js_1 = require("../../../wallet/index.js");
// Test Mock wallet which extends ProtoWallet but still implements Wallet interface
// Unsupported methods throw
class CompletedProtoWallet extends index_js_1.ProtoWallet {
    constructor(rootKeyOrKeyDeriver) {
        super(rootKeyOrKeyDeriver);
        if (rootKeyOrKeyDeriver instanceof index_js_1.KeyDeriver) {
            this.keyDeriver = rootKeyOrKeyDeriver;
        }
        else if (typeof rootKeyOrKeyDeriver === 'string' ||
            rootKeyOrKeyDeriver instanceof PrivateKey_js_1.default) {
            this.keyDeriver = new index_js_1.CachedKeyDeriver(rootKeyOrKeyDeriver);
        }
        else {
            throw new Error('Invalid key deriver provided');
        }
    }
    async isAuthenticated() {
        throw new Error('not implemented');
    }
    async waitForAuthentication() {
        throw new Error('not implemented');
    }
    async getNetwork() {
        throw new Error('not implemented');
    }
    async getVersion() {
        throw new Error('not implemented');
    }
    async getPublicKey(args) {
        if (args.privileged === true) {
            throw new Error('no privilege support');
        }
        if (args.identityKey === true) {
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            if (args.protocolID == null || typeof args.keyID !== 'string' || args.keyID.trim() === '') {
                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');
            }
            if (this.keyDeriver === null || this.keyDeriver === undefined) {
                throw new Error('keyDeriver is not initialized');
            }
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, typeof args.counterparty === 'string' && args.counterparty.trim() !== ''
                    ? args.counterparty
                    : 'self', Boolean(args.forSelf))
                    .toString()
            };
        }
    }
    async createAction() {
        throw new Error('not implemented');
    }
    async signAction() {
        throw new Error('not implemented');
    }
    async abortAction() {
        throw new Error('not implemented');
    }
    async listActions() {
        throw new Error('not implemented');
    }
    async internalizeAction() {
        throw new Error('not implemented');
    }
    async listOutputs() {
        throw new Error('not implemented');
    }
    async relinquishOutput() {
        throw new Error('not implemented');
    }
    async acquireCertificate() {
        throw new Error('not implemented');
    }
    async listCertificates() {
        throw new Error('not implemented');
    }
    async proveCertificate() {
        throw new Error('not implemented');
    }
    async relinquishCertificate() {
        throw new Error('not implemented');
    }
    async discoverByIdentityKey() {
        throw new Error('not implemented');
    }
    async discoverByAttributes() {
        throw new Error('not implemented');
    }
    async getHeight() {
        throw new Error('not implemented');
    }
    async getHeaderForHeight() {
        throw new Error('not implemented');
    }
}
exports.CompletedProtoWallet = CompletedProtoWallet;

},{"../../../primitives/PrivateKey.js":53,"../../../wallet/index.js":113}],8:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Certificate = void 0;
var Certificate_js_1 = require("./Certificate.js");
Object.defineProperty(exports, "Certificate", { enumerable: true, get: function () { return __importDefault(Certificate_js_1).default; } });
__exportStar(require("./MasterCertificate.js"), exports);
__exportStar(require("./VerifiableCertificate.js"), exports);
__exportStar(require("./__tests/CompletedProtoWallet.js"), exports);

},{"./Certificate.js":4,"./MasterCertificate.js":5,"./VerifiableCertificate.js":6,"./__tests/CompletedProtoWallet.js":7}],9:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthFetch = void 0;
// @ts-nocheck
const Utils = __importStar(require("../../primitives/utils.js"));
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
const P2PKH_js_1 = __importDefault(require("../../script/templates/P2PKH.js"));
const PublicKey_js_1 = __importDefault(require("../../primitives/PublicKey.js"));
const createNonce_js_1 = require("../utils/createNonce.js");
const Peer_js_1 = require("../Peer.js");
const SimplifiedFetchTransport_js_1 = require("../transports/SimplifiedFetchTransport.js");
const SessionManager_js_1 = require("../SessionManager.js");
const index_js_1 = require("../utils/index.js");
const PAYMENT_VERSION = '1.0';
/**
 * AuthFetch provides a lightweight fetch client for interacting with servers
 * over a simplified HTTP transport mechanism. It integrates session management, peer communication,
 * and certificate handling to enable secure and mutually-authenticated requests.
 *
 * Additionally, it automatically handles 402 Payment Required responses by creating
 * and sending BSV payment transactions when necessary.
 */
class AuthFetch {
    /**
    * Constructs a new AuthFetch instance.
    * @param wallet - The wallet instance for signing and authentication.
    * @param requestedCertificates - Optional set of certificates to request from peers.
    */
    constructor(wallet, requestedCertificates, sessionManager, originator) {
        this.callbacks = {};
        this.certificatesReceived = [];
        this.peers = {};
        this.wallet = wallet;
        this.requestedCertificates = requestedCertificates;
        this.sessionManager = sessionManager ?? new SessionManager_js_1.SessionManager();
        this.originator = originator;
    }
    /**
     * Mutually authenticates and sends a HTTP request to a server.
     *
     * 1) Attempt the request.
     * 2) If 402 Payment Required, automatically create and send payment.
     * 3) Return the final response.
     *
     * @param url - The URL to send the request to.
     * @param config - Configuration options for the request, including method, headers, and body.
     * @returns A promise that resolves with the server's response, structured as a Response-like object.
     *
     * @throws Will throw an error if unsupported headers are used or other validation fails.
     */
    async fetch(url, config = {}) {
        if (typeof config.retryCounter === 'number') {
            if (config.retryCounter <= 0) {
                throw new Error('Request failed after maximum number of retries.');
            }
            config.retryCounter--;
        }
        const response = await new Promise((async (resolve, reject) => {
            try {
                // Apply defaults
                const { method = 'GET', headers = {}, body } = config;
                // Extract a base url
                const parsedUrl = new URL(url);
                const baseURL = parsedUrl.origin;
                // Create a new transport for this base url if needed
                let peerToUse;
                if (typeof this.peers[baseURL] === 'undefined') {
                    // Create a peer for the request
                    const newTransport = new SimplifiedFetchTransport_js_1.SimplifiedFetchTransport(baseURL);
                    peerToUse = {
                        peer: new Peer_js_1.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager, undefined, this.originator),
                        pendingCertificateRequests: []
                    };
                    this.peers[baseURL] = peerToUse;
                    this.peers[baseURL].peer.listenForCertificatesReceived((senderPublicKey, certs) => {
                        this.certificatesReceived.push(...certs);
                    });
                    this.peers[baseURL].peer.listenForCertificatesRequested((async (verifier, requestedCertificates) => {
                        try {
                            this.peers[baseURL].pendingCertificateRequests.push(true);
                            const certificatesToInclude = await (0, index_js_1.getVerifiableCertificates)(this.wallet, requestedCertificates, verifier, this.originator);
                            await this.peers[baseURL].peer.sendCertificateResponse(verifier, certificatesToInclude);
                        }
                        finally {
                            // Give the backend 500 ms to process the certificates we just sent, before releasing the queue entry
                            await new Promise(resolve => setTimeout(resolve, 500));
                            this.peers[baseURL].pendingCertificateRequests.shift();
                        }
                    }));
                }
                else {
                    // Check if there's a session associated with this baseURL
                    if (this.peers[baseURL].supportsMutualAuth === false) {
                        // Use standard fetch if mutual authentication is not supported
                        try {
                            const response = await this.handleFetchAndValidate(url, config, this.peers[baseURL]);
                            resolve(response);
                        }
                        catch (error) {
                            reject(error);
                        }
                        return;
                    }
                    peerToUse = this.peers[baseURL];
                }
                // Serialize the simplified fetch request.
                const requestNonce = (0, Random_js_1.default)(32);
                const requestNonceAsBase64 = Utils.toBase64(requestNonce);
                const writer = await this.serializeRequest(method, headers, body, parsedUrl, requestNonce);
                // Setup general message listener to resolve requests once a response is received
                this.callbacks[requestNonceAsBase64] = { resolve, reject };
                const listenerId = peerToUse.peer.listenForGeneralMessages((senderPublicKey, payload) => {
                    // Create a reader
                    const responseReader = new Utils.Reader(payload);
                    // Deserialize first 32 bytes of payload
                    const responseNonceAsBase64 = Utils.toBase64(responseReader.read(32));
                    if (responseNonceAsBase64 !== requestNonceAsBase64) {
                        return;
                    }
                    peerToUse.peer.stopListeningForGeneralMessages(listenerId);
                    // Save the identity key for the peer for future requests, since we have it here.
                    this.peers[baseURL].identityKey = senderPublicKey;
                    this.peers[baseURL].supportsMutualAuth = true;
                    // Status code
                    const statusCode = responseReader.readVarIntNum();
                    // Headers
                    const responseHeaders = {};
                    const nHeaders = responseReader.readVarIntNum();
                    if (nHeaders > 0) {
                        for (let i = 0; i < nHeaders; i++) {
                            const nHeaderKeyBytes = responseReader.readVarIntNum();
                            const headerKeyBytes = responseReader.read(nHeaderKeyBytes);
                            const headerKey = Utils.toUTF8(headerKeyBytes);
                            const nHeaderValueBytes = responseReader.readVarIntNum();
                            const headerValueBytes = responseReader.read(nHeaderValueBytes);
                            const headerValue = Utils.toUTF8(headerValueBytes);
                            responseHeaders[headerKey] = headerValue;
                        }
                    }
                    // Add back the server identity key header
                    responseHeaders['x-bsv-auth-identity-key'] = senderPublicKey;
                    // Body
                    let responseBody;
                    const responseBodyBytes = responseReader.readVarIntNum();
                    if (responseBodyBytes > 0) {
                        responseBody = responseReader.read(responseBodyBytes);
                    }
                    // Create the Response object
                    const responseValue = new Response(responseBody ? new Uint8Array(responseBody) : null, {
                        status: statusCode,
                        statusText: `${statusCode}`,
                        headers: new Headers(responseHeaders)
                    });
                    // Resolve or reject the correct request with the response data
                    this.callbacks[requestNonceAsBase64].resolve(responseValue);
                    // Clean up
                    delete this.callbacks[requestNonceAsBase64];
                });
                // Before sending general messages to the peer, ensure that no certificate requests are pending.
                // This way, the user would need to choose to either allow or reject the certificate request first.
                // If the server has a resource that requires certificates to be sent before access would be granted,
                // this makes sure the user has a chance to send the certificates before the resource is requested.
                if (peerToUse.pendingCertificateRequests.length > 0) {
                    await new Promise(resolve => {
                        setInterval(() => {
                            if (peerToUse.pendingCertificateRequests.length === 0) {
                                resolve();
                            }
                        }, 100); // Check every 100 ms for the user to finish responding
                    });
                }
                // Send the request, now that all listeners are set up
                await peerToUse.peer.toPeer(writer.toArray(), peerToUse.identityKey).catch(async (error) => {
                    if (error.message.includes('Session not found for nonce')) {
                        delete this.peers[baseURL];
                        config.retryCounter ?? (config.retryCounter = 3);
                        const response = await this.fetch(url, config);
                        resolve(response);
                        return;
                    }
                    if (error.message.includes('HTTP server failed to authenticate')) {
                        try {
                            const response = await this.handleFetchAndValidate(url, config, peerToUse);
                            resolve(response);
                            return;
                        }
                        catch (fetchError) {
                            reject(fetchError);
                        }
                    }
                    else {
                        reject(error);
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        }));
        // Check if server requires payment to access the requested route
        if (response.status === 402) {
            // Create and attach a payment, then retry
            return await this.handlePaymentAndRetry(url, config, response);
        }
        return response;
    }
    /**
     * Request Certificates from a Peer
     * @param baseUrl
     * @param certificatesToRequest
     */
    async sendCertificateRequest(baseUrl, certificatesToRequest) {
        const parsedUrl = new URL(baseUrl);
        const baseURL = parsedUrl.origin;
        let peerToUse;
        if (typeof this.peers[baseURL] !== 'undefined') {
            peerToUse = { peer: this.peers[baseURL].peer };
        }
        else {
            const newTransport = new SimplifiedFetchTransport_js_1.SimplifiedFetchTransport(baseURL);
            peerToUse = {
                peer: new Peer_js_1.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager, this.originator)
            };
            this.peers[baseURL] = peerToUse;
        }
        // Return a promise that resolves when certificates are received
        return await new Promise((async (resolve, reject) => {
            // Set up the listener before making the request
            const callbackId = peerToUse.peer.listenForCertificatesReceived((_senderPublicKey, certs) => {
                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);
                this.certificatesReceived.push(...certs);
                resolve(certs);
            });
            try {
                // Initiate the certificate request
                await peerToUse.peer.requestCertificates(certificatesToRequest, peerToUse.identityKey);
            }
            catch (err) {
                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);
                reject(err);
            }
        }));
    }
    /**
     * Return any certificates we've collected thus far, then clear them out.
     */
    consumeReceivedCertificates() {
        return this.certificatesReceived.splice(0);
    }
    /**
     * Serializes the HTTP request to be sent over the Transport.
     *
     * @param method - The HTTP method (e.g., 'GET', 'POST') for the request.
     * @param headers - A record of HTTP headers to include in the request.
     * @param body - The body of the request, if applicable (e.g., for POST/PUT requests).
     * @param parsedUrl - The parsed URL object containing the full request URL.
     * @param requestNonce - A unique random nonce to ensure request integrity.
     * @returns A promise that resolves to a `Writer` containing the serialized request.
     *
     * @throws Will throw an error if unsupported headers are used or serialization fails.
     */
    async serializeRequest(method, headers, body, parsedUrl, requestNonce) {
        const writer = new Utils.Writer();
        // Write request nonce
        writer.write(requestNonce);
        // Method length
        writer.writeVarIntNum(method.length);
        // Method
        writer.write(Utils.toArray(method));
        // Handle pathname (e.g. /path/to/resource)
        if (parsedUrl.pathname.length > 0) {
            // Pathname length
            const pathnameAsArray = Utils.toArray(parsedUrl.pathname);
            writer.writeVarIntNum(pathnameAsArray.length);
            // Pathname
            writer.write(pathnameAsArray);
        }
        else {
            writer.writeVarIntNum(-1);
        }
        // Handle search params (e.g. ?q=hello)
        if (parsedUrl.search.length > 0) {
            // search length
            const searchAsArray = Utils.toArray(parsedUrl.search);
            writer.writeVarIntNum(searchAsArray.length);
            // search
            writer.write(searchAsArray);
        }
        else {
            writer.writeVarIntNum(-1);
        }
        // Construct headers to send / sign:
        // Ensures clients only provided supported HTTP request headers
        // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)
        // - Include a normalized version of the content-type header
        // - Include the authorization header
        const includedHeaders = [];
        for (let [k, v] of Object.entries(headers)) {
            k = k.toLowerCase(); // We will always sign lower-case header keys
            if (k.startsWith('x-bsv-') || k === 'authorization') {
                if (k.startsWith('x-bsv-auth')) {
                    throw new Error('No BSV auth headers allowed here!');
                }
                includedHeaders.push([k, v]);
            }
            else if (k.startsWith('content-type')) {
                // Normalize the Content-Type header by removing any parameters (e.g., "; charset=utf-8")
                v = v.split(';')[0].trim();
                includedHeaders.push([k, v]);
            }
            else {
                throw new Error('Unsupported header in the simplified fetch implementation. Only content-type, authorization, and x-bsv-* headers are supported.');
            }
        }
        // Sort the headers by key to ensure a consistent order for signing and verification.
        includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
        // nHeaders
        writer.writeVarIntNum(includedHeaders.length);
        for (let i = 0; i < includedHeaders.length; i++) {
            // headerKeyLength
            const headerKeyAsArray = Utils.toArray(includedHeaders[i][0], 'utf8');
            writer.writeVarIntNum(headerKeyAsArray.length);
            // headerKey
            writer.write(headerKeyAsArray);
            // headerValueLength
            const headerValueAsArray = Utils.toArray(includedHeaders[i][1], 'utf8');
            writer.writeVarIntNum(headerValueAsArray.length);
            // headerValue
            writer.write(headerValueAsArray);
        }
        // If method typically carries a body and body is undefined, default it
        // This prevents signature verification errors due to mismatch default body types with express
        const methodsThatTypicallyHaveBody = ['POST', 'PUT', 'PATCH', 'DELETE'];
        if (methodsThatTypicallyHaveBody.includes(method.toUpperCase()) && body === undefined) {
            // Check if content-type is application/json
            const contentTypeHeader = includedHeaders.find(([k]) => k === 'content-type');
            if (contentTypeHeader && contentTypeHeader[1].includes('application/json')) {
                body = '{}';
            }
            else {
                body = '';
            }
        }
        // Handle body
        if (body) {
            const reqBody = await this.normalizeBodyToNumberArray(body); // Use the utility function
            writer.writeVarIntNum(reqBody.length);
            writer.write(reqBody);
        }
        else {
            writer.writeVarIntNum(-1); // No body
        }
        return writer;
    }
    /**
     * Handles a non-authenticated fetch requests and validates that the server is not claiming to be authenticated.
     */
    async handleFetchAndValidate(url, config, peerToUse) {
        const response = await fetch(url, config);
        response.headers.forEach(header => {
            if (header.toLocaleLowerCase().startsWith('x-bsv')) {
                throw new Error('The server is trying to claim it has been authenticated when it has not!');
            }
        });
        if (response.ok) {
            peerToUse.supportsMutualAuth = false;
            return response;
        }
        else {
            throw new Error(`Request failed with status: ${response.status}`);
        }
    }
    /**
     * If we get 402 Payment Required, we build a transaction via wallet.createAction()
     * and re-attempt the request with an x-bsv-payment header.
     */
    async handlePaymentAndRetry(url, config = {}, originalResponse) {
        // Make sure the server is using the correct payment version
        const paymentVersion = originalResponse.headers.get('x-bsv-payment-version');
        if (!paymentVersion || paymentVersion !== PAYMENT_VERSION) {
            throw new Error(`Unsupported x-bsv-payment-version response header. Client version: ${PAYMENT_VERSION}, Server version: ${paymentVersion}`);
        }
        // Get required headers from the 402 response
        const satoshisRequiredHeader = originalResponse.headers.get('x-bsv-payment-satoshis-required');
        if (!satoshisRequiredHeader) {
            throw new Error('Missing x-bsv-payment-satoshis-required response header.');
        }
        const satoshisRequired = parseInt(satoshisRequiredHeader);
        if (isNaN(satoshisRequired) || satoshisRequired <= 0) {
            throw new Error('Invalid x-bsv-payment-satoshis-required response header value.');
        }
        const serverIdentityKey = originalResponse.headers.get('x-bsv-auth-identity-key');
        if (typeof serverIdentityKey !== 'string') {
            throw new Error('Missing x-bsv-auth-identity-key response header.');
        }
        const derivationPrefix = originalResponse.headers.get('x-bsv-payment-derivation-prefix');
        if (typeof derivationPrefix !== 'string' || derivationPrefix.length < 1) {
            throw new Error('Missing x-bsv-payment-derivation-prefix response header.');
        }
        // Create a random suffix for the derivation path
        const derivationSuffix = await (0, createNonce_js_1.createNonce)(this.wallet, undefined, this.originator);
        // Derive the script hex from the server identity key
        const { publicKey: derivedPublicKey } = await this.wallet.getPublicKey({
            protocolID: [2, '3241645161d8'],
            keyID: `${derivationPrefix} ${derivationSuffix}`,
            counterparty: serverIdentityKey
        }, this.originator);
        const lockingScript = new P2PKH_js_1.default().lock(PublicKey_js_1.default.fromString(derivedPublicKey).toAddress()).toHex();
        // Create the payment transaction using createAction
        const { tx } = await this.wallet.createAction({
            description: `Payment for request to ${new URL(url).origin}`,
            outputs: [{
                    satoshis: satoshisRequired,
                    lockingScript,
                    customInstructions: JSON.stringify({ derivationPrefix, derivationSuffix, payee: serverIdentityKey }),
                    outputDescription: 'HTTP request payment'
                }],
            options: {
                randomizeOutputs: false
            }
        }, this.originator);
        // Attach the payment to the request headers
        config.headers = config.headers || {};
        config.headers['x-bsv-payment'] = JSON.stringify({
            derivationPrefix,
            derivationSuffix,
            transaction: Utils.toBase64(tx)
        });
        config.retryCounter ?? (config.retryCounter = 3);
        // Re-attempt request with payment attached
        return this.fetch(url, config);
    }
    async normalizeBodyToNumberArray(body) {
        // 0. Null / undefined
        if (body == null) {
            return [];
        }
        // 1. object
        if (typeof body === 'object') {
            return Utils.toArray(JSON.stringify(body, 'utf8'));
        }
        // 2. number[]
        if (Array.isArray(body) && body.every((item) => typeof item === 'number')) {
            return body; // Return the array as is
        }
        // 3. string
        if (typeof body === 'string') {
            return Utils.toArray(body, 'utf8');
        }
        // 4. ArrayBuffer / TypedArrays
        if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
            const typedArray = body instanceof ArrayBuffer ? new Uint8Array(body) : new Uint8Array(body.buffer);
            return Array.from(typedArray);
        }
        // 5. Blob
        if (body instanceof Blob) {
            const arrayBuffer = await body.arrayBuffer();
            return Array.from(new Uint8Array(arrayBuffer));
        }
        // 6. FormData
        if (body instanceof FormData) {
            const entries = [];
            body.forEach((value, key) => {
                entries.push([key, value.toString()]);
            });
            const urlEncoded = new URLSearchParams(entries).toString();
            return Utils.toArray(urlEncoded, 'utf8');
        }
        // 7. URLSearchParams
        if (body instanceof URLSearchParams) {
            return Utils.toArray(body.toString(), 'utf8');
        }
        // 8. ReadableStream
        if (body instanceof ReadableStream) {
            throw new Error('ReadableStream cannot be directly converted to number[].');
        }
        // 9. Fallback
        throw new Error('Unsupported body type in this SimplifiedFetch implementation.');
    }
}
exports.AuthFetch = AuthFetch;

},{"../../primitives/PublicKey.js":54,"../../primitives/Random.js":55,"../../primitives/utils.js":62,"../../script/templates/P2PKH.js":73,"../Peer.js":2,"../SessionManager.js":3,"../transports/SimplifiedFetchTransport.js":12,"../utils/createNonce.js":15,"../utils/index.js":17}],10:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AuthFetch.js"), exports);

},{"./AuthFetch.js":9}],11:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./certificates/index.js"), exports);
__exportStar(require("./Peer.js"), exports);
__exportStar(require("./SessionManager.js"), exports);
__exportStar(require("./types.js"), exports);
__exportStar(require("./utils/index.js"), exports);
__exportStar(require("./clients/index.js"), exports);
__exportStar(require("./transports/index.js"), exports);

},{"./Peer.js":2,"./SessionManager.js":3,"./certificates/index.js":8,"./clients/index.js":10,"./transports/index.js":13,"./types.js":14,"./utils/index.js":17}],12:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimplifiedFetchTransport = void 0;
const Utils = __importStar(require("../../primitives/utils.js"));
// Only bind window.fetch in the browser
const defaultFetch = typeof window !== 'undefined' ? fetch.bind(window) : fetch;
/**
 * Implements an HTTP-specific transport for handling Peer mutual authentication messages.
 * This class integrates with fetch to send and receive authenticated messages between peers.
 */
class SimplifiedFetchTransport {
    /**
     * Constructs a new instance of SimplifiedFetchTransport.
     * @param baseUrl - The base URL for all HTTP requests made by this transport.
     * @param fetchClient - A fetch implementation to use for HTTP requests (default: global fetch).
     */
    constructor(baseUrl, fetchClient = defaultFetch) {
        this.fetchClient = fetchClient;
        this.baseUrl = baseUrl;
    }
    /**
     * Sends a message to an HTTP server using the transport mechanism.
     * Handles both general and authenticated message types. For general messages,
     * the payload is deserialized and sent as an HTTP request. For other message types,
     * the message is sent as a POST request to the `/auth` endpoint.
     *
     * @param message - The AuthMessage to send.
     * @returns A promise that resolves when the message is successfully sent.
     *
     * @throws Will throw an error if no listener has been registered via `onData`.
     */
    async send(message) {
        if (this.onDataCallback == null) {
            throw new Error('Listen before you start speaking. God gave you two ears and one mouth for a reason.');
        }
        if (message.messageType !== 'general') {
            return await new Promise((resolve, reject) => {
                void (async () => {
                    try {
                        const responsePromise = this.fetchClient(`${this.baseUrl}/.well-known/auth`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(message)
                        });
                        // For initialRequest message, mark connection as established and start pool.
                        if (message.messageType !== 'initialRequest') {
                            resolve();
                        }
                        const response = await responsePromise;
                        // Handle the response if data is received and callback is set
                        if (response.ok && (this.onDataCallback != null)) {
                            const responseMessage = await response.json();
                            this.onDataCallback(responseMessage);
                        }
                        else {
                            // Server may be a non authenticated server
                            throw new Error('HTTP server failed to authenticate');
                        }
                        if (message.messageType === 'initialRequest') {
                            resolve();
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                })();
            });
        }
        else {
            // Parse message payload
            const httpRequest = this.deserializeRequestPayload(message.payload);
            // Send the byte array as the HTTP payload
            const url = `${this.baseUrl}${httpRequest.urlPostfix}`;
            const httpRequestWithAuthHeaders = httpRequest;
            if (typeof httpRequest.headers !== 'object') {
                httpRequestWithAuthHeaders.headers = {};
            }
            // Append auth headers in request to server
            httpRequestWithAuthHeaders.headers['x-bsv-auth-version'] = message.version;
            httpRequestWithAuthHeaders.headers['x-bsv-auth-identity-key'] = message.identityKey;
            httpRequestWithAuthHeaders.headers['x-bsv-auth-nonce'] = message.nonce;
            httpRequestWithAuthHeaders.headers['x-bsv-auth-your-nonce'] = message.yourNonce;
            httpRequestWithAuthHeaders.headers['x-bsv-auth-signature'] = Utils.toHex(message.signature);
            httpRequestWithAuthHeaders.headers['x-bsv-auth-request-id'] = httpRequest.requestId;
            // Ensure Content-Type is set for requests with a body
            if (httpRequestWithAuthHeaders.body != null) {
                const headers = httpRequestWithAuthHeaders.headers;
                if (headers['content-type'] == null) {
                    throw new Error('Content-Type header is required for requests with a body.');
                }
                const contentType = String(headers['content-type'] ?? '');
                // Transform body based on Content-Type
                if (contentType.includes('application/json')) {
                    // Convert byte array to JSON string
                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);
                }
                else if (contentType.includes('application/x-www-form-urlencoded')) {
                    // Convert byte array to URL-encoded string
                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);
                }
                else if (contentType.includes('text/plain')) {
                    // Convert byte array to plain UTF-8 string
                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);
                }
                else {
                    // For all other content types, treat as binary data
                    httpRequestWithAuthHeaders.body = new Uint8Array(httpRequestWithAuthHeaders.body);
                }
            }
            // Send the actual fetch request to the server
            const response = await this.fetchClient(url, {
                method: httpRequestWithAuthHeaders.method,
                headers: httpRequestWithAuthHeaders.headers,
                body: httpRequestWithAuthHeaders.body
            });
            // Check for an acceptable status
            if (response.status === 500 && (response.headers.get('x-bsv-auth-request-id') == null &&
                response.headers.get('x-bsv-auth-requested-certificates') == null)) {
                // Try parsing JSON error
                const errorInfo = await response.json();
                // Otherwise just throw whatever we got
                throw new Error(`HTTP ${response.status} - ${JSON.stringify(errorInfo)}`);
            }
            const parsedBody = await response.arrayBuffer();
            const payloadWriter = new Utils.Writer();
            if (response.headers.get('x-bsv-auth-request-id') != null) {
                payloadWriter.write(Utils.toArray(response.headers.get('x-bsv-auth-request-id'), 'base64'));
            }
            payloadWriter.writeVarIntNum(response.status);
            // PARSE RESPONSE HEADERS FROM SERVER --------------------------------
            // Parse response headers from the server and include only the signed headers:
            // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)
            // - Include the authorization header
            const includedHeaders = [];
            response.headers.forEach((value, key) => {
                const lowerKey = key.toLowerCase();
                if ((lowerKey.startsWith('x-bsv-') || lowerKey === 'authorization') && !lowerKey.startsWith('x-bsv-auth')) {
                    includedHeaders.push([lowerKey, value]);
                }
            });
            // Sort the headers by key to ensure a consistent order for signing and verification.
            includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
            // nHeaders
            payloadWriter.writeVarIntNum(includedHeaders.length);
            for (let i = 0; i < includedHeaders.length; i++) {
                // headerKeyLength
                const headerKeyAsArray = Utils.toArray(includedHeaders[i][0], 'utf8');
                payloadWriter.writeVarIntNum(headerKeyAsArray.length);
                // headerKey
                payloadWriter.write(headerKeyAsArray);
                // headerValueLength
                const headerValueAsArray = Utils.toArray(includedHeaders[i][1], 'utf8');
                payloadWriter.writeVarIntNum(headerValueAsArray.length);
                // headerValue
                payloadWriter.write(headerValueAsArray);
            }
            // Handle body
            if (parsedBody != null) {
                const bodyAsArray = Array.from(new Uint8Array(parsedBody));
                payloadWriter.writeVarIntNum(bodyAsArray.length);
                payloadWriter.write(bodyAsArray);
            }
            else {
                payloadWriter.writeVarIntNum(-1);
            }
            // Build the correct AuthMessage for the response
            const responseMessage = {
                version: response.headers.get('x-bsv-auth-version'),
                messageType: response.headers.get('x-bsv-auth-message-type') === 'certificateRequest' ? 'certificateRequest' : 'general',
                identityKey: response.headers.get('x-bsv-auth-identity-key'),
                nonce: response.headers.get('x-bsv-auth-nonce'),
                yourNonce: response.headers.get('x-bsv-auth-your-nonce'),
                requestedCertificates: JSON.parse(response.headers.get('x-bsv-auth-requested-certificates')),
                payload: payloadWriter.toArray(),
                signature: Utils.toArray(response.headers.get('x-bsv-auth-signature'), 'hex')
            };
            // If the server didn't provide the correct authentication headers, throw an error
            if (responseMessage.version == null) {
                throw new Error('HTTP server failed to authenticate');
            }
            // Handle the response if data is received and callback is set
            this.onDataCallback(responseMessage);
        }
    }
    /**
     * Registers a callback to handle incoming messages.
     * This must be called before sending any messages to ensure responses can be processed.
     *
     * @param callback - A function to invoke when an incoming AuthMessage is received.
     * @returns A promise that resolves once the callback is set.
     */
    async onData(callback) {
        this.onDataCallback = (m) => {
            void callback(m);
        };
    }
    /**
     * Deserializes a request payload from a byte array into an HTTP request-like structure.
     *
     * @param payload - The serialized payload to deserialize.
     * @returns An object representing the deserialized request, including the method,
     *          URL postfix (path and query string), headers, body, and request ID.
     */
    deserializeRequestPayload(payload) {
        // Create a reader
        const requestReader = new Utils.Reader(payload);
        // The first 32 bytes is the requestId
        const requestId = Utils.toBase64(requestReader.read(32));
        // Method
        const methodLength = requestReader.readVarIntNum();
        let method = 'GET';
        if (methodLength > 0) {
            method = Utils.toUTF8(requestReader.read(methodLength));
        }
        // Path
        const pathLength = requestReader.readVarIntNum();
        let path = '';
        if (pathLength > 0) {
            path = Utils.toUTF8(requestReader.read(pathLength));
        }
        // Search
        const searchLength = requestReader.readVarIntNum();
        let search = '';
        if (searchLength > 0) {
            search = Utils.toUTF8(requestReader.read(searchLength));
        }
        // Read headers
        const requestHeaders = {};
        const nHeaders = requestReader.readVarIntNum();
        if (nHeaders > 0) {
            for (let i = 0; i < nHeaders; i++) {
                const nHeaderKeyBytes = requestReader.readVarIntNum();
                const headerKeyBytes = requestReader.read(nHeaderKeyBytes);
                const headerKey = Utils.toUTF8(headerKeyBytes);
                const nHeaderValueBytes = requestReader.readVarIntNum();
                const headerValueBytes = requestReader.read(nHeaderValueBytes);
                const headerValue = Utils.toUTF8(headerValueBytes);
                requestHeaders[headerKey] = headerValue;
            }
        }
        // Read body
        let requestBody;
        const requestBodyBytes = requestReader.readVarIntNum();
        if (requestBodyBytes > 0) {
            requestBody = requestReader.read(requestBodyBytes);
        }
        // Return the deserialized RequestInit
        return {
            urlPostfix: path + search,
            method,
            headers: requestHeaders,
            body: requestBody,
            requestId
        };
    }
}
exports.SimplifiedFetchTransport = SimplifiedFetchTransport;

},{"../../primitives/utils.js":62}],13:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SimplifiedFetchTransport.js"), exports);

},{"./SimplifiedFetchTransport.js":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],15:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNonce = void 0;
const Utils = __importStar(require("../../primitives/utils.js"));
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
/**
 * Creates a nonce derived from a wallet
 * @param wallet
 * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.
 * @returns A random nonce derived with a wallet
 */
async function createNonce(wallet, counterparty = 'self', originator) {
    // Generate 16 random bytes for the first half of the data
    const firstHalf = (0, Random_js_1.default)(16);
    // Create an sha256 HMAC
    const { hmac } = await wallet.createHmac({
        protocolID: [2, 'server hmac'],
        keyID: Utils.toUTF8(firstHalf),
        data: firstHalf,
        counterparty
    }, originator);
    // Concatenate firstHalf and secondHalf as the nonce bytes
    const nonceBytes = [...firstHalf, ...hmac];
    return Utils.toBase64(nonceBytes);
}
exports.createNonce = createNonce;

},{"../../primitives/Random.js":55,"../../primitives/utils.js":62}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVerifiableCertificates = void 0;
const VerifiableCertificate_js_1 = require("../certificates/VerifiableCertificate.js");
/**
 * Retrieves an array of verifiable certificates based on the request.
 *
 * @private
 * @param {RequestedCertificateSet} requestedCertificates - The set of certificates requested by the peer.
 * @param {string} verifierIdentityKey - The public key of the verifier requesting the certificates.
 * @returns {Promise<VerifiableCertificate[]>} An array of verifiable certificates.
 */
const getVerifiableCertificates = async (wallet, requestedCertificates, verifierIdentityKey, originator) => {
    // Find matching certificates we have
    // Note: This may return multiple certificates that match the correct type.
    const matchingCertificates = await wallet.listCertificates({
        certifiers: requestedCertificates.certifiers,
        types: Object.keys(requestedCertificates.types)
    }, originator);
    // For each certificate requested, create a verifiable cert with selectively revealed fields
    return await Promise.all(matchingCertificates.certificates.map(async (certificate) => {
        const { keyringForVerifier } = await wallet.proveCertificate({
            certificate,
            fieldsToReveal: requestedCertificates.types[certificate.type],
            verifier: verifierIdentityKey
        }, originator);
        return new VerifiableCertificate_js_1.VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);
    }));
};
exports.getVerifiableCertificates = getVerifiableCertificates;

},{"../certificates/VerifiableCertificate.js":6}],17:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./verifyNonce.js"), exports);
__exportStar(require("./createNonce.js"), exports);
__exportStar(require("./getVerifiableCertificates.js"), exports);
__exportStar(require("./validateCertificates.js"), exports);

},{"./createNonce.js":15,"./getVerifiableCertificates.js":16,"./validateCertificates.js":18,"./verifyNonce.js":19}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCertificates = void 0;
const VerifiableCertificate_js_1 = require("../certificates/VerifiableCertificate.js");
/**
 * Validates and processes the certificates received from a peer.
 *
 * @private
 * @param {AuthMessage} message - The message containing the certificates to validate.
 * @returns {Promise<void>}
 * @throws Will throw an error if certificate validation or field decryption fails.
 */
const validateCertificates = async (verifierWallet, message, certificatesRequested, originator) => {
    if ((message.certificates == null) || message.certificates.length === 0) {
        throw new Error('No certificates were provided in the AuthMessage.');
    }
    await Promise.all(message.certificates.map(async (incomingCert) => {
        if (incomingCert.subject !== message.identityKey) {
            throw new Error(`The subject of one of your certificates ("${incomingCert.subject}") is not the same as the request sender ("${message.identityKey}").`);
        }
        // Verify Certificate structure and signature
        const certToVerify = new VerifiableCertificate_js_1.VerifiableCertificate(incomingCert.type, incomingCert.serialNumber, incomingCert.subject, incomingCert.certifier, incomingCert.revocationOutpoint, incomingCert.fields, incomingCert.keyring, incomingCert.signature);
        const isValidCert = await certToVerify.verify();
        if (!isValidCert) {
            throw new Error(`The signature for the certificate with serial number ${certToVerify.serialNumber} is invalid!`);
        }
        // Check if the certificate matches requested certifiers, types, and fields
        if (certificatesRequested != null) {
            const { certifiers, types } = certificatesRequested;
            // Check certifier matches
            if (!certifiers.includes(certToVerify.certifier)) {
                throw new Error(`Certificate with serial number ${certToVerify.serialNumber} has an unrequested certifier: ${certToVerify.certifier}`);
            }
            // Check type and fields match requested
            const requestedFields = types[certToVerify.type];
            if (requestedFields == null) {
                throw new Error(`Certificate with type ${certToVerify.type} was not requested`);
            }
        }
        // Attempt to decrypt fields
        await certToVerify.decryptFields(verifierWallet, undefined, undefined, originator);
    }));
};
exports.validateCertificates = validateCertificates;

},{"../certificates/VerifiableCertificate.js":6}],19:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyNonce = void 0;
const Utils = __importStar(require("../../primitives/utils.js"));
/**
 * Verifies a nonce derived from a wallet
 * @param nonce - A nonce to verify as a base64 string.
 * @param wallet
 * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.
 * @returns The status of the validation
 */
async function verifyNonce(nonce, wallet, counterparty = 'self', originator) {
    // Convert nonce from base64 string to Uint8Array
    const buffer = Utils.toArray(nonce, 'base64');
    // Split the nonce buffer
    const data = buffer.slice(0, 16);
    const hmac = buffer.slice(16);
    // Calculate the HMAC
    const { valid } = await wallet.verifyHmac({
        data,
        hmac,
        protocolID: [2, 'server hmac'],
        keyID: Utils.toUTF8(data),
        counterparty
    }, originator);
    return valid;
}
exports.verifyNonce = verifyNonce;

},{"../../primitives/utils.js":62}],20:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = exports.magicHash = void 0;
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
const utils_js_1 = require("../primitives/utils.js");
const ECDSA = __importStar(require("../primitives/ECDSA.js"));
const Hash = __importStar(require("../primitives/Hash.js"));
const prefix = 'Bitcoin Signed Message:\n';
/**
 * Generates a SHA256 double-hash of the prefixed message.
 * @deprecated Replaced by BRC-77 which uses a more secure and private method for message signing.
 * @param messageBuf The message buffer to be hashed.
 * @returns The double-hash of the prefixed message as a number array.
 */
const magicHash = (messageBuf) => {
    const bw = new utils_js_1.Writer();
    bw.writeVarIntNum(prefix.length);
    bw.write((0, utils_js_1.toArray)(prefix, 'utf8'));
    bw.writeVarIntNum(messageBuf.length);
    bw.write(messageBuf);
    const buf = bw.toArray();
    const hashBuf = Hash.hash256(buf);
    return hashBuf;
};
exports.magicHash = magicHash;
/**
 * Signs a BSM message using the given private key.
 * @deprecated Replaced by BRC-77 which employs BRC-42 key derivation and BRC-43 invoice numbers for enhanced security and privacy.
 * @param message The message to be signed as a number array.
 * @param privateKey The private key used for signing the message.
 * @param mode The mode of operation. When "base64", the BSM format signature is returned. When "raw", a Signature object is returned. Default: "base64".
 * @returns The signature object when in raw mode, or the BSM base64 string when in base64 mode.
 */
const sign = (message, privateKey, mode = 'base64') => {
    const hashBuf = (0, exports.magicHash)(message);
    const sig = ECDSA.sign(new BigNumber_js_1.default(hashBuf), privateKey, true);
    if (mode === 'raw') {
        return sig;
    }
    const h = new BigNumber_js_1.default(hashBuf);
    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);
    return sig.toCompact(r, true, 'base64');
};
exports.sign = sign;
/**
 * Verifies a BSM signed message using the given public key.
 * @deprecated Replaced by BRC-77 which provides privately-verifiable signatures and avoids key reuse.
 * @param message The message to be verified as a number array.
 * @param sig The signature object.
 * @param pubKey The public key for verification.
 * @returns True if the signature is valid, false otherwise.
 */
const verify = (message, sig, pubKey) => {
    const hashBuf = (0, exports.magicHash)(message);
    return ECDSA.verify(new BigNumber_js_1.default(hashBuf), sig, pubKey);
};
exports.verify = verify;

},{"../primitives/BigNumber.js":42,"../primitives/ECDSA.js":45,"../primitives/Hash.js":46,"../primitives/utils.js":62}],21:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// import { AESWrappercbc } from './aescbc'
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
const PrivateKey_js_1 = __importDefault(require("../primitives/PrivateKey.js"));
const PublicKey_js_1 = __importDefault(require("../primitives/PublicKey.js"));
const Point_js_1 = __importDefault(require("../primitives/Point.js"));
const Hash = __importStar(require("../primitives/Hash.js"));
const utils_js_1 = require("../primitives/utils.js");
function AES(key) {
    if (this._tables[0][0][0] === 0)
        this._precompute();
    let tmp, encKey, decKey;
    const sbox = this._tables[0][4];
    const decTable = this._tables[1];
    const keyLen = key.length;
    let rcon = 1;
    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
        throw new Error('invalid aes key size');
    }
    this._key = [(encKey = key.slice(0)), (decKey = [])];
    // schedule encryption keys
    let i;
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
        tmp = encKey[i - 1];
        // apply sbox
        if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {
            tmp =
                (sbox[tmp >>> 24] << 24) ^
                    (sbox[(tmp >> 16) & 255] << 16) ^
                    (sbox[(tmp >> 8) & 255] << 8) ^
                    sbox[tmp & 255];
            // shift rows and add rcon
            if (i % keyLen === 0) {
                tmp = (tmp << 8) ^ (tmp >>> 24) ^ (rcon << 24);
                rcon = (rcon << 1) ^ ((rcon >> 7) * 283);
            }
        }
        encKey[i] = encKey[i - keyLen] ^ tmp;
    }
    // schedule decryption keys
    for (let j = 0; i > 0; j++, i--) {
        tmp = encKey[(j & 3) !== 0 ? i : i - 4];
        if (i <= 4 || j < 4) {
            decKey[j] = tmp;
        }
        else {
            decKey[j] =
                decTable[0][sbox[tmp >>> 24]] ^
                    decTable[1][sbox[(tmp >> 16) & 255]] ^
                    decTable[2][sbox[(tmp >> 8) & 255]] ^
                    decTable[3][sbox[tmp & 255]];
        }
    }
}
AES.prototype = {
    /**
     * Encrypt an array of 4 big-endian words.
     * @param {Array} data The plaintext.
     * @return {Array} The ciphertext.
     */
    encrypt: function (data) {
        return this._crypt(data, 0);
    },
    /**
     * Decrypt an array of 4 big-endian words.
     * @param {Array} data The ciphertext.
     * @return {Array} The plaintext.
     */
    decrypt: function (data) {
        return this._crypt(data, 1);
    },
    /**
     * The expanded S-box and inverse S-box tables.  These will be computed
     * on the client so that we don't have to send them down the wire.
     *
     * There are two tables, _tables[0] is for encryption and
     * _tables[1] is for decryption.
     *
     * The first 4 sub-tables are the expanded S-box with MixColumns.  The
     * last (_tables[01][4]) is the S-box itself.
     *
     * @private
     */
    _tables: [
        [
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256)
        ],
        [
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256)
        ]
    ],
    // Expand the S-box tables.
    _precompute: function () {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        let i;
        let x;
        let xInv;
        const d = new Uint8Array(256);
        const th = new Uint8Array(256);
        let x2;
        let x4;
        let x8;
        let s;
        let tEnc;
        let tDec;
        // Compute double and third tables
        for (i = 0; i < 256; i++) {
            th[(d[i] = (i << 1) ^ ((i >> 7) * 283)) ^ i] = i;
        }
        for (x = xInv = 0; sbox[x] === 0; x ^= (x2 !== 0 ? x2 : 1), xInv = th[xInv] !== 0 ? th[xInv] : 1) {
            // Compute sbox
            s = xInv ^ (xInv << 1) ^ (xInv << 2) ^ (xInv << 3) ^ (xInv << 4);
            s = (s >> 8) ^ (s & 255) ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;
            // Compute MixColumns
            x8 = d[(x4 = d[(x2 = d[x])])];
            tDec = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            tEnc = (d[s] * 0x101) ^ (s * 0x1010100);
            for (i = 0; i < 4; i++) {
                encTable[i][x] = tEnc = (tEnc << 24) ^ (tEnc >>> 8);
                decTable[i][s] = tDec = (tDec << 24) ^ (tDec >>> 8);
            }
        }
    },
    /**
     * Encryption and decryption core.
     * @param {Array} input Four words to be encrypted or decrypted.
     * @param dir The direction, 0 for encrypt and 1 for decrypt.
     * @return {Array} The four encrypted or decrypted words.
     * @private
     */
    _crypt: function (input, dir) {
        if (input.length !== 4) {
            throw new Error('invalid aes block size');
        }
        const key = this._key[dir];
        // state variables a,b,c,d are loaded with pre-whitened data
        let a = input[0] ^ key[0];
        let b = input[dir === 1 ? 3 : 1] ^ key[1];
        let c = input[2] ^ key[2];
        let d = input[dir === 1 ? 1 : 3] ^ key[3];
        let a2;
        let b2;
        let c2;
        const nInnerRounds = key.length / 4 - 2;
        let i;
        let kIndex = 4;
        const out = new Uint32Array(4);
        const // <--- this is slower in Node, about the same in Chrome */
        table = this._tables[dir];
        // load up the tables
        const t0 = table[0];
        const t1 = table[1];
        const t2 = table[2];
        const t3 = table[3];
        const sbox = table[4];
        // Inner rounds.  Cribbed from OpenSSL.
        for (i = 0; i < nInnerRounds; i++) {
            a2 =
                t0[a >>> 24] ^
                    t1[(b >> 16) & 255] ^
                    t2[(c >> 8) & 255] ^
                    t3[d & 255] ^
                    key[kIndex];
            b2 =
                t0[b >>> 24] ^
                    t1[(c >> 16) & 255] ^
                    t2[(d >> 8) & 255] ^
                    t3[a & 255] ^
                    key[kIndex + 1];
            c2 =
                t0[c >>> 24] ^
                    t1[(d >> 16) & 255] ^
                    t2[(a >> 8) & 255] ^
                    t3[b & 255] ^
                    key[kIndex + 2];
            d =
                t0[d >>> 24] ^
                    t1[(a >> 16) & 255] ^
                    t2[(b >> 8) & 255] ^
                    t3[c & 255] ^
                    key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
        }
        // Last round.
        for (i = 0; i < 4; i++) {
            out[dir === 1 ? 3 & -i : i] =
                (sbox[a >>> 24] << 24) ^
                    (sbox[(b >> 16) & 255] << 16) ^
                    (sbox[(c >> 8) & 255] << 8) ^
                    sbox[d & 255] ^
                    key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
        }
        return out;
    }
};
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class AESWrapper {
    static encrypt(messageBuf, keyBuf) {
        const key = AESWrapper.buf2Words(keyBuf);
        const message = AESWrapper.buf2Words(messageBuf);
        const a = new AES(key);
        const enc = a.encrypt(message);
        const encBuf = AESWrapper.words2Buf(enc);
        return encBuf;
    }
    static decrypt(encBuf, keyBuf) {
        const enc = AESWrapper.buf2Words(encBuf);
        const key = AESWrapper.buf2Words(keyBuf);
        const a = new AES(key);
        const message = a.decrypt(enc);
        const messageBuf = AESWrapper.words2Buf(message);
        return messageBuf;
    }
    static buf2Words(buf) {
        if (buf.length % 4 !== 0) {
            throw new Error('buf length must be a multiple of 4');
        }
        const words = [];
        for (let i = 0; i < buf.length / 4; i++) {
            const val = buf[i * 4] * 0x1000000 + // Shift the first byte by 24 bits
                ((buf[i * 4 + 1] << 16) | // Shift the second byte by 16 bits
                    (buf[i * 4 + 2] << 8) | // Shift the third byte by 8 bits
                    buf[i * 4 + 3]); // The fourth byte
            words.push(val);
        }
        return words;
    }
    static words2Buf(words) {
        const buf = new Array(words.length * 4);
        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            buf[i * 4] = (word >>> 24) & 0xff;
            buf[i * 4 + 1] = (word >>> 16) & 0xff;
            buf[i * 4 + 2] = (word >>> 8) & 0xff;
            buf[i * 4 + 3] = word & 0xff;
        }
        return buf;
    }
}
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class CBC {
    static buf2BlocksBuf(buf, blockSize) {
        const bytesize = blockSize / 8;
        const blockBufs = [];
        for (let i = 0; i <= buf.length / bytesize; i++) {
            let blockBuf = buf.slice(i * bytesize, i * bytesize + bytesize);
            if (blockBuf.length < blockSize) {
                blockBuf = CBC.pkcs7Pad(blockBuf, blockSize);
            }
            blockBufs.push(blockBuf);
        }
        return blockBufs;
    }
    static blockBufs2Buf(blockBufs) {
        let last = blockBufs[blockBufs.length - 1];
        last = CBC.pkcs7Unpad(last);
        blockBufs[blockBufs.length - 1] = last;
        const buf = blockBufs.flat();
        return buf;
    }
    static encrypt(messageBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const blockSize = ivBuf.length * 8;
        const blockBufs = CBC.buf2BlocksBuf(messageBuf, blockSize);
        const encBufs = CBC.encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf);
        const encBuf = encBufs.flat();
        return encBuf;
    }
    static decrypt(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const bytesize = ivBuf.length;
        const encBufs = [];
        for (let i = 0; i < encBuf.length / bytesize; i++) {
            encBufs.push(encBuf.slice(i * bytesize, i * bytesize + bytesize));
        }
        const blockBufs = CBC.decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf);
        const buf = CBC.blockBufs2Buf(blockBufs);
        return buf;
    }
    static encryptBlock(blockBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const xorbuf = CBC.xorBufs(blockBuf, ivBuf);
        const encBuf = blockCipher.encrypt(xorbuf, cipherKeyBuf);
        return encBuf;
    }
    static decryptBlock(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const xorbuf = blockCipher.decrypt(encBuf, cipherKeyBuf);
        const blockBuf = CBC.xorBufs(xorbuf, ivBuf);
        return blockBuf;
    }
    static encryptBlocks(blockBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const encBufs = [];
        for (let i = 0; i < blockBufs.length; i++) {
            const blockBuf = blockBufs[i];
            const encBuf = CBC.encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf);
            encBufs.push(encBuf);
            ivBuf = encBuf;
        }
        return encBufs;
    }
    static decryptBlocks(encBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const blockBufs = [];
        for (let i = 0; i < encBufs.length; i++) {
            const encBuf = encBufs[i];
            const blockBuf = CBC.decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf);
            blockBufs.push(blockBuf);
            ivBuf = encBuf;
        }
        return blockBufs;
    }
    static pkcs7Pad(buf, blockSize) {
        const bytesize = blockSize / 8;
        const padbytesize = bytesize - buf.length;
        const pad = new Array(padbytesize);
        pad.fill(padbytesize);
        const paddedbuf = [...buf, ...pad];
        return paddedbuf;
    }
    static pkcs7Unpad(paddedbuf) {
        const padlength = paddedbuf[paddedbuf.length - 1];
        const padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);
        const padbuf2 = new Array(padlength);
        padbuf2.fill(padlength);
        if ((0, utils_js_1.toHex)(padbuf) !== (0, utils_js_1.toHex)(padbuf2)) {
            throw new Error('invalid padding');
        }
        return paddedbuf.slice(0, paddedbuf.length - padlength);
    }
    static xorBufs(buf1, buf2) {
        if (buf1.length !== buf2.length) {
            throw new Error('bufs must have the same length');
        }
        const buf = new Array(buf1.length);
        for (let i = 0; i < buf1.length; i++) {
            buf[i] = buf1[i] ^ buf2[i];
        }
        return buf;
    }
}
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class AESCBC {
    static encrypt(messageBuf, cipherKeyBuf, ivBuf, concatIvBuf = true) {
        ivBuf = ivBuf ?? (0, Random_js_1.default)(128 / 8);
        const ctBuf = CBC.encrypt(messageBuf, ivBuf, AESWrapper, cipherKeyBuf);
        if (concatIvBuf) {
            return [...ivBuf, ...ctBuf];
        }
        else {
            return [...ctBuf];
        }
    }
    static decrypt(encBuf, cipherKeyBuf, ivBuf) {
        if (ivBuf == null) {
            ivBuf = encBuf.slice(0, 128 / 8);
            const ctBuf = encBuf.slice(128 / 8);
            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);
        }
        else {
            const ctBuf = encBuf;
            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);
        }
    }
}
/**
 * @class ECIES
 * Implements the Electrum ECIES protocol for encrypted communication.
 *
 * @prprecated This class is deprecated in favor of the BRC-78 standard for portable encrypted messages,
 * which provides a more comprehensive and secure solution by integrating with BRC-42 and BRC-43 standards.
 */
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class ECIES {
    /**
     * Generates the initialization vector (iv), encryption key (kE), and MAC key (kM)
     * using the sender's private key and receiver's public key.
     *
     * @param {PrivateKey} privKey - The sender's private key.
     * @param {PublicKey} pubKey - The receiver's public key.
     * @returns {Object} An object containing the iv, kE, and kM as number arrays.
     */
    static ivkEkM(privKey, pubKey) {
        const r = privKey;
        const KB = pubKey;
        const P = KB.mul(r);
        const S = new PublicKey_js_1.default(P.x, P.y);
        const Sbuf = S.encode(true);
        const hash = Hash.sha512(Sbuf);
        return {
            iv: hash.slice(0, 16),
            kE: hash.slice(16, 32),
            kM: hash.slice(32, 64)
        };
    }
    /**
     * Encrypts a given message using the Electrum ECIES method.
     *
     * @param {number[]} messageBuf - The message to be encrypted, in number array format.
     * @param {PublicKey} toPublicKey - The public key of the recipient.
     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.
     * @param {boolean} [noKey=false] - If true, does not include the sender's public key in the encrypted message.
     * @returns {number[]} The encrypted message as a number array.
     */
    static electrumEncrypt(messageBuf, toPublicKey, fromPrivateKey, noKey = false) {
        let Rbuf = null;
        if (fromPrivateKey == null) {
            fromPrivateKey = PrivateKey_js_1.default.fromRandom();
        }
        if (!noKey) {
            Rbuf = fromPrivateKey.toPublicKey().encode(true);
        }
        const { iv, kE, kM } = ECIES.ivkEkM(fromPrivateKey, toPublicKey);
        const ciphertext = AESCBC.encrypt(messageBuf, kE, iv, false);
        const BIE1 = (0, utils_js_1.toArray)('BIE1', 'utf8');
        let encBuf;
        if (Rbuf !== undefined && Rbuf !== null && Rbuf.length > 0) {
            encBuf = [...BIE1, ...Rbuf, ...ciphertext];
        }
        else {
            encBuf = [...BIE1, ...ciphertext];
        }
        const hmac = Hash.sha256hmac(kM, encBuf);
        return [...encBuf, ...hmac];
    }
    /**
     * Decrypts a message encrypted using the Electrum ECIES method.
     *
     * @param {number[]} encBuf - The encrypted message buffer.
     * @param {PrivateKey} toPrivateKey - The private key of the recipient.
     * @param {PublicKey} [fromPublicKey=null] - The public key of the sender. If not provided, it is extracted from the message.
     * @returns {number[]} The decrypted message as a number array.
     */
    static electrumDecrypt(encBuf, toPrivateKey, fromPublicKey) {
        const tagLength = 32;
        const magic = encBuf.slice(0, 4);
        if ((0, utils_js_1.encode)(magic, 'utf8') !== 'BIE1') {
            throw new Error('Invalid Magic');
        }
        let offset = 4;
        // Determine if the sender's public key is included in encBuf
        let Rbuf = null;
        if (encBuf.length - offset - tagLength >= 33) {
            const firstByte = encBuf[offset];
            if (firstByte === 0x02 || firstByte === 0x03) {
                // Compressed public key
                Rbuf = encBuf.slice(offset, offset + 33);
                offset += 33;
            }
            else if (firstByte === 0x04) {
                // Uncompressed public key
                Rbuf = encBuf.slice(offset, offset + 65);
                offset += 65;
            }
        }
        if (Rbuf !== null) {
            if (fromPublicKey == null) {
                fromPublicKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(Rbuf));
            }
        }
        else {
            if (fromPublicKey == null) {
                throw new Error('Sender public key is required');
            }
        }
        const { iv, kE, kM } = ECIES.ivkEkM(toPrivateKey, fromPublicKey);
        const ciphertext = encBuf.slice(offset, encBuf.length - tagLength);
        const hmac = encBuf.slice(encBuf.length - tagLength, encBuf.length);
        const hmac2 = Hash.sha256hmac(kM, encBuf.slice(0, encBuf.length - tagLength));
        if ((0, utils_js_1.toHex)(hmac) !== (0, utils_js_1.toHex)(hmac2)) {
            throw new Error('Invalid checksum');
        }
        return AESCBC.decrypt(ciphertext, kE, iv);
    }
    /**
     * Encrypts a given message using the Bitcore variant of ECIES.
     *
     * @param {number[]} messageBuf - The message to be encrypted, in number array format.
     * @param {PublicKey} toPublicKey - The public key of the recipient.
     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.
     * @param {number[]} [ivBuf] - The initialization vector for encryption. If not provided, a random IV is used.
     * @returns {number[]} The encrypted message as a number array.
     */
    static bitcoreEncrypt(messageBuf, toPublicKey, fromPrivateKey, ivBuf) {
        if (fromPrivateKey == null) {
            fromPrivateKey = PrivateKey_js_1.default.fromRandom();
        }
        if (ivBuf == null) {
            ivBuf = (0, Random_js_1.default)(16);
        }
        const r = fromPrivateKey;
        const RPublicKey = fromPrivateKey.toPublicKey();
        const RBuf = RPublicKey.encode(true);
        const KB = toPublicKey;
        const P = KB.mul(r);
        const S = P.getX();
        const Sbuf = S.toArray('be', 32);
        const kEkM = Hash.sha512(Sbuf);
        const kE = kEkM.slice(0, 32);
        const kM = kEkM.slice(32, 64);
        const c = AESCBC.encrypt(messageBuf, kE, ivBuf);
        const d = Hash.sha256hmac(kM, [...c]);
        const encBuf = [...RBuf, ...c, ...d];
        return encBuf;
    }
    /**
     * Decrypts a message encrypted using the Bitcore variant of ECIES.
     *
     * @param {number[]} encBuf - The encrypted message buffer.
     * @param {PrivateKey} toPrivateKey - The private key of the recipient.
     * @returns {number[]} The decrypted message as a number array.
     */
    static bitcoreDecrypt(encBuf, toPrivateKey) {
        const kB = toPrivateKey;
        const fromPublicKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(encBuf.slice(0, 33)));
        const R = fromPublicKey;
        const P = R.mul(kB);
        if (P.eq(new Point_js_1.default(0, 0))) {
            throw new Error('P equals 0');
        }
        const S = P.getX();
        const Sbuf = S.toArray('be', 32);
        const kEkM = Hash.sha512(Sbuf);
        const kE = kEkM.slice(0, 32);
        const kM = kEkM.slice(32, 64);
        const c = encBuf.slice(33, encBuf.length - 32);
        const d = encBuf.slice(encBuf.length - 32, encBuf.length);
        const d2 = Hash.sha256hmac(kM, c);
        if ((0, utils_js_1.toHex)(d) !== (0, utils_js_1.toHex)(d2)) {
            throw new Error('Invalid checksum');
        }
        const messageBuf = AESCBC.decrypt(c, kE);
        return [...messageBuf];
    }
}
exports.default = ECIES;

},{"../primitives/Hash.js":46,"../primitives/Point.js":51,"../primitives/PrivateKey.js":53,"../primitives/PublicKey.js":54,"../primitives/Random.js":55,"../primitives/utils.js":62}],22:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
const utils_js_1 = require("../primitives/utils.js");
const Hash = __importStar(require("../primitives/Hash.js"));
const Curve_js_1 = __importDefault(require("../primitives/Curve.js"));
const PrivateKey_js_1 = __importDefault(require("../primitives/PrivateKey.js"));
const PublicKey_js_1 = __importDefault(require("../primitives/PublicKey.js"));
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
/**
 * @deprecated
 * The HD class implements the Bitcoin Improvement Proposal 32 (BIP32) hierarchical deterministic wallets.
 * It allows the generation of child keys from a master key, ensuring a tree-like structure of keys and addresses.
 * This class is deprecated due to the introduction of BRC-42, which offers an enhanced key derivation scheme.
 * BRC-42 uses invoice numbers for key derivation, improving privacy and scalability compared to BIP32.
 *
 * @class HD
 * @deprecated Replaced by BRC-42 which uses invoice numbers and supports private derivation.
 */
class HD {
    /**
     * Constructor for the BIP32 HD wallet.
     * Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.
     * @param versionBytesNum - Version bytes number for the wallet.
     * @param depth - Depth of the key in the hierarchy.
     * @param parentFingerPrint - Fingerprint of the parent key.
     * @param childIndex - Index of the child key.
     * @param chainCode - Chain code for key derivation.
     * @param privKey - Private key of the wallet.
     * @param pubKey - Public key of the wallet.
     */
    constructor(versionBytesNum, depth, parentFingerPrint, childIndex, chainCode, privKey, pubKey) {
        this.constants = {
            pubKey: 0x0488b21e,
            privKey: 0x0488ade4
        };
        this.versionBytesNum = versionBytesNum;
        this.depth = depth;
        this.parentFingerPrint = parentFingerPrint;
        this.childIndex = childIndex;
        this.chainCode = chainCode;
        this.privKey = privKey;
        this.pubKey = pubKey;
    }
    /**
     * Generates a new HD wallet with random keys.
     * This method creates a root HD wallet with randomly generated private and public keys.
     * @returns {HD} The current HD instance with generated keys.
     */
    fromRandom() {
        this.versionBytesNum = this.constants.privKey;
        this.depth = 0x00;
        this.parentFingerPrint = [0, 0, 0, 0];
        this.childIndex = 0;
        this.chainCode = (0, Random_js_1.default)(32);
        this.privKey = PrivateKey_js_1.default.fromRandom();
        this.pubKey = this.privKey.toPublicKey();
        return this;
    }
    /**
     * Generates a new HD wallet with random keys.
     * This method creates a root HD wallet with randomly generated private and public keys.
     * @returns {HD} A new HD instance with generated keys.
     * @static
     */
    static fromRandom() {
        return new this().fromRandom();
    }
    /**
     * Initializes the HD wallet from a given base58 encoded string.
     * This method decodes a provided string to set up the HD wallet's properties.
     * @param str - A base58 encoded string representing the wallet.
     * @returns {HD} The new instance with properties set from the string.
     */
    static fromString(str) {
        return new this().fromString(str);
    }
    /**
     * Initializes the HD wallet from a given base58 encoded string.
     * This method decodes a provided string to set up the HD wallet's properties.
     * @param str - A base58 encoded string representing the wallet.
     * @returns {HD} The current instance with properties set from the string.
     */
    fromString(str) {
        const decoded = (0, utils_js_1.fromBase58Check)(str);
        return this.fromBinary([...decoded.prefix, ...decoded.data]);
    }
    /**
     * Initializes the HD wallet from a seed.
     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.
     * @param bytes - An array of bytes representing the seed.
     * @returns {HD} The current instance with properties set from the seed.
     */
    static fromSeed(bytes) {
        return new this().fromSeed(bytes);
    }
    /**
     * Initializes the HD wallet from a seed.
     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.
     * @param bytes - An array of bytes representing the seed.
     * @returns {HD} The current instance with properties set from the seed.
     */
    fromSeed(bytes) {
        if (bytes.length < 128 / 8) {
            throw new Error('Need more than 128 bits of entropy');
        }
        if (bytes.length > 512 / 8) {
            throw new Error('More than 512 bits of entropy is nonstandard');
        }
        const hash = Hash.sha512hmac((0, utils_js_1.toArray)('Bitcoin seed', 'utf8'), bytes);
        this.depth = 0x00;
        this.parentFingerPrint = [0, 0, 0, 0];
        this.childIndex = 0;
        this.chainCode = hash.slice(32, 64);
        this.versionBytesNum = this.constants.privKey;
        this.privKey = new PrivateKey_js_1.default(hash.slice(0, 32));
        this.pubKey = this.privKey.toPublicKey();
        return this;
    }
    /**
     * Initializes the HD wallet from a binary buffer.
     * Parses a binary buffer to set up the wallet's properties.
     * @param buf - A buffer containing the wallet data.
     * @returns {HD} The new instance with properties set from the buffer.
     */
    static fromBinary(buf) {
        return new this().fromBinary(buf);
    }
    /**
     * Initializes the HD wallet from a binary buffer.
     * Parses a binary buffer to set up the wallet's properties.
     * @param buf - A buffer containing the wallet data.
     * @returns {HD} The current instance with properties set from the buffer.
     */
    fromBinary(buf) {
        // Both pub and private extended keys are 78 buf
        if (buf.length !== 78) {
            throw new Error('incorrect bip32 data length');
        }
        const reader = new utils_js_1.Reader(buf);
        this.versionBytesNum = reader.readUInt32BE();
        this.depth = reader.readUInt8();
        this.parentFingerPrint = reader.read(4);
        this.childIndex = reader.readUInt32BE();
        this.chainCode = reader.read(32);
        const keyBytes = reader.read(33);
        const isPrivate = this.versionBytesNum === this.constants.privKey;
        const isPublic = this.versionBytesNum === this.constants.pubKey;
        if (isPrivate && keyBytes[0] === 0) {
            this.privKey = new PrivateKey_js_1.default(keyBytes.slice(1, 33));
            this.pubKey = this.privKey.toPublicKey();
        }
        else if (isPublic && (keyBytes[0] === 0x02 || keyBytes[0] === 0x03)) {
            this.pubKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(keyBytes));
        }
        else {
            throw new Error('Invalid key');
        }
        return this;
    }
    /**
     * Converts the HD wallet to a base58 encoded string.
     * This method provides a string representation of the HD wallet's current state.
     * @returns {string} A base58 encoded string of the HD wallet.
     */
    toString() {
        const bin = this.toBinary();
        return (0, utils_js_1.toBase58Check)(bin, []);
    }
    /**
     * Derives a child HD wallet based on a given path.
     * The path specifies the hierarchy of the child key to be derived.
     * @param path - A string representing the derivation path (e.g., 'm/0'/1).
     * @returns {HD} A new HD instance representing the derived child wallet.
     */
    derive(path) {
        if (path === 'm') {
            return this;
        }
        const e = path.split('/');
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let bip32 = this;
        for (const [i, c] of e.entries()) {
            if (i === 0) { // Since `i` is now a number, compare it to 0
                if (c !== 'm') {
                    throw new Error('invalid path');
                }
                continue;
            }
            if (parseInt(c.replace("'", ''), 10).toString() !== c.replace("'", '')) {
                throw new Error('invalid path');
            }
            const usePrivate = c.length > 1 && c[c.length - 1] === "'";
            let childIndex = parseInt(usePrivate ? c.slice(0, c.length - 1) : c, 10) & 0x7fffffff;
            if (usePrivate) {
                childIndex += 0x80000000;
            }
            bip32 = bip32.deriveChild(childIndex);
        }
        return bip32;
    }
    /**
     * Derives a child HD wallet from the current wallet based on an index.
     * This method generates either a private or public child key depending on the current wallet's state.
     * @param i - The index of the child key to derive.
     * @returns {HD} A new HD instance representing the derived child wallet.
     */
    deriveChild(i) {
        if (typeof i !== 'number') {
            throw new Error('i must be a number');
        }
        const ibc = [];
        ibc.push((i >> 24) & 0xff);
        ibc.push((i >> 16) & 0xff);
        ibc.push((i >> 8) & 0xff);
        ibc.push(i & 0xff);
        const ib = [...ibc];
        const usePrivate = (i & 0x80000000) !== 0;
        const isPrivate = this.versionBytesNum === this.constants.privKey;
        if (usePrivate && (this.privKey === null || this.privKey === undefined || !isPrivate)) {
            throw new Error('Cannot do private key derivation without private key');
        }
        let ret = null;
        if (this.privKey !== null && this.privKey !== undefined) {
            let data = null;
            if (usePrivate) {
                data = [0, ...this.privKey.toArray('be', 32), ...ib];
            }
            else {
                data = [...this.pubKey.encode(true), ...ib];
            }
            const hash = Hash.sha512hmac(this.chainCode, data);
            const il = new BigNumber_js_1.default(hash.slice(0, 32));
            const ir = hash.slice(32, 64);
            // ki = IL + kpar (mod n).
            const k = il.add(this.privKey).mod(new Curve_js_1.default().n);
            ret = new HD();
            ret.chainCode = ir;
            ret.privKey = new PrivateKey_js_1.default(k.toArray());
            ret.pubKey = ret.privKey.toPublicKey();
        }
        else {
            const data = [...this.pubKey.encode(true), ...ib];
            const hash = Hash.sha512hmac(this.chainCode, data);
            const il = new BigNumber_js_1.default(hash.slice(0, 32));
            const ir = hash.slice(32, 64);
            // Ki = (IL + kpar)*G = IL*G + Kpar
            const ilG = new Curve_js_1.default().g.mul(il);
            const Kpar = this.pubKey;
            const Ki = ilG.add(Kpar);
            const newpub = new PublicKey_js_1.default(Ki.x, Ki.y);
            ret = new HD();
            ret.chainCode = ir;
            ret.pubKey = newpub;
        }
        ret.childIndex = i;
        const pubKeyhash = Hash.hash160(this.pubKey.encode(true));
        ret.parentFingerPrint = pubKeyhash.slice(0, 4);
        ret.versionBytesNum = this.versionBytesNum;
        ret.depth = this.depth + 1;
        return ret;
    }
    /**
     * Converts the current HD wallet to a public-only wallet.
     * This method strips away the private key information, leaving only the public part.
     * @returns {HD} A new HD instance representing the public-only wallet.
     */
    toPublic() {
        const bip32 = new HD(this.versionBytesNum, this.depth, this.parentFingerPrint, this.childIndex, this.chainCode, this.privKey, this.pubKey);
        bip32.versionBytesNum = this.constants.pubKey;
        bip32.privKey = undefined;
        return bip32;
    }
    /**
     * Converts the HD wallet into a binary representation.
     * This method serializes the wallet's properties into a binary format.
     * @returns {number[]} An array of numbers representing the binary data of the wallet.
     */
    toBinary() {
        const isPrivate = this.versionBytesNum === this.constants.privKey;
        const isPublic = this.versionBytesNum === this.constants.pubKey;
        if (isPrivate) {
            return new utils_js_1.Writer()
                .writeUInt32BE(this.versionBytesNum)
                .writeUInt8(this.depth)
                .write(this.parentFingerPrint)
                .writeUInt32BE(this.childIndex)
                .write(this.chainCode)
                .writeUInt8(0)
                .write(this.privKey.toArray('be', 32))
                .toArray();
        }
        else if (isPublic) {
            return new utils_js_1.Writer()
                .writeUInt32BE(this.versionBytesNum)
                .writeUInt8(this.depth)
                .write(this.parentFingerPrint)
                .writeUInt32BE(this.childIndex)
                .write(this.chainCode)
                .write(this.pubKey.encode(true))
                .toArray();
        }
        else {
            throw new Error('bip32: invalid versionBytesNum byte');
        }
    }
    /**
     * Checks if the HD wallet contains a private key.
     * This method determines whether the wallet is a private key wallet or a public key only wallet.
     * @returns {boolean} A boolean value indicating whether the wallet has a private key (true) or not (false).
     */
    isPrivate() {
        return this.versionBytesNum === this.constants.privKey;
    }
}
exports.default = HD;

},{"../primitives/BigNumber.js":42,"../primitives/Curve.js":43,"../primitives/Hash.js":46,"../primitives/PrivateKey.js":53,"../primitives/PublicKey.js":54,"../primitives/Random.js":55,"../primitives/utils.js":62}],23:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip_39_wordlist_en_js_1 = require("./bip-39-wordlist-en.js");
const utils_js_1 = require("../primitives/utils.js");
const Hash = __importStar(require("../primitives/Hash.js"));
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
/**
 * @class Mnemonic
 *
 * @description
 * Class representing Mnemonic functionality.
 * This class provides methods for generating, converting, and validating mnemonic phrases
 * according to the BIP39 standard. It supports creating mnemonics from random entropy,
 * converting mnemonics to seeds, and validating mnemonic phrases.
 */
class Mnemonic {
    /**
     * Constructs a Mnemonic object.
     * @param {string} [mnemonic] - An optional mnemonic phrase.
     * @param {number[]} [seed] - An optional seed derived from the mnemonic.
     * @param {object} [wordlist=wordList] - An object containing a list of words and space character used in the mnemonic.
     */
    constructor(mnemonic, seed, wordlist = bip_39_wordlist_en_js_1.wordList) {
        this.mnemonic = mnemonic ?? ''; // Default to empty string if undefined
        this.seed = seed ?? []; // Default to empty array if undefined
        this.Wordlist = wordlist;
    }
    /**
     * Converts the mnemonic and seed into a binary representation.
     * @returns {number[]} The binary representation of the mnemonic and seed.
     */
    toBinary() {
        const bw = new utils_js_1.Writer();
        if (this.mnemonic !== '') {
            const buf = (0, utils_js_1.toArray)(this.mnemonic, 'utf8');
            bw.writeVarIntNum(buf.length);
            bw.write(buf);
        }
        else {
            bw.writeVarIntNum(0);
        }
        if (this.seed.length > 0) {
            bw.writeVarIntNum(this.seed.length);
            bw.write(this.seed);
        }
        else {
            bw.writeVarIntNum(0);
        }
        return bw.toArray();
    }
    /**
     * Loads a mnemonic and seed from a binary representation.
     * @param {number[]} bin - The binary representation of a mnemonic and seed.
     * @returns {this} The Mnemonic instance with loaded mnemonic and seed.
     */
    fromBinary(bin) {
        const br = new utils_js_1.Reader(bin);
        const mnemoniclen = br.readVarIntNum();
        if (mnemoniclen > 0) {
            this.mnemonic = (0, utils_js_1.encode)(br.read(mnemoniclen), 'utf8');
        }
        const seedlen = br.readVarIntNum();
        if (seedlen > 0) {
            this.seed = br.read(seedlen);
        }
        return this;
    }
    /**
     * Generates a random mnemonic from a given bit length.
     * @param {number} [bits=128] - The bit length for the random mnemonic (must be a multiple of 32 and at least 128).
     * @returns {this} The Mnemonic instance with the new random mnemonic.
     * @throws {Error} If the bit length is not a multiple of 32 or is less than 128.
     */
    fromRandom(bits) {
        if (bits === undefined || bits === null || isNaN(bits) || bits === 0) {
            bits = 128;
        }
        if (bits % 32 !== 0) {
            throw new Error('bits must be multiple of 32');
        }
        if (bits < 128) {
            throw new Error('bits must be at least 128');
        }
        const buf = (0, Random_js_1.default)(bits / 8);
        this.entropy2Mnemonic(buf);
        this.mnemonic2Seed();
        return this;
    }
    /**
     * Static method to generate a Mnemonic instance with a random mnemonic.
     * @param {number} [bits=128] - The bit length for the random mnemonic.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
    static fromRandom(bits) {
        return new this().fromRandom(bits);
    }
    /**
     * Converts given entropy into a mnemonic phrase.
     * This method is used to generate a mnemonic from a specific entropy source.
     * @param {number[]} buf - The entropy buffer, must be at least 128 bits.
     * @returns {this} The Mnemonic instance with the mnemonic set from the given entropy.
     * @throws {Error} If the entropy is less than 128 bits.
     */
    fromEntropy(buf) {
        this.entropy2Mnemonic(buf);
        return this;
    }
    /**
     * Static method to create a Mnemonic instance from a given entropy.
     * @param {number[]} buf - The entropy buffer.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
    static fromEntropy(buf) {
        return new this().fromEntropy(buf);
    }
    /**
     * Sets the mnemonic for the instance from a string.
     * @param {string} mnemonic - The mnemonic phrase as a string.
     * @returns {this} The Mnemonic instance with the set mnemonic.
     */
    fromString(mnemonic) {
        this.mnemonic = mnemonic;
        return this;
    }
    /**
     * Static method to create a Mnemonic instance from a mnemonic string.
     * @param {string} str - The mnemonic phrase.
     * @returns {Mnemonic} A new Mnemonic instance.
     */
    static fromString(str) {
        return new this().fromString(str);
    }
    /**
     * Converts the instance's mnemonic to a string representation.
     * @returns {string} The mnemonic phrase as a string.
     */
    toString() {
        return this.mnemonic;
    }
    /**
     * Converts the mnemonic to a seed.
     * The mnemonic must pass the validity check before conversion.
     * @param {string} [passphrase=''] - An optional passphrase for additional security.
     * @returns {number[]} The generated seed.
     * @throws {Error} If the mnemonic is invalid.
     */
    toSeed(passphrase) {
        this.mnemonic2Seed(passphrase);
        return this.seed;
    }
    /**
     * Converts entropy to a mnemonic phrase.
     * This method takes a buffer of entropy and converts it into a corresponding
     * mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits.
     * The method applies a checksum and maps the entropy to words in the wordlist.
     * @param {number[]} buf - The entropy buffer to convert. Must be at least 128 bits.
     * @returns {this} The Mnemonic instance with the mnemonic set from the entropy.
     * @throws {Error} If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.
     */
    entropy2Mnemonic(buf) {
        if (buf.length < 128 / 8) {
            throw new Error('Entropy is less than 128 bits. It must be 128 bits or more.');
        }
        const hash = Hash.sha256(buf);
        let bin = '';
        const bits = buf.length * 8;
        for (let i = 0; i < buf.length; i++) {
            bin = bin + ('00000000' + buf[i].toString(2)).slice(-8);
        }
        let hashbits = hash[0].toString(2);
        hashbits = ('00000000' + hashbits).slice(-8).slice(0, bits / 32);
        bin = bin + hashbits;
        if (bin.length % 11 !== 0) {
            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +
                bin.length.toString());
        }
        let mnemonic = '';
        for (let i = 0; i < bin.length / 11; i++) {
            if (mnemonic !== '') {
                mnemonic = mnemonic + this.Wordlist.space;
            }
            const wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);
            mnemonic = mnemonic + this.Wordlist.value[wi];
        }
        this.mnemonic = mnemonic;
        return this;
    }
    /**
     * Validates the mnemonic phrase.
     * Checks for correct length, absence of invalid words, and proper checksum.
     * @returns {boolean} True if the mnemonic is valid, false otherwise.
     * @throws {Error} If the mnemonic is not an even multiple of 11 bits.
     */
    check() {
        const mnemonic = this.mnemonic;
        // confirm no invalid words
        const words = mnemonic.split(this.Wordlist.space);
        let bin = '';
        for (let i = 0; i < words.length; i++) {
            const ind = this.Wordlist.value.indexOf(words[i]);
            if (ind < 0) {
                return false;
            }
            bin = bin + ('00000000000' + ind.toString(2)).slice(-11);
        }
        if (bin.length % 11 !== 0) {
            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +
                bin.length.toString());
        }
        // confirm checksum
        const cs = bin.length / 33;
        const hashBits = bin.slice(-cs);
        const nonhashBits = bin.slice(0, bin.length - cs);
        const buf = [];
        for (let i = 0; i < nonhashBits.length / 8; i++) {
            buf.push(parseInt(bin.slice(i * 8, (i + 1) * 8), 2));
        }
        const hash = Hash.sha256(buf.slice(0, nonhashBits.length / 8));
        let expectedHashBits = hash[0].toString(2);
        expectedHashBits = ('00000000' + expectedHashBits).slice(-8).slice(0, cs);
        return expectedHashBits === hashBits;
    }
    /**
     * Converts a mnemonic to a seed.
     * This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided),
     * and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion.
     * This seed can then be used for generating deterministic keys.
     * @param {string} [passphrase=''] - An optional passphrase for added security.
     * @returns {this} The Mnemonic instance with the seed generated from the mnemonic.
     * @throws {Error} If the mnemonic does not pass validation or if the passphrase is not a string.
     */
    mnemonic2Seed(passphrase = '') {
        let mnemonic = this.mnemonic;
        if (!this.check()) {
            throw new Error('Mnemonic does not pass the check - was the mnemonic typed incorrectly? Are there extra spaces?');
        }
        if (typeof passphrase !== 'string') {
            throw new Error('passphrase must be a string or undefined');
        }
        mnemonic = mnemonic.normalize('NFKD');
        passphrase = passphrase.normalize('NFKD');
        const mbuf = (0, utils_js_1.toArray)(mnemonic, 'utf8');
        const pbuf = [
            ...(0, utils_js_1.toArray)('mnemonic', 'utf8'),
            ...(0, utils_js_1.toArray)(passphrase, 'utf8')
        ];
        this.seed = Hash.pbkdf2(mbuf, pbuf, 2048, 64, 'sha512');
        return this;
    }
    /**
     * Determines the validity of a given passphrase with the mnemonic.
     * This method is useful for checking if a passphrase matches with the mnemonic.
     * @param {string} [passphrase=''] - The passphrase to validate.
     * @returns {boolean} True if the mnemonic and passphrase combination is valid, false otherwise.
     */
    isValid(passphrase = '') {
        let isValid;
        try {
            this.mnemonic2Seed(passphrase);
            isValid = true;
        }
        catch {
            isValid = false;
        }
        return isValid;
    }
    /**
     * Static method to check the validity of a given mnemonic and passphrase combination.
     * @param {string} mnemonic - The mnemonic phrase.
     * @param {string} [passphrase=''] - The passphrase to validate.
     * @returns {boolean} True if the combination is valid, false otherwise.
     */
    static isValid(mnemonic, passphrase = '') {
        return new Mnemonic(mnemonic).isValid(passphrase);
    }
}
exports.default = Mnemonic;

},{"../primitives/Hash.js":46,"../primitives/Random.js":55,"../primitives/utils.js":62,"./bip-39-wordlist-en.js":25}],24:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Transaction_js_1 = __importDefault(require("../transaction/Transaction.js"));
const LockingScript_js_1 = __importDefault(require("../script/LockingScript.js"));
/**
 * @method fromUtxo
 *
 * @description
 * This function creates a transaction input from a utxo json object
 * The idea being old code that uses utxos rather than sourceTranactions can convert using this.
 *
 * @deprecated
 * This approach is made available for compatibility only. It is deprecated in favor of using sourceTransactions
 * directly. It's recommended that wallets general keep transactions which store unspent outputs in their entirety,
 * along with corresonding Merkle paths. The reason you would keep the whole transaction is such that you can prove
 * the txid, and therefore its inclusion within a specific block.
 *
 * @example
 * const i = fromUtxo({
 *   txid: '434555433eaca96dff6e71a4d02febd0dd3832e5ca4e5734623ca914522e17d5',
 *   vout: 0,
 *   script: '51',
 *   satoshis: 1234
 * }, new P2PKH().unlock(p))
 *
 * tx.addInput(i)
 *
 * @param utxo: jsonUtxo
 * @param unlockingScriptTemplate: { sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>, estimateLength: (tx: Transaction, inputIndex: number) => Promise<number> }
 * @returns
 */
function fromUtxo(utxo, unlockingScriptTemplate) {
    const sourceTransaction = new Transaction_js_1.default(0, [], [], 0);
    sourceTransaction.outputs = Array(utxo.vout + 1).fill(null);
    sourceTransaction.outputs[utxo.vout] = {
        satoshis: utxo.satoshis,
        lockingScript: LockingScript_js_1.default.fromHex(utxo.script)
    };
    return {
        sourceTransaction,
        sourceTXID: utxo.txid,
        sourceOutputIndex: utxo.vout,
        unlockingScriptTemplate,
        sequence: 0xffffffff
    };
}
exports.default = fromUtxo;

},{"../script/LockingScript.js":66,"../transaction/Transaction.js":88}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wordList = void 0;
exports.wordList = {
    value: [
        'abandon',
        'ability',
        'able',
        'about',
        'above',
        'absent',
        'absorb',
        'abstract',
        'absurd',
        'abuse',
        'access',
        'accident',
        'account',
        'accuse',
        'achieve',
        'acid',
        'acoustic',
        'acquire',
        'across',
        'act',
        'action',
        'actor',
        'actress',
        'actual',
        'adapt',
        'add',
        'addict',
        'address',
        'adjust',
        'admit',
        'adult',
        'advance',
        'advice',
        'aerobic',
        'affair',
        'afford',
        'afraid',
        'again',
        'age',
        'agent',
        'agree',
        'ahead',
        'aim',
        'air',
        'airport',
        'aisle',
        'alarm',
        'album',
        'alcohol',
        'alert',
        'alien',
        'all',
        'alley',
        'allow',
        'almost',
        'alone',
        'alpha',
        'already',
        'also',
        'alter',
        'always',
        'amateur',
        'amazing',
        'among',
        'amount',
        'amused',
        'analyst',
        'anchor',
        'ancient',
        'anger',
        'angle',
        'angry',
        'animal',
        'ankle',
        'announce',
        'annual',
        'another',
        'answer',
        'antenna',
        'antique',
        'anxiety',
        'any',
        'apart',
        'apology',
        'appear',
        'apple',
        'approve',
        'april',
        'arch',
        'arctic',
        'area',
        'arena',
        'argue',
        'arm',
        'armed',
        'armor',
        'army',
        'around',
        'arrange',
        'arrest',
        'arrive',
        'arrow',
        'art',
        'artefact',
        'artist',
        'artwork',
        'ask',
        'aspect',
        'assault',
        'asset',
        'assist',
        'assume',
        'asthma',
        'athlete',
        'atom',
        'attack',
        'attend',
        'attitude',
        'attract',
        'auction',
        'audit',
        'august',
        'aunt',
        'author',
        'auto',
        'autumn',
        'average',
        'avocado',
        'avoid',
        'awake',
        'aware',
        'away',
        'awesome',
        'awful',
        'awkward',
        'axis',
        'baby',
        'bachelor',
        'bacon',
        'badge',
        'bag',
        'balance',
        'balcony',
        'ball',
        'bamboo',
        'banana',
        'banner',
        'bar',
        'barely',
        'bargain',
        'barrel',
        'base',
        'basic',
        'basket',
        'battle',
        'beach',
        'bean',
        'beauty',
        'because',
        'become',
        'beef',
        'before',
        'begin',
        'behave',
        'behind',
        'believe',
        'below',
        'belt',
        'bench',
        'benefit',
        'best',
        'betray',
        'better',
        'between',
        'beyond',
        'bicycle',
        'bid',
        'bike',
        'bind',
        'biology',
        'bird',
        'birth',
        'bitter',
        'black',
        'blade',
        'blame',
        'blanket',
        'blast',
        'bleak',
        'bless',
        'blind',
        'blood',
        'blossom',
        'blouse',
        'blue',
        'blur',
        'blush',
        'board',
        'boat',
        'body',
        'boil',
        'bomb',
        'bone',
        'bonus',
        'book',
        'boost',
        'border',
        'boring',
        'borrow',
        'boss',
        'bottom',
        'bounce',
        'box',
        'boy',
        'bracket',
        'brain',
        'brand',
        'brass',
        'brave',
        'bread',
        'breeze',
        'brick',
        'bridge',
        'brief',
        'bright',
        'bring',
        'brisk',
        'broccoli',
        'broken',
        'bronze',
        'broom',
        'brother',
        'brown',
        'brush',
        'bubble',
        'buddy',
        'budget',
        'buffalo',
        'build',
        'bulb',
        'bulk',
        'bullet',
        'bundle',
        'bunker',
        'burden',
        'burger',
        'burst',
        'bus',
        'business',
        'busy',
        'butter',
        'buyer',
        'buzz',
        'cabbage',
        'cabin',
        'cable',
        'cactus',
        'cage',
        'cake',
        'call',
        'calm',
        'camera',
        'camp',
        'can',
        'canal',
        'cancel',
        'candy',
        'cannon',
        'canoe',
        'canvas',
        'canyon',
        'capable',
        'capital',
        'captain',
        'car',
        'carbon',
        'card',
        'cargo',
        'carpet',
        'carry',
        'cart',
        'case',
        'cash',
        'casino',
        'castle',
        'casual',
        'cat',
        'catalog',
        'catch',
        'category',
        'cattle',
        'caught',
        'cause',
        'caution',
        'cave',
        'ceiling',
        'celery',
        'cement',
        'census',
        'century',
        'cereal',
        'certain',
        'chair',
        'chalk',
        'champion',
        'change',
        'chaos',
        'chapter',
        'charge',
        'chase',
        'chat',
        'cheap',
        'check',
        'cheese',
        'chef',
        'cherry',
        'chest',
        'chicken',
        'chief',
        'child',
        'chimney',
        'choice',
        'choose',
        'chronic',
        'chuckle',
        'chunk',
        'churn',
        'cigar',
        'cinnamon',
        'circle',
        'citizen',
        'city',
        'civil',
        'claim',
        'clap',
        'clarify',
        'claw',
        'clay',
        'clean',
        'clerk',
        'clever',
        'click',
        'client',
        'cliff',
        'climb',
        'clinic',
        'clip',
        'clock',
        'clog',
        'close',
        'cloth',
        'cloud',
        'clown',
        'club',
        'clump',
        'cluster',
        'clutch',
        'coach',
        'coast',
        'coconut',
        'code',
        'coffee',
        'coil',
        'coin',
        'collect',
        'color',
        'column',
        'combine',
        'come',
        'comfort',
        'comic',
        'common',
        'company',
        'concert',
        'conduct',
        'confirm',
        'congress',
        'connect',
        'consider',
        'control',
        'convince',
        'cook',
        'cool',
        'copper',
        'copy',
        'coral',
        'core',
        'corn',
        'correct',
        'cost',
        'cotton',
        'couch',
        'country',
        'couple',
        'course',
        'cousin',
        'cover',
        'coyote',
        'crack',
        'cradle',
        'craft',
        'cram',
        'crane',
        'crash',
        'crater',
        'crawl',
        'crazy',
        'cream',
        'credit',
        'creek',
        'crew',
        'cricket',
        'crime',
        'crisp',
        'critic',
        'crop',
        'cross',
        'crouch',
        'crowd',
        'crucial',
        'cruel',
        'cruise',
        'crumble',
        'crunch',
        'crush',
        'cry',
        'crystal',
        'cube',
        'culture',
        'cup',
        'cupboard',
        'curious',
        'current',
        'curtain',
        'curve',
        'cushion',
        'custom',
        'cute',
        'cycle',
        'dad',
        'damage',
        'damp',
        'dance',
        'danger',
        'daring',
        'dash',
        'daughter',
        'dawn',
        'day',
        'deal',
        'debate',
        'debris',
        'decade',
        'december',
        'decide',
        'decline',
        'decorate',
        'decrease',
        'deer',
        'defense',
        'define',
        'defy',
        'degree',
        'delay',
        'deliver',
        'demand',
        'demise',
        'denial',
        'dentist',
        'deny',
        'depart',
        'depend',
        'deposit',
        'depth',
        'deputy',
        'derive',
        'describe',
        'desert',
        'design',
        'desk',
        'despair',
        'destroy',
        'detail',
        'detect',
        'develop',
        'device',
        'devote',
        'diagram',
        'dial',
        'diamond',
        'diary',
        'dice',
        'diesel',
        'diet',
        'differ',
        'digital',
        'dignity',
        'dilemma',
        'dinner',
        'dinosaur',
        'direct',
        'dirt',
        'disagree',
        'discover',
        'disease',
        'dish',
        'dismiss',
        'disorder',
        'display',
        'distance',
        'divert',
        'divide',
        'divorce',
        'dizzy',
        'doctor',
        'document',
        'dog',
        'doll',
        'dolphin',
        'domain',
        'donate',
        'donkey',
        'donor',
        'door',
        'dose',
        'double',
        'dove',
        'draft',
        'dragon',
        'drama',
        'drastic',
        'draw',
        'dream',
        'dress',
        'drift',
        'drill',
        'drink',
        'drip',
        'drive',
        'drop',
        'drum',
        'dry',
        'duck',
        'dumb',
        'dune',
        'during',
        'dust',
        'dutch',
        'duty',
        'dwarf',
        'dynamic',
        'eager',
        'eagle',
        'early',
        'earn',
        'earth',
        'easily',
        'east',
        'easy',
        'echo',
        'ecology',
        'economy',
        'edge',
        'edit',
        'educate',
        'effort',
        'egg',
        'eight',
        'either',
        'elbow',
        'elder',
        'electric',
        'elegant',
        'element',
        'elephant',
        'elevator',
        'elite',
        'else',
        'embark',
        'embody',
        'embrace',
        'emerge',
        'emotion',
        'employ',
        'empower',
        'empty',
        'enable',
        'enact',
        'end',
        'endless',
        'endorse',
        'enemy',
        'energy',
        'enforce',
        'engage',
        'engine',
        'enhance',
        'enjoy',
        'enlist',
        'enough',
        'enrich',
        'enroll',
        'ensure',
        'enter',
        'entire',
        'entry',
        'envelope',
        'episode',
        'equal',
        'equip',
        'era',
        'erase',
        'erode',
        'erosion',
        'error',
        'erupt',
        'escape',
        'essay',
        'essence',
        'estate',
        'eternal',
        'ethics',
        'evidence',
        'evil',
        'evoke',
        'evolve',
        'exact',
        'example',
        'excess',
        'exchange',
        'excite',
        'exclude',
        'excuse',
        'execute',
        'exercise',
        'exhaust',
        'exhibit',
        'exile',
        'exist',
        'exit',
        'exotic',
        'expand',
        'expect',
        'expire',
        'explain',
        'expose',
        'express',
        'extend',
        'extra',
        'eye',
        'eyebrow',
        'fabric',
        'face',
        'faculty',
        'fade',
        'faint',
        'faith',
        'fall',
        'false',
        'fame',
        'family',
        'famous',
        'fan',
        'fancy',
        'fantasy',
        'farm',
        'fashion',
        'fat',
        'fatal',
        'father',
        'fatigue',
        'fault',
        'favorite',
        'feature',
        'february',
        'federal',
        'fee',
        'feed',
        'feel',
        'female',
        'fence',
        'festival',
        'fetch',
        'fever',
        'few',
        'fiber',
        'fiction',
        'field',
        'figure',
        'file',
        'film',
        'filter',
        'final',
        'find',
        'fine',
        'finger',
        'finish',
        'fire',
        'firm',
        'first',
        'fiscal',
        'fish',
        'fit',
        'fitness',
        'fix',
        'flag',
        'flame',
        'flash',
        'flat',
        'flavor',
        'flee',
        'flight',
        'flip',
        'float',
        'flock',
        'floor',
        'flower',
        'fluid',
        'flush',
        'fly',
        'foam',
        'focus',
        'fog',
        'foil',
        'fold',
        'follow',
        'food',
        'foot',
        'force',
        'forest',
        'forget',
        'fork',
        'fortune',
        'forum',
        'forward',
        'fossil',
        'foster',
        'found',
        'fox',
        'fragile',
        'frame',
        'frequent',
        'fresh',
        'friend',
        'fringe',
        'frog',
        'front',
        'frost',
        'frown',
        'frozen',
        'fruit',
        'fuel',
        'fun',
        'funny',
        'furnace',
        'fury',
        'future',
        'gadget',
        'gain',
        'galaxy',
        'gallery',
        'game',
        'gap',
        'garage',
        'garbage',
        'garden',
        'garlic',
        'garment',
        'gas',
        'gasp',
        'gate',
        'gather',
        'gauge',
        'gaze',
        'general',
        'genius',
        'genre',
        'gentle',
        'genuine',
        'gesture',
        'ghost',
        'giant',
        'gift',
        'giggle',
        'ginger',
        'giraffe',
        'girl',
        'give',
        'glad',
        'glance',
        'glare',
        'glass',
        'glide',
        'glimpse',
        'globe',
        'gloom',
        'glory',
        'glove',
        'glow',
        'glue',
        'goat',
        'goddess',
        'gold',
        'good',
        'goose',
        'gorilla',
        'gospel',
        'gossip',
        'govern',
        'gown',
        'grab',
        'grace',
        'grain',
        'grant',
        'grape',
        'grass',
        'gravity',
        'great',
        'green',
        'grid',
        'grief',
        'grit',
        'grocery',
        'group',
        'grow',
        'grunt',
        'guard',
        'guess',
        'guide',
        'guilt',
        'guitar',
        'gun',
        'gym',
        'habit',
        'hair',
        'half',
        'hammer',
        'hamster',
        'hand',
        'happy',
        'harbor',
        'hard',
        'harsh',
        'harvest',
        'hat',
        'have',
        'hawk',
        'hazard',
        'head',
        'health',
        'heart',
        'heavy',
        'hedgehog',
        'height',
        'hello',
        'helmet',
        'help',
        'hen',
        'hero',
        'hidden',
        'high',
        'hill',
        'hint',
        'hip',
        'hire',
        'history',
        'hobby',
        'hockey',
        'hold',
        'hole',
        'holiday',
        'hollow',
        'home',
        'honey',
        'hood',
        'hope',
        'horn',
        'horror',
        'horse',
        'hospital',
        'host',
        'hotel',
        'hour',
        'hover',
        'hub',
        'huge',
        'human',
        'humble',
        'humor',
        'hundred',
        'hungry',
        'hunt',
        'hurdle',
        'hurry',
        'hurt',
        'husband',
        'hybrid',
        'ice',
        'icon',
        'idea',
        'identify',
        'idle',
        'ignore',
        'ill',
        'illegal',
        'illness',
        'image',
        'imitate',
        'immense',
        'immune',
        'impact',
        'impose',
        'improve',
        'impulse',
        'inch',
        'include',
        'income',
        'increase',
        'index',
        'indicate',
        'indoor',
        'industry',
        'infant',
        'inflict',
        'inform',
        'inhale',
        'inherit',
        'initial',
        'inject',
        'injury',
        'inmate',
        'inner',
        'innocent',
        'input',
        'inquiry',
        'insane',
        'insect',
        'inside',
        'inspire',
        'install',
        'intact',
        'interest',
        'into',
        'invest',
        'invite',
        'involve',
        'iron',
        'island',
        'isolate',
        'issue',
        'item',
        'ivory',
        'jacket',
        'jaguar',
        'jar',
        'jazz',
        'jealous',
        'jeans',
        'jelly',
        'jewel',
        'job',
        'join',
        'joke',
        'journey',
        'joy',
        'judge',
        'juice',
        'jump',
        'jungle',
        'junior',
        'junk',
        'just',
        'kangaroo',
        'keen',
        'keep',
        'ketchup',
        'key',
        'kick',
        'kid',
        'kidney',
        'kind',
        'kingdom',
        'kiss',
        'kit',
        'kitchen',
        'kite',
        'kitten',
        'kiwi',
        'knee',
        'knife',
        'knock',
        'know',
        'lab',
        'label',
        'labor',
        'ladder',
        'lady',
        'lake',
        'lamp',
        'language',
        'laptop',
        'large',
        'later',
        'latin',
        'laugh',
        'laundry',
        'lava',
        'law',
        'lawn',
        'lawsuit',
        'layer',
        'lazy',
        'leader',
        'leaf',
        'learn',
        'leave',
        'lecture',
        'left',
        'leg',
        'legal',
        'legend',
        'leisure',
        'lemon',
        'lend',
        'length',
        'lens',
        'leopard',
        'lesson',
        'letter',
        'level',
        'liar',
        'liberty',
        'library',
        'license',
        'life',
        'lift',
        'light',
        'like',
        'limb',
        'limit',
        'link',
        'lion',
        'liquid',
        'list',
        'little',
        'live',
        'lizard',
        'load',
        'loan',
        'lobster',
        'local',
        'lock',
        'logic',
        'lonely',
        'long',
        'loop',
        'lottery',
        'loud',
        'lounge',
        'love',
        'loyal',
        'lucky',
        'luggage',
        'lumber',
        'lunar',
        'lunch',
        'luxury',
        'lyrics',
        'machine',
        'mad',
        'magic',
        'magnet',
        'maid',
        'mail',
        'main',
        'major',
        'make',
        'mammal',
        'man',
        'manage',
        'mandate',
        'mango',
        'mansion',
        'manual',
        'maple',
        'marble',
        'march',
        'margin',
        'marine',
        'market',
        'marriage',
        'mask',
        'mass',
        'master',
        'match',
        'material',
        'math',
        'matrix',
        'matter',
        'maximum',
        'maze',
        'meadow',
        'mean',
        'measure',
        'meat',
        'mechanic',
        'medal',
        'media',
        'melody',
        'melt',
        'member',
        'memory',
        'mention',
        'menu',
        'mercy',
        'merge',
        'merit',
        'merry',
        'mesh',
        'message',
        'metal',
        'method',
        'middle',
        'midnight',
        'milk',
        'million',
        'mimic',
        'mind',
        'minimum',
        'minor',
        'minute',
        'miracle',
        'mirror',
        'misery',
        'miss',
        'mistake',
        'mix',
        'mixed',
        'mixture',
        'mobile',
        'model',
        'modify',
        'mom',
        'moment',
        'monitor',
        'monkey',
        'monster',
        'month',
        'moon',
        'moral',
        'more',
        'morning',
        'mosquito',
        'mother',
        'motion',
        'motor',
        'mountain',
        'mouse',
        'move',
        'movie',
        'much',
        'muffin',
        'mule',
        'multiply',
        'muscle',
        'museum',
        'mushroom',
        'music',
        'must',
        'mutual',
        'myself',
        'mystery',
        'myth',
        'naive',
        'name',
        'napkin',
        'narrow',
        'nasty',
        'nation',
        'nature',
        'near',
        'neck',
        'need',
        'negative',
        'neglect',
        'neither',
        'nephew',
        'nerve',
        'nest',
        'net',
        'network',
        'neutral',
        'never',
        'news',
        'next',
        'nice',
        'night',
        'noble',
        'noise',
        'nominee',
        'noodle',
        'normal',
        'north',
        'nose',
        'notable',
        'note',
        'nothing',
        'notice',
        'novel',
        'now',
        'nuclear',
        'number',
        'nurse',
        'nut',
        'oak',
        'obey',
        'object',
        'oblige',
        'obscure',
        'observe',
        'obtain',
        'obvious',
        'occur',
        'ocean',
        'october',
        'odor',
        'off',
        'offer',
        'office',
        'often',
        'oil',
        'okay',
        'old',
        'olive',
        'olympic',
        'omit',
        'once',
        'one',
        'onion',
        'online',
        'only',
        'open',
        'opera',
        'opinion',
        'oppose',
        'option',
        'orange',
        'orbit',
        'orchard',
        'order',
        'ordinary',
        'organ',
        'orient',
        'original',
        'orphan',
        'ostrich',
        'other',
        'outdoor',
        'outer',
        'output',
        'outside',
        'oval',
        'oven',
        'over',
        'own',
        'owner',
        'oxygen',
        'oyster',
        'ozone',
        'pact',
        'paddle',
        'page',
        'pair',
        'palace',
        'palm',
        'panda',
        'panel',
        'panic',
        'panther',
        'paper',
        'parade',
        'parent',
        'park',
        'parrot',
        'party',
        'pass',
        'patch',
        'path',
        'patient',
        'patrol',
        'pattern',
        'pause',
        'pave',
        'payment',
        'peace',
        'peanut',
        'pear',
        'peasant',
        'pelican',
        'pen',
        'penalty',
        'pencil',
        'people',
        'pepper',
        'perfect',
        'permit',
        'person',
        'pet',
        'phone',
        'photo',
        'phrase',
        'physical',
        'piano',
        'picnic',
        'picture',
        'piece',
        'pig',
        'pigeon',
        'pill',
        'pilot',
        'pink',
        'pioneer',
        'pipe',
        'pistol',
        'pitch',
        'pizza',
        'place',
        'planet',
        'plastic',
        'plate',
        'play',
        'please',
        'pledge',
        'pluck',
        'plug',
        'plunge',
        'poem',
        'poet',
        'point',
        'polar',
        'pole',
        'police',
        'pond',
        'pony',
        'pool',
        'popular',
        'portion',
        'position',
        'possible',
        'post',
        'potato',
        'pottery',
        'poverty',
        'powder',
        'power',
        'practice',
        'praise',
        'predict',
        'prefer',
        'prepare',
        'present',
        'pretty',
        'prevent',
        'price',
        'pride',
        'primary',
        'print',
        'priority',
        'prison',
        'private',
        'prize',
        'problem',
        'process',
        'produce',
        'profit',
        'program',
        'project',
        'promote',
        'proof',
        'property',
        'prosper',
        'protect',
        'proud',
        'provide',
        'public',
        'pudding',
        'pull',
        'pulp',
        'pulse',
        'pumpkin',
        'punch',
        'pupil',
        'puppy',
        'purchase',
        'purity',
        'purpose',
        'purse',
        'push',
        'put',
        'puzzle',
        'pyramid',
        'quality',
        'quantum',
        'quarter',
        'question',
        'quick',
        'quit',
        'quiz',
        'quote',
        'rabbit',
        'raccoon',
        'race',
        'rack',
        'radar',
        'radio',
        'rail',
        'rain',
        'raise',
        'rally',
        'ramp',
        'ranch',
        'random',
        'range',
        'rapid',
        'rare',
        'rate',
        'rather',
        'raven',
        'raw',
        'razor',
        'ready',
        'real',
        'reason',
        'rebel',
        'rebuild',
        'recall',
        'receive',
        'recipe',
        'record',
        'recycle',
        'reduce',
        'reflect',
        'reform',
        'refuse',
        'region',
        'regret',
        'regular',
        'reject',
        'relax',
        'release',
        'relief',
        'rely',
        'remain',
        'remember',
        'remind',
        'remove',
        'render',
        'renew',
        'rent',
        'reopen',
        'repair',
        'repeat',
        'replace',
        'report',
        'require',
        'rescue',
        'resemble',
        'resist',
        'resource',
        'response',
        'result',
        'retire',
        'retreat',
        'return',
        'reunion',
        'reveal',
        'review',
        'reward',
        'rhythm',
        'rib',
        'ribbon',
        'rice',
        'rich',
        'ride',
        'ridge',
        'rifle',
        'right',
        'rigid',
        'ring',
        'riot',
        'ripple',
        'risk',
        'ritual',
        'rival',
        'river',
        'road',
        'roast',
        'robot',
        'robust',
        'rocket',
        'romance',
        'roof',
        'rookie',
        'room',
        'rose',
        'rotate',
        'rough',
        'round',
        'route',
        'royal',
        'rubber',
        'rude',
        'rug',
        'rule',
        'run',
        'runway',
        'rural',
        'sad',
        'saddle',
        'sadness',
        'safe',
        'sail',
        'salad',
        'salmon',
        'salon',
        'salt',
        'salute',
        'same',
        'sample',
        'sand',
        'satisfy',
        'satoshi',
        'sauce',
        'sausage',
        'save',
        'say',
        'scale',
        'scan',
        'scare',
        'scatter',
        'scene',
        'scheme',
        'school',
        'science',
        'scissors',
        'scorpion',
        'scout',
        'scrap',
        'screen',
        'script',
        'scrub',
        'sea',
        'search',
        'season',
        'seat',
        'second',
        'secret',
        'section',
        'security',
        'seed',
        'seek',
        'segment',
        'select',
        'sell',
        'seminar',
        'senior',
        'sense',
        'sentence',
        'series',
        'service',
        'session',
        'settle',
        'setup',
        'seven',
        'shadow',
        'shaft',
        'shallow',
        'share',
        'shed',
        'shell',
        'sheriff',
        'shield',
        'shift',
        'shine',
        'ship',
        'shiver',
        'shock',
        'shoe',
        'shoot',
        'shop',
        'short',
        'shoulder',
        'shove',
        'shrimp',
        'shrug',
        'shuffle',
        'shy',
        'sibling',
        'sick',
        'side',
        'siege',
        'sight',
        'sign',
        'silent',
        'silk',
        'silly',
        'silver',
        'similar',
        'simple',
        'since',
        'sing',
        'siren',
        'sister',
        'situate',
        'six',
        'size',
        'skate',
        'sketch',
        'ski',
        'skill',
        'skin',
        'skirt',
        'skull',
        'slab',
        'slam',
        'sleep',
        'slender',
        'slice',
        'slide',
        'slight',
        'slim',
        'slogan',
        'slot',
        'slow',
        'slush',
        'small',
        'smart',
        'smile',
        'smoke',
        'smooth',
        'snack',
        'snake',
        'snap',
        'sniff',
        'snow',
        'soap',
        'soccer',
        'social',
        'sock',
        'soda',
        'soft',
        'solar',
        'soldier',
        'solid',
        'solution',
        'solve',
        'someone',
        'song',
        'soon',
        'sorry',
        'sort',
        'soul',
        'sound',
        'soup',
        'source',
        'south',
        'space',
        'spare',
        'spatial',
        'spawn',
        'speak',
        'special',
        'speed',
        'spell',
        'spend',
        'sphere',
        'spice',
        'spider',
        'spike',
        'spin',
        'spirit',
        'split',
        'spoil',
        'sponsor',
        'spoon',
        'sport',
        'spot',
        'spray',
        'spread',
        'spring',
        'spy',
        'square',
        'squeeze',
        'squirrel',
        'stable',
        'stadium',
        'staff',
        'stage',
        'stairs',
        'stamp',
        'stand',
        'start',
        'state',
        'stay',
        'steak',
        'steel',
        'stem',
        'step',
        'stereo',
        'stick',
        'still',
        'sting',
        'stock',
        'stomach',
        'stone',
        'stool',
        'story',
        'stove',
        'strategy',
        'street',
        'strike',
        'strong',
        'struggle',
        'student',
        'stuff',
        'stumble',
        'style',
        'subject',
        'submit',
        'subway',
        'success',
        'such',
        'sudden',
        'suffer',
        'sugar',
        'suggest',
        'suit',
        'summer',
        'sun',
        'sunny',
        'sunset',
        'super',
        'supply',
        'supreme',
        'sure',
        'surface',
        'surge',
        'surprise',
        'surround',
        'survey',
        'suspect',
        'sustain',
        'swallow',
        'swamp',
        'swap',
        'swarm',
        'swear',
        'sweet',
        'swift',
        'swim',
        'swing',
        'switch',
        'sword',
        'symbol',
        'symptom',
        'syrup',
        'system',
        'table',
        'tackle',
        'tag',
        'tail',
        'talent',
        'talk',
        'tank',
        'tape',
        'target',
        'task',
        'taste',
        'tattoo',
        'taxi',
        'teach',
        'team',
        'tell',
        'ten',
        'tenant',
        'tennis',
        'tent',
        'term',
        'test',
        'text',
        'thank',
        'that',
        'theme',
        'then',
        'theory',
        'there',
        'they',
        'thing',
        'this',
        'thought',
        'three',
        'thrive',
        'throw',
        'thumb',
        'thunder',
        'ticket',
        'tide',
        'tiger',
        'tilt',
        'timber',
        'time',
        'tiny',
        'tip',
        'tired',
        'tissue',
        'title',
        'toast',
        'tobacco',
        'today',
        'toddler',
        'toe',
        'together',
        'toilet',
        'token',
        'tomato',
        'tomorrow',
        'tone',
        'tongue',
        'tonight',
        'tool',
        'tooth',
        'top',
        'topic',
        'topple',
        'torch',
        'tornado',
        'tortoise',
        'toss',
        'total',
        'tourist',
        'toward',
        'tower',
        'town',
        'toy',
        'track',
        'trade',
        'traffic',
        'tragic',
        'train',
        'transfer',
        'trap',
        'trash',
        'travel',
        'tray',
        'treat',
        'tree',
        'trend',
        'trial',
        'tribe',
        'trick',
        'trigger',
        'trim',
        'trip',
        'trophy',
        'trouble',
        'truck',
        'true',
        'truly',
        'trumpet',
        'trust',
        'truth',
        'try',
        'tube',
        'tuition',
        'tumble',
        'tuna',
        'tunnel',
        'turkey',
        'turn',
        'turtle',
        'twelve',
        'twenty',
        'twice',
        'twin',
        'twist',
        'two',
        'type',
        'typical',
        'ugly',
        'umbrella',
        'unable',
        'unaware',
        'uncle',
        'uncover',
        'under',
        'undo',
        'unfair',
        'unfold',
        'unhappy',
        'uniform',
        'unique',
        'unit',
        'universe',
        'unknown',
        'unlock',
        'until',
        'unusual',
        'unveil',
        'update',
        'upgrade',
        'uphold',
        'upon',
        'upper',
        'upset',
        'urban',
        'urge',
        'usage',
        'use',
        'used',
        'useful',
        'useless',
        'usual',
        'utility',
        'vacant',
        'vacuum',
        'vague',
        'valid',
        'valley',
        'valve',
        'van',
        'vanish',
        'vapor',
        'various',
        'vast',
        'vault',
        'vehicle',
        'velvet',
        'vendor',
        'venture',
        'venue',
        'verb',
        'verify',
        'version',
        'very',
        'vessel',
        'veteran',
        'viable',
        'vibrant',
        'vicious',
        'victory',
        'video',
        'view',
        'village',
        'vintage',
        'violin',
        'virtual',
        'virus',
        'visa',
        'visit',
        'visual',
        'vital',
        'vivid',
        'vocal',
        'voice',
        'void',
        'volcano',
        'volume',
        'vote',
        'voyage',
        'wage',
        'wagon',
        'wait',
        'walk',
        'wall',
        'walnut',
        'want',
        'warfare',
        'warm',
        'warrior',
        'wash',
        'wasp',
        'waste',
        'water',
        'wave',
        'way',
        'wealth',
        'weapon',
        'wear',
        'weasel',
        'weather',
        'web',
        'wedding',
        'weekend',
        'weird',
        'welcome',
        'west',
        'wet',
        'whale',
        'what',
        'wheat',
        'wheel',
        'when',
        'where',
        'whip',
        'whisper',
        'wide',
        'width',
        'wife',
        'wild',
        'will',
        'win',
        'window',
        'wine',
        'wing',
        'wink',
        'winner',
        'winter',
        'wire',
        'wisdom',
        'wise',
        'wish',
        'witness',
        'wolf',
        'woman',
        'wonder',
        'wood',
        'wool',
        'word',
        'work',
        'world',
        'worry',
        'worth',
        'wrap',
        'wreck',
        'wrestle',
        'wrist',
        'write',
        'wrong',
        'yard',
        'year',
        'yellow',
        'you',
        'young',
        'youth',
        'zebra',
        'zero',
        'zone',
        'zoo'
    ],
    space: ' '
};

},{}],26:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromUtxo = exports.ECIES = exports.Mnemonic = exports.HD = exports.BSM = void 0;
exports.BSM = __importStar(require("./BSM.js"));
var HD_js_1 = require("./HD.js");
Object.defineProperty(exports, "HD", { enumerable: true, get: function () { return __importDefault(HD_js_1).default; } });
var Mnemonic_js_1 = require("./Mnemonic.js");
Object.defineProperty(exports, "Mnemonic", { enumerable: true, get: function () { return __importDefault(Mnemonic_js_1).default; } });
var ECIES_js_1 = require("./ECIES.js");
Object.defineProperty(exports, "ECIES", { enumerable: true, get: function () { return __importDefault(ECIES_js_1).default; } });
var Utxo_js_1 = require("./Utxo.js");
Object.defineProperty(exports, "fromUtxo", { enumerable: true, get: function () { return __importDefault(Utxo_js_1).default; } });

},{"./BSM.js":20,"./ECIES.js":21,"./HD.js":22,"./Mnemonic.js":23,"./Utxo.js":24}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContactsManager = void 0;
const index_js_1 = require("../wallet/index.js");
const index_js_2 = require("../primitives/index.js");
const index_js_3 = require("../script/index.js");
const index_js_4 = require("../transaction/index.js");
const CONTACT_PROTOCOL_ID = [2, 'contact'];
// In-memory cache for cross-platform compatibility
class MemoryCache {
    constructor() {
        this.cache = new Map();
    }
    getItem(key) {
        return this.cache.get(key) ?? null;
    }
    setItem(key, value) {
        this.cache.set(key, value);
    }
    removeItem(key) {
        this.cache.delete(key);
    }
    clear() {
        this.cache.clear();
    }
}
class ContactsManager {
    constructor(wallet) {
        this.cache = new MemoryCache();
        this.CONTACTS_CACHE_KEY = 'metanet-contacts';
        this.wallet = wallet ?? new index_js_1.WalletClient();
    }
    /**
     * Load all records from the contacts basket
     * @param identityKey Optional specific identity key to fetch
     * @param forceRefresh Whether to force a check for new contact data
     * @param limit Maximum number of contacts to return
     * @returns A promise that resolves with an array of contacts
     */
    async getContacts(identityKey, forceRefresh = false, limit = 1000) {
        // Check in-memory cache first unless forcing refresh
        if (!forceRefresh) {
            const cached = this.cache.getItem(this.CONTACTS_CACHE_KEY);
            if (cached != null && cached !== '') {
                try {
                    const cachedContacts = JSON.parse(cached);
                    return identityKey != null
                        ? cachedContacts.filter(c => c.identityKey === identityKey)
                        : cachedContacts;
                }
                catch (e) {
                    console.warn('Invalid cached contacts JSON; will reload from chain', e);
                }
            }
        }
        const tags = [];
        if (identityKey != null) {
            // Hash the identity key to use as a tag for quick lookup
            const { hmac: hashedIdentityKey } = await this.wallet.createHmac({
                protocolID: CONTACT_PROTOCOL_ID,
                keyID: identityKey,
                counterparty: 'self',
                data: index_js_2.Utils.toArray(identityKey, 'utf8')
            });
            tags.push(`identityKey ${index_js_2.Utils.toHex(hashedIdentityKey)}`);
        }
        // Get all contact outputs from the contacts basket
        const outputs = await this.wallet.listOutputs({
            basket: 'contacts',
            include: 'locking scripts',
            includeCustomInstructions: true,
            tags,
            limit
        });
        if (outputs.outputs == null || outputs.outputs.length === 0) {
            this.cache.setItem(this.CONTACTS_CACHE_KEY, JSON.stringify([]));
            return [];
        }
        const contacts = [];
        // Process each contact output
        for (const output of outputs.outputs) {
            try {
                if (output.lockingScript == null)
                    continue;
                // Decode the PushDrop data
                const decoded = index_js_3.PushDrop.decode(index_js_3.LockingScript.fromHex(output.lockingScript));
                if (output.customInstructions == null)
                    continue;
                const keyID = JSON.parse(output.customInstructions).keyID;
                // Decrypt the contact data
                const { plaintext } = await this.wallet.decrypt({
                    ciphertext: decoded.fields[0],
                    protocolID: CONTACT_PROTOCOL_ID,
                    keyID,
                    counterparty: 'self'
                });
                // Parse the contact data
                const contactData = JSON.parse(index_js_2.Utils.toUTF8(plaintext));
                contacts.push(contactData);
            }
            catch (error) {
                console.warn('ContactsManager: Failed to decode contact output:', error);
                // Skip this contact and continue with others
            }
        }
        // Cache the loaded contacts
        this.cache.setItem(this.CONTACTS_CACHE_KEY, JSON.stringify(contacts));
        const filteredContacts = identityKey != null
            ? contacts.filter(c => c.identityKey === identityKey)
            : contacts;
        return filteredContacts;
    }
    /**
     * Save or update a Metanet contact
     * @param contact The displayable identity information for the contact
     * @param metadata Optional metadata to store with the contact (ex. notes, aliases, etc)
     */
    async saveContact(contact, metadata) {
        // Get current contacts from cache or blockchain
        const cached = this.cache.getItem(this.CONTACTS_CACHE_KEY);
        let contacts;
        if (cached != null && cached !== '') {
            contacts = JSON.parse(cached);
        }
        else {
            // If cache is empty, get current data from blockchain
            contacts = await this.getContacts();
        }
        const existingIndex = contacts.findIndex(c => c.identityKey === contact.identityKey);
        const contactToStore = {
            ...contact,
            metadata
        };
        if (existingIndex >= 0) {
            contacts[existingIndex] = contactToStore;
        }
        else {
            contacts.push(contactToStore);
        }
        const { hmac: hashedIdentityKey } = await this.wallet.createHmac({
            protocolID: CONTACT_PROTOCOL_ID,
            keyID: contact.identityKey,
            counterparty: 'self',
            data: index_js_2.Utils.toArray(contact.identityKey, 'utf8')
        });
        // Check if this contact already exists (to update it)
        const outputs = await this.wallet.listOutputs({
            basket: 'contacts',
            include: 'entire transactions',
            includeCustomInstructions: true,
            tags: [`identityKey ${index_js_2.Utils.toHex(hashedIdentityKey)}`],
            limit: 100 // Should only be one contact!
        });
        let existingOutput = null;
        let keyID = index_js_2.Utils.toBase64((0, index_js_2.Random)(32));
        if (outputs.outputs != null) {
            // Find output by trying to decrypt and checking identityKey in payload
            for (const output of outputs.outputs) {
                try {
                    const [txid, outputIndex] = output.outpoint.split('.');
                    const tx = index_js_4.Transaction.fromBEEF(outputs.BEEF, txid);
                    const decoded = index_js_3.PushDrop.decode(tx.outputs[Number(outputIndex)].lockingScript);
                    if (output.customInstructions == null)
                        continue;
                    keyID = JSON.parse(output.customInstructions).keyID;
                    const { plaintext } = await this.wallet.decrypt({
                        ciphertext: decoded.fields[0],
                        protocolID: CONTACT_PROTOCOL_ID,
                        keyID,
                        counterparty: 'self'
                    });
                    const storedContact = JSON.parse(index_js_2.Utils.toUTF8(plaintext));
                    if (storedContact.identityKey === contact.identityKey) {
                        // Found the right output
                        existingOutput = output;
                        break;
                    }
                }
                catch (e) {
                    // Skip malformed or undecryptable outputs
                }
            }
        }
        // Encrypt the contact data directly
        const contactWithMetadata = {
            ...contact,
            metadata
        };
        const { ciphertext } = await this.wallet.encrypt({
            plaintext: index_js_2.Utils.toArray(JSON.stringify(contactWithMetadata), 'utf8'),
            protocolID: CONTACT_PROTOCOL_ID,
            keyID,
            counterparty: 'self'
        });
        // Create locking script for the new contact token
        const lockingScript = await new index_js_3.PushDrop(this.wallet).lock([ciphertext], CONTACT_PROTOCOL_ID, keyID, 'self');
        if (existingOutput != null) {
            // Update existing contact by spending its output
            const [txid, outputIndex] = String(existingOutput.outpoint).split('.');
            const prevOutpoint = `${txid}.${outputIndex}`;
            const pushdrop = new index_js_3.PushDrop(this.wallet);
            const { signableTransaction } = await this.wallet.createAction({
                description: 'Update Contact',
                inputBEEF: outputs.BEEF,
                inputs: [{
                        outpoint: prevOutpoint,
                        unlockingScriptLength: 74,
                        inputDescription: 'Spend previous contact output'
                    }],
                outputs: [{
                        basket: 'contacts',
                        satoshis: 1,
                        lockingScript: lockingScript.toHex(),
                        outputDescription: `Updated Contact: ${contact.name ?? contact.identityKey.slice(0, 10)}`,
                        tags: [`identityKey ${index_js_2.Utils.toHex(hashedIdentityKey)}`],
                        customInstructions: JSON.stringify({ keyID })
                    }],
                options: { acceptDelayedBroadcast: false, randomizeOutputs: false } // TODO: Support custom config as needed.
            });
            if (signableTransaction == null)
                throw new Error('Unable to update contact');
            const unlocker = pushdrop.unlock(CONTACT_PROTOCOL_ID, keyID, 'self');
            const unlockingScript = await unlocker.sign(index_js_4.Transaction.fromBEEF(signableTransaction.tx), 0);
            const { tx } = await this.wallet.signAction({
                reference: signableTransaction.reference,
                spends: { 0: { unlockingScript: unlockingScript.toHex() } }
            });
            if (tx == null)
                throw new Error('Failed to update contact output');
        }
        else {
            // Create new contact output
            const { tx } = await this.wallet.createAction({
                description: 'Add Contact',
                outputs: [{
                        basket: 'contacts',
                        satoshis: 1,
                        lockingScript: lockingScript.toHex(),
                        outputDescription: `Contact: ${contact.name ?? contact.identityKey.slice(0, 10)}`,
                        tags: [`identityKey ${index_js_2.Utils.toHex(hashedIdentityKey)}`],
                        customInstructions: JSON.stringify({ keyID })
                    }],
                options: { acceptDelayedBroadcast: false, randomizeOutputs: false } // TODO: Support custom config as needed.
            });
            if (tx == null)
                throw new Error('Failed to create contact output');
        }
        this.cache.setItem(this.CONTACTS_CACHE_KEY, JSON.stringify(contacts));
    }
    /**
     * Remove a contact from the contacts basket
     * @param identityKey The identity key of the contact to remove
     */
    async removeContact(identityKey) {
        // Update in-memory cache
        const cached = this.cache.getItem(this.CONTACTS_CACHE_KEY);
        if (cached != null && cached !== '') {
            try {
                const contacts = JSON.parse(cached);
                const filteredContacts = contacts.filter(c => c.identityKey !== identityKey);
                this.cache.setItem(this.CONTACTS_CACHE_KEY, JSON.stringify(filteredContacts));
            }
            catch (e) {
                console.warn('Failed to update cache after contact removal:', e);
            }
        }
        // Hash the identity key to use as a tag for quick lookup
        const tags = [];
        const { hmac: hashedIdentityKey } = await this.wallet.createHmac({
            protocolID: CONTACT_PROTOCOL_ID,
            keyID: identityKey,
            counterparty: 'self',
            data: index_js_2.Utils.toArray(identityKey, 'utf8')
        });
        tags.push(`identityKey ${index_js_2.Utils.toHex(hashedIdentityKey)}`);
        // Find and spend the contact's output
        const outputs = await this.wallet.listOutputs({
            basket: 'contacts',
            include: 'entire transactions',
            includeCustomInstructions: true,
            tags,
            limit: 100 // Should only be one contact!
        });
        if (outputs.outputs == null)
            return;
        // Find the output for this specific contact by decrypting and checking identityKey
        for (const output of outputs.outputs) {
            try {
                const [txid, outputIndex] = String(output.outpoint).split('.');
                const tx = index_js_4.Transaction.fromBEEF(outputs.BEEF, txid);
                const decoded = index_js_3.PushDrop.decode(tx.outputs[Number(outputIndex)].lockingScript);
                if (output.customInstructions == null)
                    continue;
                const keyID = JSON.parse(output.customInstructions).keyID;
                const { plaintext } = await this.wallet.decrypt({
                    ciphertext: decoded.fields[0],
                    protocolID: CONTACT_PROTOCOL_ID,
                    keyID,
                    counterparty: 'self'
                });
                const storedContact = JSON.parse(index_js_2.Utils.toUTF8(plaintext));
                if (storedContact.identityKey === identityKey) {
                    // Found the contact's output, spend it without creating a new one
                    const prevOutpoint = `${txid}.${outputIndex}`;
                    const pushdrop = new index_js_3.PushDrop(this.wallet);
                    const { signableTransaction } = await this.wallet.createAction({
                        description: 'Delete Contact',
                        inputBEEF: outputs.BEEF,
                        inputs: [{
                                outpoint: prevOutpoint,
                                unlockingScriptLength: 74,
                                inputDescription: 'Spend contact output to delete'
                            }],
                        outputs: [],
                        options: { acceptDelayedBroadcast: false, randomizeOutputs: false } // TODO: Support custom config as needed.
                    });
                    if (signableTransaction == null)
                        throw new Error('Unable to delete contact');
                    const unlocker = pushdrop.unlock(CONTACT_PROTOCOL_ID, keyID, 'self');
                    const unlockingScript = await unlocker.sign(index_js_4.Transaction.fromBEEF(signableTransaction.tx), 0);
                    const { tx: deleteTx } = await this.wallet.signAction({
                        reference: signableTransaction.reference,
                        spends: { 0: { unlockingScript: unlockingScript.toHex() } }
                    });
                    if (deleteTx == null)
                        throw new Error('Failed to delete contact output');
                    return;
                }
            }
            catch (e) {
                // Skip malformed or undecryptable outputs
            }
        }
    }
}
exports.ContactsManager = ContactsManager;

},{"../primitives/index.js":61,"../script/index.js":72,"../transaction/index.js":105,"../wallet/index.js":113}],28:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityClient = void 0;
const index_js_1 = require("../auth/clients/index.js");
const index_js_2 = require("./types/index.js");
const index_js_3 = require("../wallet/index.js");
const index_js_4 = require("../transaction/index.js");
const Certificate_js_1 = __importDefault(require("../auth/certificates/Certificate.js"));
const index_js_5 = require("../script/index.js");
const index_js_6 = require("../primitives/index.js");
const index_js_7 = require("../overlay-tools/index.js");
const ContactsManager_js_1 = require("./ContactsManager.js");
/**
 * IdentityClient lets you discover who others are, and let the world know who you are.
 */
class IdentityClient {
    constructor(wallet, options = index_js_2.DEFAULT_IDENTITY_CLIENT_OPTIONS, originator) {
        this.options = options;
        this.originator = originator;
        this.wallet = wallet ?? new index_js_3.WalletClient();
        this.authClient = new index_js_1.AuthFetch(this.wallet);
        this.contactsManager = new ContactsManager_js_1.ContactsManager(this.wallet);
    }
    /**
     * Publicly reveals selected fields from a given certificate by creating a publicly verifiable certificate.
     * The publicly revealed certificate is included in a blockchain transaction and broadcast to a federated overlay node.
     *
     * @param {Certificate} certificate - The master certificate to selectively reveal.
     * @param {CertificateFieldNameUnder50Bytes[]} fieldsToReveal - An array of certificate field names to reveal. Only these fields will be included in the public certificate.
     *
     * @returns {Promise<object>} A promise that resolves with the broadcast result from the overlay network.
     * @throws {Error} Throws an error if the certificate is invalid, the fields cannot be revealed, or if the broadcast fails.
     */
    async publiclyRevealAttributes(certificate, fieldsToReveal) {
        if (Object.keys(certificate.fields).length === 0) {
            throw new Error('Public reveal failed: Certificate has no fields to reveal!');
        }
        if (fieldsToReveal.length === 0) {
            throw new Error('Public reveal failed: You must reveal at least one field!');
        }
        try {
            const masterCert = new Certificate_js_1.default(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.signature);
            await masterCert.verify();
        }
        catch (error) {
            throw new Error('Public reveal failed: Certificate verification failed!');
        }
        // Given we already have a master certificate from a certifier,
        // create an anyone verifiable certificate with selectively revealed fields
        const { keyringForVerifier } = await this.wallet.proveCertificate({
            certificate,
            fieldsToReveal,
            verifier: new index_js_6.PrivateKey(1).toPublicKey().toString()
        });
        // Build the lockingScript with pushdrop.create() and the transaction with createAction()
        const lockingScript = await new index_js_5.PushDrop(this.wallet).lock([index_js_6.Utils.toArray(JSON.stringify({ ...certificate, keyring: keyringForVerifier }))], this.options.protocolID, this.options.keyID, 'anyone', true, true);
        // TODO: Consider verification and if this is necessary
        // counterpartyCanVerifyMyOwnership: true
        const { tx } = await this.wallet.createAction({
            description: 'Create a new Identity Token',
            outputs: [{
                    satoshis: this.options.tokenAmount,
                    lockingScript: lockingScript.toHex(),
                    outputDescription: 'Identity Token'
                }],
            options: {
                randomizeOutputs: false
            }
        });
        if (tx !== undefined) {
            // Submit the transaction to an overlay
            const broadcaster = new index_js_7.TopicBroadcaster(['tm_identity'], {
                networkPreset: (await (this.wallet.getNetwork({}))).network
            });
            return await broadcaster.broadcast(index_js_4.Transaction.fromAtomicBEEF(tx));
        }
        throw new Error('Public reveal failed: failed to create action!');
    }
    /**
    * Resolves displayable identity certificates, issued to a given identity key by a trusted certifier.
    *
    * @param {DiscoverByIdentityKeyArgs} args - Arguments for requesting the discovery based on the identity key.
    * @param {boolean} [overrideWithContacts=true] - Whether to override the results with personal contacts if available.
    * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.
    */
    async resolveByIdentityKey(args, overrideWithContacts = true) {
        if (overrideWithContacts) {
            // Override results with personal contacts if available
            const contacts = await this.contactsManager.getContacts(args.identityKey);
            if (contacts.length > 0) {
                return contacts;
            }
        }
        const { certificates } = await this.wallet.discoverByIdentityKey(args, this.originator);
        return certificates.map(cert => {
            return IdentityClient.parseIdentity(cert);
        });
    }
    /**
     * Resolves displayable identity certificates by specific identity attributes, issued by a trusted entity.
     *
     * @param {DiscoverByAttributesArgs} args - Attributes and optional parameters used to discover certificates.
     * @param {boolean} [overrideWithContacts=true] - Whether to override the results with personal contacts if available.
     * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.
     */
    async resolveByAttributes(args, overrideWithContacts = true) {
        // Run both queries in parallel for better performance
        const [contacts, certificatesResult] = await Promise.all([
            overrideWithContacts ? this.contactsManager.getContacts() : Promise.resolve([]),
            this.wallet.discoverByAttributes(args, this.originator)
        ]);
        // Fast lookup by identityKey
        const contactByKey = new Map(contacts.map(contact => [contact.identityKey, contact]));
        // Guard if certificates might be absent
        const certs = certificatesResult?.certificates ?? [];
        // Parse certificates and substitute with contacts where available
        return certs.map(cert => contactByKey.get(cert.subject) ?? IdentityClient.parseIdentity(cert));
    }
    /**
     * TODO: Implement once revocation overlay is created
     * Remove public certificate revelation from overlay services by spending the identity token
     * @param serialNumber - Unique serial number of the certificate to revoke revelation
     */
    // async revokeCertificateRevelation(
    //   serialNumber: Base64String
    // ): Promise<BroadcastResponse | BroadcastFailure> {
    //   // 1. Find existing UTXO
    //   const lookupResolver = new LookupResolver()
    //   const result = await lookupResolver.query({
    //     service: 'ls_identity',
    //     query: {
    //       serialNumber
    //     }
    //   })
    //   let outpoint: string
    //   let lockingScript: LockingScript | undefined
    //   if (result.type === 'output-list') {
    //     const tx = Transaction.fromAtomicBEEF(result.outputs[this.options.outputIndex].beef)
    //     outpoint = `${tx.id('hex')}.${this.options.outputIndex}` // Consider better way
    //     lockingScript = tx.outputs[this.options.outputIndex].lockingScript
    //   }
    //   if (lockingScript === undefined) {
    //     throw new Error('Failed to get locking script for revelation output!')
    //   }
    //   // 2. Parse results
    //   const { signableTransaction } = await this.wallet.createAction({
    //     description: '',
    //     inputs: [{
    //       inputDescription: 'Spend certificate revelation token',
    //       outpoint,
    //       unlockingScriptLength: 73
    //     }],
    //     options: {
    //       randomizeOutputs: false
    //     }
    //   })
    //   if (signableTransaction === undefined) {
    //     throw new Error('Failed to create signable transaction')
    //   }
    //   const partialTx = Transaction.fromBEEF(signableTransaction.tx)
    //   const unlocker = new PushDrop(this.wallet).unlock(
    //     this.options.protocolID,
    //     this.options.keyID,
    //     'self',
    //     'all',
    //     false,
    //     1,
    //     lockingScript
    //   )
    //   const unlockingScript = await unlocker.sign(partialTx, this.options.outputIndex)
    //   const { tx: signedTx } = await this.wallet.signAction({
    //     reference: signableTransaction.reference,
    //     spends: {
    //       [this.options.outputIndex]: {
    //         unlockingScript: unlockingScript.toHex()
    //       }
    //     }
    //   })
    //   // 4. Return broadcast status
    //   // Submit the transaction to an overlay
    //   const broadcaster = new SHIPBroadcaster(['tm_identity'])
    //   return await broadcaster.broadcast(Transaction.fromAtomicBEEF(signedTx as number[]))
    // }
    /**
     * Load all records from the contacts basket
     * @param identityKey Optional specific identity key to fetch
     * @param forceRefresh Whether to force a check for new contact data
     * @param limit Optional limit on number of contacts to fetch
     * @returns A promise that resolves with an array of contacts
     */
    async getContacts(identityKey, forceRefresh = false, limit = 1000) {
        return await this.contactsManager.getContacts(identityKey, forceRefresh, limit);
    }
    /**
     * Save or update a Metanet contact
     * @param contact The displayable identity information for the contact
     * @param metadata Optional metadata to store with the contact (ex. notes, aliases, etc)
     */
    async saveContact(contact, metadata) {
        return await this.contactsManager.saveContact(contact, metadata);
    }
    /**
     * Remove a contact from the contacts basket
     * @param identityKey The identity key of the contact to remove
     */
    async removeContact(identityKey) {
        return await this.contactsManager.removeContact(identityKey);
    }
    /**
     * Parse out identity and certifier attributes to display from an IdentityCertificate
     * @param identityToParse - The Identity Certificate to parse
     * @returns - IdentityToDisplay
     */
    static parseIdentity(identityToParse) {
        const { type, decryptedFields, certifierInfo } = identityToParse;
        let name, avatarURL, badgeLabel, badgeIconURL, badgeClickURL;
        // Parse out the name to display based on the specific certificate type which has clearly defined fields.
        switch (type) {
            case index_js_2.KNOWN_IDENTITY_TYPES.xCert:
                name = decryptedFields.userName;
                avatarURL = decryptedFields.profilePhoto;
                badgeLabel = `X account certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.discordCert:
                name = decryptedFields.userName;
                avatarURL = decryptedFields.profilePhoto;
                badgeLabel = `Discord account certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.emailCert:
                name = decryptedFields.email;
                avatarURL = 'XUTZxep7BBghAJbSBwTjNfmcsDdRFs5EaGEgkESGSgjJVYgMEizu';
                badgeLabel = `Email certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.phoneCert:
                name = decryptedFields.phoneNumber;
                avatarURL = 'XUTLxtX3ELNUwRhLwL7kWNGbdnFM8WG2eSLv84J7654oH8HaJWrU';
                badgeLabel = `Phone certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.identiCert:
                name = `${decryptedFields.firstName} ${decryptedFields.lastName}`;
                avatarURL = decryptedFields.profilePhoto;
                badgeLabel = `Government ID certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://identicert.me'; // TODO Make a specific page for this.
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.registrant:
                name = decryptedFields.name;
                avatarURL = decryptedFields.icon;
                badgeLabel = `Entity certified by ${certifierInfo.name}`;
                badgeIconURL = certifierInfo.iconUrl;
                badgeClickURL = 'https://projectbabbage.com/docs/registrant'; // TODO: Make this doc page exist
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.coolCert:
                name = decryptedFields.cool === 'true' ? 'Cool Person!' : 'Not cool!';
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.anyone:
                name = 'Anyone';
                avatarURL = 'XUT4bpQ6cpBaXi1oMzZsXfpkWGbtp2JTUYAoN7PzhStFJ6wLfoeR';
                badgeLabel = 'Represents the ability for anyone to access this information.';
                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';
                badgeClickURL = 'https://projectbabbage.com/docs/anyone-identity'; // TODO: Make this doc page exist
                break;
            case index_js_2.KNOWN_IDENTITY_TYPES.self:
                name = 'You';
                avatarURL = 'XUT9jHGk2qace148jeCX5rDsMftkSGYKmigLwU2PLLBc7Hm63VYR';
                badgeLabel = 'Represents your ability to access this information.';
                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';
                badgeClickURL = 'https://projectbabbage.com/docs/self-identity'; // TODO: Make this doc page exist
                break;
            default:
                name = index_js_2.defaultIdentity.name;
                avatarURL = decryptedFields.profilePhoto;
                badgeLabel = index_js_2.defaultIdentity.badgeLabel;
                badgeIconURL = index_js_2.defaultIdentity.badgeIconURL;
                badgeClickURL = index_js_2.defaultIdentity.badgeClickURL; // TODO: Make this doc page exist
                break;
        }
        return {
            name,
            avatarURL,
            abbreviatedKey: identityToParse.subject.length > 0 ? `${identityToParse.subject.substring(0, 10)}...` : '',
            identityKey: identityToParse.subject,
            badgeIconURL,
            badgeLabel,
            badgeClickURL
        };
    }
}
exports.IdentityClient = IdentityClient;

},{"../auth/certificates/Certificate.js":4,"../auth/clients/index.js":10,"../overlay-tools/index.js":39,"../primitives/index.js":61,"../script/index.js":72,"../transaction/index.js":105,"../wallet/index.js":113,"./ContactsManager.js":27,"./types/index.js":30}],29:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./IdentityClient.js"), exports);
__exportStar(require("./types/index.js"), exports);

},{"./IdentityClient.js":28,"./types/index.js":30}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KNOWN_IDENTITY_TYPES = exports.DEFAULT_IDENTITY_CLIENT_OPTIONS = exports.defaultIdentity = void 0;
exports.defaultIdentity = {
    name: 'Unknown Identity',
    avatarURL: 'XUUB8bbn9fEthk15Ge3zTQXypUShfC94vFjp65v7u5CQ8qkpxzst',
    identityKey: '',
    abbreviatedKey: '',
    badgeIconURL: 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG',
    badgeLabel: 'Not verified by anyone you trust.',
    badgeClickURL: 'https://projectbabbage.com/docs/unknown-identity'
};
exports.DEFAULT_IDENTITY_CLIENT_OPTIONS = {
    protocolID: [1, 'identity'],
    keyID: '1',
    tokenAmount: 1,
    outputIndex: 0
};
exports.KNOWN_IDENTITY_TYPES = {
    identiCert: 'z40BOInXkI8m7f/wBrv4MJ09bZfzZbTj2fJqCtONqCY=',
    discordCert: '2TgqRC35B1zehGmB21xveZNc7i5iqHc0uxMb+1NMPW4=',
    phoneCert: 'mffUklUzxbHr65xLohn0hRL0Tq2GjW1GYF/OPfzqJ6A=',
    xCert: 'vdDWvftf1H+5+ZprUw123kjHlywH+v20aPQTuXgMpNc=',
    registrant: 'YoPsbfR6YQczjzPdHCoGC7nJsOdPQR50+SYqcWpJ0y0=',
    emailCert: 'exOl3KM0dIJ04EW5pZgbZmPag6MdJXd3/a1enmUU/BA=',
    anyone: 'mfkOMfLDQmrr3SBxBQ5WeE+6Hy3VJRFq6w4A5Ljtlis=',
    self: 'Hkge6X5JRxt1cWXtHLCrSTg6dCVTxjQJJ48iOYd7n3g=',
    coolCert: 'AGfk/WrT1eBDXpz3mcw386Zww2HmqcIn3uY6x4Af1eo='
};

},{}],31:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PushDrop_js_1 = __importDefault(require("../script/templates/PushDrop.js"));
const Utils = __importStar(require("../primitives/utils.js"));
const WalletClient_js_1 = __importDefault(require("../wallet/WalletClient.js"));
const Transaction_js_1 = __importDefault(require("../transaction/Transaction.js"));
const Beef_js_1 = require("../transaction/Beef.js");
/**
 * Implements a key-value storage system backed by transaction outputs managed by a wallet.
 * Each key-value pair is represented by a PushDrop token output in a specific context (basket).
 * Allows setting, getting, and removing key-value pairs, with optional encryption.
 */
class LocalKVStore {
    /**
     * Creates an instance of the localKVStore.
     *
     * @param {WalletInterface} [wallet=new WalletClient()] - The wallet interface to use. Defaults to a new WalletClient instance.
     * @param {string} [context='kvstoredefault'] - The context (basket) for namespacing keys. Defaults to 'kvstore default'.
     * @param {boolean} [encrypt=true] - Whether to encrypt values. Defaults to true.
     * @param {string} [originator] — An originator to use with PushDrop and the wallet, if provided.
     * @throws {Error} If the context is missing or empty.
     */
    constructor(wallet = new WalletClient_js_1.default(), context = 'kvstore default', encrypt = true, originator, acceptDelayedBroadcast = false) {
        this.acceptDelayedBroadcast = false;
        /**
         * A map to store locks for each key to ensure atomic updates.
         * @private
         */
        this.keyLocks = new Map();
        if (typeof context !== 'string' || context.length < 1) {
            throw new Error('A context in which to operate is required.');
        }
        this.wallet = wallet;
        this.context = context;
        this.encrypt = encrypt;
        this.originator = originator;
        this.acceptDelayedBroadcast = acceptDelayedBroadcast;
    }
    async queueOperationOnKey(key) {
        // Check if a lock exists for this key and wait for it to resolve
        let lockQueue = this.keyLocks.get(key);
        if (lockQueue == null) {
            lockQueue = [];
            this.keyLocks.set(key, lockQueue);
        }
        let resolveNewLock = () => { };
        const newLock = new Promise((resolve) => {
            resolveNewLock = resolve;
            if (lockQueue != null) {
                lockQueue.push(resolve);
            }
        });
        // If we are the only request, resolve the lock immediately, queue remains at 1 item until request ends.
        if (lockQueue.length === 1) {
            resolveNewLock();
        }
        await newLock;
        return lockQueue;
    }
    finishOperationOnKey(key, lockQueue) {
        lockQueue.shift(); // Remove the current lock from the queue
        if (lockQueue.length > 0) {
            // If there are more locks waiting, resolve the next one
            lockQueue[0]();
        }
    }
    getProtocol(key) {
        return { protocolID: [2, this.context], keyID: key };
    }
    async getOutputs(key, limit) {
        const results = await this.wallet.listOutputs({
            basket: this.context,
            tags: [key],
            tagQueryMode: 'all',
            include: 'entire transactions',
            limit
        });
        return results;
    }
    /**
     * Retrieves the value associated with a given key.
     *
     * @param {string} key - The key to retrieve the value for.
     * @param {string | undefined} [defaultValue=undefined] - The value to return if the key is not found.
     * @returns {Promise<string | undefined>} A promise that resolves to the value as a string,
     *   the defaultValue if the key is not found, or undefined if no defaultValue is provided.
     * @throws {Error} If too many outputs are found for the key (ambiguous state).
     * @throws {Error} If the found output's locking script cannot be decoded or represents an invalid token format.
     */
    async get(key, defaultValue = undefined) {
        const lockQueue = await this.queueOperationOnKey(key);
        try {
            const r = await this.lookupValue(key, defaultValue, 5);
            return r.value;
        }
        finally {
            this.finishOperationOnKey(key, lockQueue);
        }
    }
    getLockingScript(output, beef) {
        const [txid, vout] = output.outpoint.split('.');
        const tx = beef.findTxid(txid)?.tx;
        if (tx == null) {
            throw new Error(`beef must contain txid ${txid}`);
        }
        const lockingScript = tx.outputs[Number(vout)].lockingScript;
        return lockingScript;
    }
    async lookupValue(key, defaultValue, limit) {
        const lor = await this.getOutputs(key, limit);
        const r = { value: defaultValue, outpoint: undefined, lor };
        const { outputs } = lor;
        if (outputs.length === 0) {
            return r;
        }
        const output = outputs.slice(-1)[0];
        r.outpoint = output.outpoint;
        let field;
        try {
            if (lor.BEEF === undefined) {
                throw new Error('entire transactions listOutputs option must return valid BEEF');
            }
            const lockingScript = this.getLockingScript(output, Beef_js_1.Beef.fromBinary(lor.BEEF));
            const decoded = PushDrop_js_1.default.decode(lockingScript);
            if (decoded.fields.length < 1 || decoded.fields.length > 2) {
                throw new Error('Invalid token.');
            }
            field = decoded.fields[0];
        }
        catch (_) {
            throw new Error(`Invalid value found. You need to call set to collapse the corrupted state (or relinquish the corrupted ${outputs[0].outpoint} output from the ${this.context} basket) before you can get this value again.`);
        }
        if (!this.encrypt) {
            r.value = Utils.toUTF8(field);
        }
        else {
            const { plaintext } = await this.wallet.decrypt({
                ...this.getProtocol(key),
                ciphertext: field
            });
            r.value = Utils.toUTF8(plaintext);
        }
        return r;
    }
    getInputs(outputs) {
        const inputs = [];
        for (let i = 0; i < outputs.length; i++) {
            inputs.push({
                outpoint: outputs[i].outpoint,
                unlockingScriptLength: 74,
                inputDescription: 'Previous key-value token'
            });
        }
        return inputs;
    }
    async getSpends(key, outputs, pushdrop, atomicBEEF) {
        const p = this.getProtocol(key);
        const tx = Transaction_js_1.default.fromAtomicBEEF(atomicBEEF);
        const spends = {};
        for (let i = 0; i < outputs.length; i++) {
            const unlocker = pushdrop.unlock(p.protocolID, p.keyID, 'self');
            const unlockingScript = await unlocker.sign(tx, i);
            spends[i] = {
                unlockingScript: unlockingScript.toHex()
            };
        }
        return spends;
    }
    /**
     * Sets or updates the value associated with a given key atomically.
     * If the key already exists (one or more outputs found), it spends the existing output(s)
     * and creates a new one with the updated value. If multiple outputs exist for the key,
     * they are collapsed into a single new output.
     * If the key does not exist, it creates a new output.
     * Handles encryption if enabled.
     * If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain.
     * Ensures atomicity by locking the key during the operation, preventing concurrent updates
     * to the same key from missing earlier changes.
     *
     * @param {string} key - The key to set or update.
     * @param {string} value - The value to associate with the key.
     * @returns {Promise<OutpointString>} A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.
     */
    async set(key, value) {
        const lockQueue = await this.queueOperationOnKey(key);
        try {
            const current = await this.lookupValue(key, undefined, 10);
            if (current.value === value) {
                if (current.outpoint === undefined) {
                    throw new Error('outpoint must be valid when value is valid and unchanged');
                }
                // Don't create a new transaction if the value doesn't need to change
                return current.outpoint;
            }
            const protocol = this.getProtocol(key);
            let valueAsArray = Utils.toArray(value, 'utf8');
            if (this.encrypt) {
                const { ciphertext } = await this.wallet.encrypt({
                    ...protocol,
                    plaintext: valueAsArray
                });
                valueAsArray = ciphertext;
            }
            const pushdrop = new PushDrop_js_1.default(this.wallet, this.originator);
            const lockingScript = await pushdrop.lock([valueAsArray], protocol.protocolID, protocol.keyID, 'self');
            const { outputs, BEEF: inputBEEF } = current.lor;
            let outpoint;
            try {
                const inputs = this.getInputs(outputs);
                const { txid, signableTransaction } = await this.wallet.createAction({
                    description: `Update ${key} in ${this.context}`,
                    inputBEEF,
                    inputs,
                    outputs: [{
                            basket: this.context,
                            tags: [key],
                            lockingScript: lockingScript.toHex(),
                            satoshis: 1,
                            outputDescription: 'Key-value token'
                        }],
                    options: {
                        acceptDelayedBroadcast: this.acceptDelayedBroadcast,
                        randomizeOutputs: false
                    }
                });
                if (outputs.length > 0 && typeof signableTransaction !== 'object') {
                    throw new Error('Wallet did not return a signable transaction when expected.');
                }
                if (signableTransaction == null) {
                    outpoint = `${txid}.0`;
                }
                else {
                    const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);
                    const { txid } = await this.wallet.signAction({
                        reference: signableTransaction.reference,
                        spends
                    });
                    outpoint = `${txid}.0`;
                }
            }
            catch (_) {
                throw new Error(`There are ${outputs.length} outputs with tag ${key} that cannot be unlocked.`);
            }
            return outpoint;
        }
        finally {
            this.finishOperationOnKey(key, lockQueue);
        }
    }
    /**
     * Removes the key-value pair associated with the given key.
     * It finds the existing output(s) for the key and spends them without creating a new output.
     * If multiple outputs exist, they are all spent in the same transaction.
     * If the key does not exist, it does nothing.
     * If signing the removal transaction fails, it relinquishes the original outputs instead of spending.
     *
     * @param {string} key - The key to remove.
     * @returns {Promise<string[]>} A promise that resolves to the txids of the removal transactions if successful.
     */
    async remove(key) {
        const lockQueue = await this.queueOperationOnKey(key);
        try {
            const txids = [];
            for (;;) {
                const { outputs, BEEF: inputBEEF, totalOutputs } = await this.getOutputs(key);
                if (outputs.length > 0) {
                    const pushdrop = new PushDrop_js_1.default(this.wallet, this.originator);
                    try {
                        const inputs = this.getInputs(outputs);
                        const { signableTransaction } = await this.wallet.createAction({
                            description: `Remove ${key} in ${this.context}`,
                            inputBEEF,
                            inputs,
                            options: {
                                acceptDelayedBroadcast: this.acceptDelayedBroadcast
                            }
                        });
                        if (typeof signableTransaction !== 'object') {
                            throw new Error('Wallet did not return a signable transaction when expected.');
                        }
                        const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);
                        const { txid } = await this.wallet.signAction({
                            reference: signableTransaction.reference,
                            spends
                        });
                        if (txid === undefined) {
                            throw new Error('signAction must return a valid txid');
                        }
                        txids.push(txid);
                    }
                    catch (_) {
                        throw new Error(`There are ${totalOutputs} outputs with tag ${key} that cannot be unlocked.`);
                    }
                }
                if (outputs.length === totalOutputs) {
                    break;
                }
            }
            return txids;
        }
        finally {
            this.finishOperationOnKey(key, lockQueue);
        }
    }
}
exports.default = LocalKVStore;

},{"../primitives/utils.js":62,"../script/templates/PushDrop.js":74,"../transaction/Beef.js":83,"../transaction/Transaction.js":88,"../wallet/WalletClient.js":111}],32:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalKVStore = void 0;
var LocalKVStore_js_1 = require("./LocalKVStore.js");
Object.defineProperty(exports, "LocalKVStore", { enumerable: true, get: function () { return __importDefault(LocalKVStore_js_1).default; } });

},{"./LocalKVStore.js":31}],33:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = void 0;
const PublicKey_js_1 = __importDefault(require("../primitives/PublicKey.js"));
const SymmetricKey_js_1 = __importDefault(require("../primitives/SymmetricKey.js"));
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
const utils_js_1 = require("../primitives/utils.js");
const VERSION = '42421033';
/**
 * Encrypts a message from one party to another using the BRC-78 message encryption protocol.
 * @param message The message to encrypt
 * @param sender The private key of the sender
 * @param recipient The public key of the recipient
 *
 * @returns The encrypted message
 */
const encrypt = (message, sender, recipient) => {
    const keyID = (0, Random_js_1.default)(32);
    const keyIDBase64 = (0, utils_js_1.toBase64)(keyID);
    const invoiceNumber = `2-message encryption-${keyIDBase64}`;
    const signingPriv = sender.deriveChild(recipient, invoiceNumber);
    const recipientPub = recipient.deriveChild(sender, invoiceNumber);
    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);
    const symmetricKey = new SymmetricKey_js_1.default(sharedSecret.encode(true).slice(1));
    const encrypted = symmetricKey.encrypt(message);
    const senderPublicKey = sender.toPublicKey().encode(true);
    const version = (0, utils_js_1.toArray)(VERSION, 'hex');
    return [
        ...version,
        ...senderPublicKey,
        ...recipient.encode(true),
        ...keyID,
        ...encrypted
    ];
};
exports.encrypt = encrypt;
/**
 * Decrypts a message from one party to another using the BRC-78 message encryption protocol.
 * @param message The message to decrypt
 * @param sender The private key of the recipient
 *
 * @returns The decrypted message
 */
const decrypt = (message, recipient) => {
    const reader = new utils_js_1.Reader(message);
    const messageVersion = (0, utils_js_1.toHex)(reader.read(4));
    if (messageVersion !== VERSION) {
        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);
    }
    const sender = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(reader.read(33)));
    const expectedRecipientDER = (0, utils_js_1.toHex)(reader.read(33));
    const actualRecipientDER = recipient
        .toPublicKey()
        .encode(true, 'hex');
    if (expectedRecipientDER !== actualRecipientDER) {
        throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);
    }
    const keyID = (0, utils_js_1.toBase64)(reader.read(32));
    const encrypted = reader.read(reader.bin.length - reader.pos);
    const invoiceNumber = `2-message encryption-${keyID}`;
    const signingPriv = sender.deriveChild(recipient, invoiceNumber);
    const recipientPub = recipient.deriveChild(sender, invoiceNumber);
    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);
    const symmetricKey = new SymmetricKey_js_1.default(sharedSecret.encode(true).slice(1));
    return symmetricKey.decrypt(encrypted);
};
exports.decrypt = decrypt;

},{"../primitives/PublicKey.js":54,"../primitives/Random.js":55,"../primitives/SymmetricKey.js":59,"../primitives/utils.js":62}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = void 0;
// @ts-nocheck
const PublicKey_js_1 = __importDefault(require("../primitives/PublicKey.js"));
const PrivateKey_js_1 = __importDefault(require("../primitives/PrivateKey.js"));
const Signature_js_1 = __importDefault(require("../primitives/Signature.js"));
const Curve_js_1 = __importDefault(require("../primitives/Curve.js"));
const Random_js_1 = __importDefault(require("../primitives/Random.js"));
const utils_js_1 = require("../primitives/utils.js");
const VERSION = '42423301';
/**
 * Signs a message from one party to be verified by another, or for verification by anyone, using the BRC-77 message signing protocol.
 * @param message The message to sign
 * @param signer The private key of the message signer
 * @param [verifier] The public key of the person who can verify the message. If not provided, anyone will be able to verify the message signature.
 *
 * @returns The message signature.
 */
const sign = (message, signer, verifier) => {
    const recipientAnyone = typeof verifier !== 'object';
    if (recipientAnyone) {
        const curve = new Curve_js_1.default();
        const anyone = new PrivateKey_js_1.default(1);
        const anyonePoint = curve.g.mul(anyone);
        verifier = new PublicKey_js_1.default(anyonePoint.x, anyonePoint.y);
    }
    const keyID = (0, Random_js_1.default)(32);
    const keyIDBase64 = (0, utils_js_1.toBase64)(keyID);
    const invoiceNumber = `2-message signing-${keyIDBase64}`;
    const signingKey = signer.deriveChild(verifier, invoiceNumber);
    const signature = signingKey.sign(message).toDER();
    const senderPublicKey = signer.toPublicKey().encode(true);
    const version = (0, utils_js_1.toArray)(VERSION, 'hex');
    return [
        ...version,
        ...senderPublicKey,
        ...(recipientAnyone ? [0] : verifier.encode(true)),
        ...keyID,
        ...signature
    ];
};
exports.sign = sign;
/**
 * Verifies a message using the BRC-77 message signing protocol.
 * @param message The message to verify.
 * @param sig The message signature to be verified.
 * @param [recipient] The private key of the message verifier. This can be omitted if the message is verifiable by anyone.
 *
 * @returns True if the message is verified.
 */
const verify = (message, sig, recipient) => {
    const reader = new utils_js_1.Reader(sig);
    const messageVersion = (0, utils_js_1.toHex)(reader.read(4));
    if (messageVersion !== VERSION) {
        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);
    }
    const signer = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(reader.read(33)));
    const [verifierFirst] = reader.read(1);
    if (verifierFirst === 0) {
        recipient = new PrivateKey_js_1.default(1);
    }
    else {
        const verifierRest = reader.read(32);
        const verifierDER = (0, utils_js_1.toHex)([verifierFirst, ...verifierRest]);
        if (typeof recipient !== 'object') {
            throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);
        }
        const recipientDER = recipient.toPublicKey().encode(true, 'hex');
        if (verifierDER !== recipientDER) {
            throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);
        }
    }
    const keyID = (0, utils_js_1.toBase64)(reader.read(32));
    const signatureDER = (0, utils_js_1.toHex)(reader.read(reader.bin.length - reader.pos));
    const signature = Signature_js_1.default.fromDER(signatureDER, 'hex');
    const invoiceNumber = `2-message signing-${keyID}`;
    const signingKey = signer.deriveChild(recipient, invoiceNumber);
    const verified = signingKey.verify(message, signature);
    return verified;
};
exports.verify = verify;

},{"../primitives/Curve.js":43,"../primitives/PrivateKey.js":53,"../primitives/PublicKey.js":54,"../primitives/Random.js":55,"../primitives/Signature.js":58,"../primitives/utils.js":62}],35:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedMessage = exports.SignedMessage = void 0;
exports.SignedMessage = __importStar(require("./SignedMessage.js"));
exports.EncryptedMessage = __importStar(require("./EncryptedMessage.js"));

},{"./EncryptedMessage.js":33,"./SignedMessage.js":34}],36:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPSOverlayLookupFacilitator = exports.DEFAULT_TESTNET_SLAP_TRACKERS = exports.DEFAULT_SLAP_TRACKERS = void 0;
const index_js_1 = require("../transaction/index.js");
const OverlayAdminTokenTemplate_js_1 = __importDefault(require("./OverlayAdminTokenTemplate.js"));
// Only bind window.fetch in the browser
const defaultFetch = typeof window !== 'undefined' ? fetch.bind(window) : fetch;
/** Default SLAP trackers */
exports.DEFAULT_SLAP_TRACKERS = [
    // BSVA clusters
    'https://overlay-us-1.bsvb.tech',
    'https://overlay-eu-1.bsvb.tech',
    'https://overlay-ap-1.bsvb.tech',
    // Babbage primary overlay service
    'https://users.bapp.dev'
    // NOTE: Other entities may submit pull requests to the library if they maintain SLAP overlay services.
    // Additional trackers run by different entities contribute to greater network resiliency.
    // It also generally doesn't hurt to have more trackers in this list.
    // DISCLAIMER:
    // Trackers known to host invalid or illegal records will be removed at the discretion of the BSV Association.
];
/** Default testnet SLAP trackers */
exports.DEFAULT_TESTNET_SLAP_TRACKERS = [
    // Babbage primary testnet overlay service
    'https://testnet-users.bapp.dev'
];
const MAX_TRACKER_WAIT_TIME = 5000;
class HTTPSOverlayLookupFacilitator {
    constructor(httpClient = defaultFetch, allowHTTP = false) {
        this.fetchClient = httpClient;
        this.allowHTTP = allowHTTP;
    }
    async lookup(url, question, timeout = 5000) {
        if (!url.startsWith('https:') && !this.allowHTTP) {
            throw new Error('HTTPS facilitator can only use URLs that start with "https:"');
        }
        const controller = typeof AbortController !== 'undefined' ? new AbortController() : undefined;
        const timer = setTimeout(() => {
            try {
                controller?.abort();
            }
            catch { /* noop */ }
        }, timeout);
        try {
            const fco = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ service: question.service, query: question.query }),
                signal: controller?.signal
            };
            const response = await this.fetchClient(`${url}/lookup`, fco);
            if (!response.ok)
                throw new Error(`Failed to facilitate lookup (HTTP ${response.status})`);
            return await response.json();
        }
        catch (e) {
            // Normalize timeouts to a consistent error message
            if (e?.name === 'AbortError')
                throw new Error('Request timed out');
            throw e;
        }
        finally {
            clearTimeout(timer);
        }
    }
}
exports.HTTPSOverlayLookupFacilitator = HTTPSOverlayLookupFacilitator;
/**
 * Represents a Lookup Resolver.
 */
class LookupResolver {
    constructor(config = {}) {
        this.networkPreset = config.networkPreset ?? 'mainnet';
        this.facilitator = config.facilitator ?? new HTTPSOverlayLookupFacilitator(undefined, this.networkPreset === 'local');
        this.slapTrackers = config.slapTrackers ?? (this.networkPreset === 'mainnet' ? exports.DEFAULT_SLAP_TRACKERS : exports.DEFAULT_TESTNET_SLAP_TRACKERS);
        this.hostOverrides = config.hostOverrides ?? {};
        this.additionalHosts = config.additionalHosts ?? {};
        // cache tuning
        this.hostsTtlMs = config.cache?.hostsTtlMs ?? 5 * 60 * 1000; // 5 min
        this.hostsMaxEntries = config.cache?.hostsMaxEntries ?? 128;
        this.txMemoTtlMs = config.cache?.txMemoTtlMs ?? 10 * 60 * 1000; // 10 min
        this.hostsCache = new Map();
        this.hostsInFlight = new Map();
        this.txMemo = new Map();
    }
    /**
     * Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.
     */
    async query(question, timeout) {
        let competentHosts = [];
        if (question.service === 'ls_slap') {
            competentHosts = this.networkPreset === 'local' ? ['http://localhost:8080'] : this.slapTrackers;
        }
        else if (this.hostOverrides[question.service] != null) {
            competentHosts = this.hostOverrides[question.service];
        }
        else if (this.networkPreset === 'local') {
            competentHosts = ['http://localhost:8080'];
        }
        else {
            competentHosts = await this.getCompetentHostsCached(question.service);
        }
        if (this.additionalHosts[question.service]?.length > 0) {
            // preserve order: resolved hosts first, then additional (unique)
            const extra = this.additionalHosts[question.service];
            const seen = new Set(competentHosts);
            for (const h of extra)
                if (!seen.has(h))
                    competentHosts.push(h);
        }
        if (competentHosts.length < 1) {
            throw new Error(`No competent ${this.networkPreset} hosts found by the SLAP trackers for lookup service: ${question.service}`);
        }
        // Fire all hosts with per-host timeout, harvest successful output-list responses
        const hostResponses = await Promise.allSettled(competentHosts.map(async (host) => {
            return await this.facilitator.lookup(host, question, timeout);
        }));
        const outputsMap = new Map();
        // Memo key helper for tx parsing
        const beefKey = (beef) => {
            if (typeof beef !== 'object')
                return ''; // The invalid BEEF has an empty key.
            // A fast and deterministic key for memoization; avoids large JSON strings
            // since beef is an array of integers, join is safe and compact.
            return beef.join(',');
        };
        for (const result of hostResponses) {
            if (result.status !== 'fulfilled')
                continue;
            const response = result.value;
            if (response?.type !== 'output-list' || !Array.isArray(response.outputs))
                continue;
            for (const output of response.outputs) {
                const keyForBeef = beefKey(output.beef);
                let memo = this.txMemo.get(keyForBeef);
                const now = Date.now();
                if (typeof memo !== 'object' || memo === null || memo.expiresAt <= now) {
                    try {
                        const txId = index_js_1.Transaction.fromBEEF(output.beef).id('hex');
                        memo = { txId, expiresAt: now + this.txMemoTtlMs };
                        // prune opportunistically if the map gets too large (cheap heuristic)
                        if (this.txMemo.size > 4096)
                            this.evictOldest(this.txMemo);
                        this.txMemo.set(keyForBeef, memo);
                    }
                    catch {
                        continue;
                    }
                }
                const uniqKey = `${memo.txId}.${output.outputIndex}`;
                // last-writer wins is fine here; outputs are identical if uniqKey matches
                outputsMap.set(uniqKey, output);
            }
        }
        return {
            type: 'output-list',
            outputs: Array.from(outputsMap.values())
        };
    }
    /**
     * Cached wrapper for competent host discovery with stale-while-revalidate.
     */
    async getCompetentHostsCached(service) {
        const now = Date.now();
        const cached = this.hostsCache.get(service);
        // if fresh, return immediately
        if (typeof cached === 'object' && cached.expiresAt > now) {
            return cached.hosts.slice();
        }
        // if stale but present, kick off a refresh if not already in-flight and return stale
        if (typeof cached === 'object' && cached.expiresAt <= now) {
            if (!this.hostsInFlight.has(service)) {
                this.hostsInFlight.set(service, this.refreshHosts(service).finally(() => {
                    this.hostsInFlight.delete(service);
                }));
            }
            return cached.hosts.slice();
        }
        // no cache: coalesce concurrent requests
        if (this.hostsInFlight.has(service)) {
            try {
                const hosts = await this.hostsInFlight.get(service);
                if (typeof hosts !== 'object') {
                    throw new Error('Hosts is not defined.');
                }
                return hosts.slice();
            }
            catch {
                // fall through to a fresh attempt below
            }
        }
        const promise = this.refreshHosts(service).finally(() => {
            this.hostsInFlight.delete(service);
        });
        this.hostsInFlight.set(service, promise);
        const hosts = await promise;
        return hosts.slice();
    }
    /**
     * Actually resolves competent hosts from SLAP trackers and updates cache.
     */
    async refreshHosts(service) {
        const hosts = await this.findCompetentHosts(service);
        const expiresAt = Date.now() + this.hostsTtlMs;
        // bounded cache with simple FIFO eviction
        if (!this.hostsCache.has(service) && this.hostsCache.size >= this.hostsMaxEntries) {
            const oldestKey = this.hostsCache.keys().next().value;
            if (oldestKey !== undefined)
                this.hostsCache.delete(oldestKey);
        }
        this.hostsCache.set(service, { hosts, expiresAt });
        return hosts;
    }
    /**
     * Returns a list of competent hosts for a given lookup service.
     * @param service Service for which competent hosts are to be returned
     * @returns Array of hosts competent for resolving queries
     */
    async findCompetentHosts(service) {
        const query = {
            service: 'ls_slap',
            query: { service }
        };
        // Query all SLAP trackers; tolerate failures.
        const trackerResponses = await Promise.allSettled(this.slapTrackers.map(async (tracker) => await this.facilitator.lookup(tracker, query, MAX_TRACKER_WAIT_TIME)));
        const hosts = new Set();
        for (const result of trackerResponses) {
            if (result.status !== 'fulfilled')
                continue;
            const answer = result.value;
            if (answer.type !== 'output-list')
                continue;
            for (const output of answer.outputs) {
                try {
                    const tx = index_js_1.Transaction.fromBEEF(output.beef);
                    const script = tx.outputs[output.outputIndex]?.lockingScript;
                    if (typeof script !== 'object' || script === null)
                        continue;
                    const parsed = OverlayAdminTokenTemplate_js_1.default.decode(script);
                    if (parsed.topicOrService !== service || parsed.protocol !== 'SLAP')
                        continue;
                    if (typeof parsed.domain === 'string' && parsed.domain.length > 0) {
                        hosts.add(parsed.domain);
                    }
                }
                catch {
                    continue;
                }
            }
        }
        return [...hosts];
    }
    /** Evict an arbitrary “oldest” entry from a Map (iteration order). */
    evictOldest(m) {
        const firstKey = m.keys().next().value;
        if (firstKey !== undefined)
            m.delete(firstKey);
    }
}
exports.default = LookupResolver;

},{"../transaction/index.js":105,"./OverlayAdminTokenTemplate.js":37}],37:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PushDrop_js_1 = __importDefault(require("../script/templates/PushDrop.js"));
const index_js_1 = require("../primitives/index.js");
/**
 * Script template enabling the creation, unlocking, and decoding of SHIP and SLAP advertisements.
 */
class OverlayAdminTokenTemplate {
    /**
     * Decodes a SHIP or SLAP advertisement from a given locking script.
     * @param script Locking script comprising a SHIP or SLAP token to decode
     * @returns Decoded SHIP or SLAP advertisement
     */
    static decode(script) {
        const result = PushDrop_js_1.default.decode(script);
        if (result.fields.length < 4) {
            throw new Error('Invalid SHIP/SLAP advertisement!');
        }
        const protocol = index_js_1.Utils.toUTF8(result.fields[0]);
        if (protocol !== 'SHIP' && protocol !== 'SLAP') {
            throw new Error('Invalid protocol type!');
        }
        const identityKey = index_js_1.Utils.toHex(result.fields[1]);
        const domain = index_js_1.Utils.toUTF8(result.fields[2]);
        const topicOrService = index_js_1.Utils.toUTF8(result.fields[3]);
        return {
            protocol,
            identityKey,
            domain,
            topicOrService
        };
    }
    /**
     * Constructs a new Overlay Admin template instance
     * @param wallet Wallet to use for locking and unlocking
     */
    constructor(wallet) {
        this.pushDrop = new PushDrop_js_1.default(wallet);
    }
    /**
     * Creates a new advertisement locking script
     * @param protocol SHIP or SLAP
     * @param domain Domain where the topic or service is available
     * @param topicOrService Topic or service to advertise
     * @returns Locking script comprising the advertisement token
     */
    async lock(protocol, domain, topicOrService) {
        const { publicKey: identityKey } = await this.pushDrop.wallet.getPublicKey({
            identityKey: true
        });
        return await this.pushDrop.lock([
            index_js_1.Utils.toArray(protocol, 'utf8'),
            index_js_1.Utils.toArray(identityKey, 'hex'),
            index_js_1.Utils.toArray(domain, 'utf8'),
            index_js_1.Utils.toArray(topicOrService, 'utf8')
        ], [
            2,
            protocol === 'SHIP'
                ? 'Service Host Interconnect'
                : 'Service Lookup Availability'
        ], '1', 'self');
    }
    /**
     * Unlocks an advertisement token as part of a transaction.
     * @param protocol SHIP or SLAP, depending on the token to unlock
     * @returns Script unlocker capable of unlocking the advertisement token
     */
    unlock(protocol) {
        return this.pushDrop.unlock([
            2,
            protocol === 'SHIP'
                ? 'Service Host Interconnect'
                : 'Service Lookup Availability'
        ], '1', 'self');
    }
}
exports.default = OverlayAdminTokenTemplate;

},{"../primitives/index.js":61,"../script/templates/PushDrop.js":74}],38:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPSOverlayBroadcastFacilitator = void 0;
const index_js_1 = require("../transaction/index.js");
const Utils = __importStar(require("../primitives/utils.js"));
const LookupResolver_js_1 = __importDefault(require("./LookupResolver.js"));
const OverlayAdminTokenTemplate_js_1 = __importDefault(require("./OverlayAdminTokenTemplate.js"));
const MAX_SHIP_QUERY_TIMEOUT = 5000;
class HTTPSOverlayBroadcastFacilitator {
    constructor(httpClient = fetch, allowHTTP = false) {
        this.httpClient = httpClient;
        this.allowHTTP = allowHTTP;
    }
    async send(url, taggedBEEF) {
        if (!url.startsWith('https:') && !this.allowHTTP) {
            throw new Error('HTTPS facilitator can only use URLs that start with "https:"');
        }
        const headers = {
            'Content-Type': 'application/octet-stream',
            'X-Topics': JSON.stringify(taggedBEEF.topics)
        };
        let body;
        if (Array.isArray(taggedBEEF.offChainValues)) {
            headers['x-includes-off-chain-values'] = 'true';
            const w = new Utils.Writer();
            w.writeVarIntNum(taggedBEEF.beef.length);
            w.write(taggedBEEF.beef);
            w.write(taggedBEEF.offChainValues);
            body = new Uint8Array(w.toArray());
        }
        else {
            body = new Uint8Array(taggedBEEF.beef);
        }
        const response = await fetch(`${url}/submit`, {
            method: 'POST',
            headers,
            body
        });
        if (response.ok) {
            return await response.json();
        }
        else {
            throw new Error('Failed to facilitate broadcast');
        }
    }
}
exports.HTTPSOverlayBroadcastFacilitator = HTTPSOverlayBroadcastFacilitator;
/**
 * Broadcasts transactions to one or more overlay topics.
 */
class TopicBroadcaster {
    /**
     * Constructs an instance of the SHIP broadcaster.
     *
     * @param {string[]} topics - The list of SHIP topic names where transactions are to be sent.
     * @param {SHIPBroadcasterConfig} config - Configuration options for the SHIP broadcaster.
     */
    constructor(topics, config = {}) {
        if (topics.length === 0) {
            throw new Error('At least one topic is required for broadcast.');
        }
        if (topics.some((x) => !x.startsWith('tm_'))) {
            throw new Error('Every topic must start with "tm_".');
        }
        this.topics = topics;
        this.networkPreset = config.networkPreset ?? 'mainnet';
        this.facilitator = config.facilitator ?? new HTTPSOverlayBroadcastFacilitator(undefined, this.networkPreset === 'local');
        this.resolver = config.resolver ?? new LookupResolver_js_1.default({ networkPreset: this.networkPreset });
        this.requireAcknowledgmentFromAllHostsForTopics =
            config.requireAcknowledgmentFromAllHostsForTopics ?? [];
        this.requireAcknowledgmentFromAnyHostForTopics =
            config.requireAcknowledgmentFromAnyHostForTopics ?? 'all';
        this.requireAcknowledgmentFromSpecificHostsForTopics =
            config.requireAcknowledgmentFromSpecificHostsForTopics ?? {};
    }
    /**
     * Broadcasts a transaction to Overlay Services via SHIP.
     *
     * @param {Transaction} tx - The transaction to be sent.
     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
     */
    async broadcast(tx) {
        let beef;
        const offChainValues = tx.metadata.get('OffChainValues');
        try {
            beef = tx.toBEEF();
        }
        catch (error) {
            throw new Error('Transactions sent via SHIP to Overlay Services must be serializable to BEEF format.');
        }
        const interestedHosts = await this.findInterestedHosts();
        if (Object.keys(interestedHosts).length === 0) {
            return {
                status: 'error',
                code: 'ERR_NO_HOSTS_INTERESTED',
                description: `No ${this.networkPreset} hosts are interested in receiving this transaction.`
            };
        }
        const hostPromises = Object.entries(interestedHosts).map(async ([host, topics]) => {
            try {
                const steak = await this.facilitator.send(host, {
                    beef,
                    offChainValues,
                    topics: [...topics]
                });
                if (steak == null || Object.keys(steak).length === 0) {
                    throw new Error('Steak has no topics.');
                }
                return { host, success: true, steak };
            }
            catch (error) {
                console.error(error);
                // Log error if needed
                return { host, success: false, error };
            }
        });
        const results = await Promise.all(hostPromises);
        const successfulHosts = results.filter((result) => result.success);
        if (successfulHosts.length === 0) {
            return {
                status: 'error',
                code: 'ERR_ALL_HOSTS_REJECTED',
                description: `All ${this.networkPreset} topical hosts have rejected the transaction.`
            };
        }
        // Collect host acknowledgments
        const hostAcknowledgments = {};
        for (const result of successfulHosts) {
            const host = result.host;
            const steak = result.steak;
            const acknowledgedTopics = new Set();
            for (const [topic, instructions] of Object.entries(steak)) {
                const outputsToAdmit = instructions.outputsToAdmit;
                const coinsToRetain = instructions.coinsToRetain;
                const coinsRemoved = instructions.coinsRemoved;
                if (outputsToAdmit?.length > 0 ||
                    coinsToRetain?.length > 0 ||
                    coinsRemoved?.length > 0) {
                    acknowledgedTopics.add(topic);
                }
            }
            hostAcknowledgments[host] = acknowledgedTopics;
        }
        // Now, perform the checks
        // Check requireAcknowledgmentFromAllHostsForTopics
        let requiredTopicsAllHosts;
        let requireAllHosts;
        if (this.requireAcknowledgmentFromAllHostsForTopics === 'all') {
            requiredTopicsAllHosts = this.topics;
            requireAllHosts = 'all';
        }
        else if (this.requireAcknowledgmentFromAllHostsForTopics === 'any') {
            requiredTopicsAllHosts = this.topics;
            requireAllHosts = 'any';
        }
        else if (Array.isArray(this.requireAcknowledgmentFromAllHostsForTopics)) {
            requiredTopicsAllHosts = this.requireAcknowledgmentFromAllHostsForTopics;
            requireAllHosts = 'all';
        }
        else {
            // Default to 'all' and 'all'
            requiredTopicsAllHosts = this.topics;
            requireAllHosts = 'all';
        }
        if (requiredTopicsAllHosts.length > 0) {
            const allHostsAcknowledged = this.checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopicsAllHosts, requireAllHosts);
            if (!allHostsAcknowledged) {
                return {
                    status: 'error',
                    code: 'ERR_REQUIRE_ACK_FROM_ALL_HOSTS_FAILED',
                    description: 'Not all hosts acknowledged the required topics.'
                };
            }
        }
        // Check requireAcknowledgmentFromAnyHostForTopics
        let requiredTopicsAnyHost;
        let requireAnyHost;
        if (this.requireAcknowledgmentFromAnyHostForTopics === 'all') {
            requiredTopicsAnyHost = this.topics;
            requireAnyHost = 'all';
        }
        else if (this.requireAcknowledgmentFromAnyHostForTopics === 'any') {
            requiredTopicsAnyHost = this.topics;
            requireAnyHost = 'any';
        }
        else if (Array.isArray(this.requireAcknowledgmentFromAnyHostForTopics)) {
            requiredTopicsAnyHost = this.requireAcknowledgmentFromAnyHostForTopics;
            requireAnyHost = 'all';
        }
        else {
            // No requirement
            requiredTopicsAnyHost = [];
            requireAnyHost = 'all';
        }
        if (requiredTopicsAnyHost.length > 0) {
            const anyHostAcknowledged = this.checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopicsAnyHost, requireAnyHost);
            if (!anyHostAcknowledged) {
                return {
                    status: 'error',
                    code: 'ERR_REQUIRE_ACK_FROM_ANY_HOST_FAILED',
                    description: 'No host acknowledged the required topics.'
                };
            }
        }
        // Check requireAcknowledgmentFromSpecificHostsForTopics
        if (Object.keys(this.requireAcknowledgmentFromSpecificHostsForTopics).length >
            0) {
            const specificHostsAcknowledged = this.checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, this.requireAcknowledgmentFromSpecificHostsForTopics);
            if (!specificHostsAcknowledged) {
                return {
                    status: 'error',
                    code: 'ERR_REQUIRE_ACK_FROM_SPECIFIC_HOSTS_FAILED',
                    description: 'Specific hosts did not acknowledge the required topics.'
                };
            }
        }
        // If all checks pass, return success
        return {
            status: 'success',
            txid: tx.id('hex'),
            message: `Sent to ${successfulHosts.length} Overlay Services ${successfulHosts.length === 1 ? 'host' : 'hosts'}.`
        };
    }
    checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopics, require) {
        for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {
            if (require === 'all') {
                for (const topic of requiredTopics) {
                    if (!acknowledgedTopics.has(topic)) {
                        return false;
                    }
                }
            }
            else if (require === 'any') {
                let anyAcknowledged = false;
                for (const topic of requiredTopics) {
                    if (acknowledgedTopics.has(topic)) {
                        anyAcknowledged = true;
                        break;
                    }
                }
                if (!anyAcknowledged) {
                    return false;
                }
            }
        }
        return true;
    }
    checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopics, require) {
        if (require === 'all') {
            // All required topics must be acknowledged by at least one host
            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {
                let acknowledgesAllRequiredTopics = true;
                for (const topic of requiredTopics) {
                    if (!acknowledgedTopics.has(topic)) {
                        acknowledgesAllRequiredTopics = false;
                        break;
                    }
                }
                if (acknowledgesAllRequiredTopics) {
                    return true;
                }
            }
            return false;
        }
        else {
            // At least one required topic must be acknowledged by at least one host
            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {
                for (const topic of requiredTopics) {
                    if (acknowledgedTopics.has(topic)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, requirements) {
        for (const [host, requiredTopicsOrAllAny] of Object.entries(requirements)) {
            const acknowledgedTopics = hostAcknowledgments[host];
            if (acknowledgedTopics == null) {
                // Host did not respond successfully
                return false;
            }
            let requiredTopics;
            let require;
            if (requiredTopicsOrAllAny === 'all' ||
                requiredTopicsOrAllAny === 'any') {
                require = requiredTopicsOrAllAny;
                requiredTopics = this.topics;
            }
            else if (Array.isArray(requiredTopicsOrAllAny)) {
                requiredTopics = requiredTopicsOrAllAny;
                require = 'all';
            }
            else {
                // Invalid configuration
                continue;
            }
            if (require === 'all') {
                for (const topic of requiredTopics) {
                    if (!acknowledgedTopics.has(topic)) {
                        return false;
                    }
                }
            }
            else if (require === 'any') {
                let anyAcknowledged = false;
                for (const topic of requiredTopics) {
                    if (acknowledgedTopics.has(topic)) {
                        anyAcknowledged = true;
                        break;
                    }
                }
                if (!anyAcknowledged) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Finds which hosts are interested in transactions tagged with the given set of topics.
     *
     * @returns A mapping of URLs for hosts interested in this transaction. Keys are URLs, values are which of our topics the specific host cares about.
     */
    async findInterestedHosts() {
        // Handle the local network preset
        if (this.networkPreset === 'local') {
            const resultSet = new Set();
            for (let i = 0; i < this.topics.length; i++) {
                resultSet.add(this.topics[i]);
            }
            return { 'http://localhost:8080': resultSet };
        }
        // TODO: cache the list of interested hosts to avoid spamming SHIP trackers.
        // TODO: Monetize the operation of the SHIP tracker system.
        // TODO: Cache ship/slap lookup with expiry (every 5min)
        // Find all SHIP advertisements for the topics we care about
        const results = {};
        const answer = await this.resolver.query({
            service: 'ls_ship',
            query: {
                topics: this.topics
            }
        }, MAX_SHIP_QUERY_TIMEOUT);
        if (answer.type !== 'output-list') {
            throw new Error('SHIP answer is not an output list.');
        }
        for (const output of answer.outputs) {
            try {
                const tx = index_js_1.Transaction.fromBEEF(output.beef);
                const script = tx.outputs[output.outputIndex].lockingScript;
                const parsed = OverlayAdminTokenTemplate_js_1.default.decode(script);
                if (!this.topics.includes(parsed.topicOrService) ||
                    parsed.protocol !== 'SHIP') {
                    // This should make us think a LOT less highly of this SHIP tracker if it ever happens...
                    continue;
                }
                if (results[parsed.domain] === undefined) {
                    results[parsed.domain] = new Set();
                }
                results[parsed.domain].add(parsed.topicOrService);
            }
            catch (e) {
                continue;
            }
        }
        return results;
    }
}
exports.default = TopicBroadcaster;

},{"../primitives/utils.js":62,"../transaction/index.js":105,"./LookupResolver.js":36,"./OverlayAdminTokenTemplate.js":37}],39:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHIPCast = exports.SHIPBroadcaster = exports.TopicBroadcaster = exports.LookupResolver = exports.OverlayAdminTokenTemplate = void 0;
__exportStar(require("./LookupResolver.js"), exports);
__exportStar(require("./SHIPBroadcaster.js"), exports);
var OverlayAdminTokenTemplate_js_1 = require("./OverlayAdminTokenTemplate.js");
Object.defineProperty(exports, "OverlayAdminTokenTemplate", { enumerable: true, get: function () { return __importDefault(OverlayAdminTokenTemplate_js_1).default; } });
var LookupResolver_js_1 = require("./LookupResolver.js");
Object.defineProperty(exports, "LookupResolver", { enumerable: true, get: function () { return __importDefault(LookupResolver_js_1).default; } });
// For intuitive clarity, we name this the Topic Broadcaster.
var SHIPBroadcaster_js_1 = require("./SHIPBroadcaster.js");
Object.defineProperty(exports, "TopicBroadcaster", { enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_1).default; } });
// Historically, it was also known by two other names:
var SHIPBroadcaster_js_2 = require("./SHIPBroadcaster.js");
Object.defineProperty(exports, "SHIPBroadcaster", { enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_2).default; } });
var SHIPBroadcaster_js_3 = require("./SHIPBroadcaster.js");
Object.defineProperty(exports, "SHIPCast", { enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_3).default; } });

},{"./LookupResolver.js":36,"./OverlayAdminTokenTemplate.js":37,"./SHIPBroadcaster.js":38}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AESGCMDecrypt = exports.AESGCM = exports.ghash = exports.incrementLeastSignificantThirtyTwoBits = exports.multiply = exports.rightShift = exports.exclusiveOR = exports.getBytes = exports.checkBit = exports.AES = void 0;
// @ts-nocheck
const SBox = new Uint8Array([
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
]);
const Rcon = [
    [0x00, 0x00, 0x00, 0x00], [0x01, 0x00, 0x00, 0x00], [0x02, 0x00, 0x00, 0x00], [0x04, 0x00, 0x00, 0x00],
    [0x08, 0x00, 0x00, 0x00], [0x10, 0x00, 0x00, 0x00], [0x20, 0x00, 0x00, 0x00], [0x40, 0x00, 0x00, 0x00],
    [0x80, 0x00, 0x00, 0x00], [0x1b, 0x00, 0x00, 0x00], [0x36, 0x00, 0x00, 0x00]
].map(v => new Uint8Array(v));
const mul2 = new Uint8Array(256);
const mul3 = new Uint8Array(256);
for (let i = 0; i < 256; i++) {
    const m2 = ((i << 1) ^ ((i & 0x80) !== 0 ? 0x1b : 0)) & 0xff;
    mul2[i] = m2;
    mul3[i] = m2 ^ i;
}
function addRoundKey(state, roundKeyArray, offset) {
    for (let c = 0; c < 4; c++) {
        const keyCol = roundKeyArray[offset + c];
        for (let r = 0; r < 4; r++) {
            state[r][c] ^= keyCol[r];
        }
    }
}
function subBytes(state) {
    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
            state[r][c] = SBox[state[r][c]];
        }
    }
}
function subWord(value) {
    for (let i = 0; i < 4; i++) {
        value[i] = SBox[value[i]];
    }
}
function rotWord(value) {
    const temp = value[0];
    value[0] = value[1];
    value[1] = value[2];
    value[2] = value[3];
    value[3] = temp;
}
function shiftRows(state) {
    let tmp = state[1][0];
    state[1][0] = state[1][1];
    state[1][1] = state[1][2];
    state[1][2] = state[1][3];
    state[1][3] = tmp;
    tmp = state[2][0];
    const tmp2 = state[2][1];
    state[2][0] = state[2][2];
    state[2][1] = state[2][3];
    state[2][2] = tmp;
    state[2][3] = tmp2;
    tmp = state[3][3];
    state[3][3] = state[3][2];
    state[3][2] = state[3][1];
    state[3][1] = state[3][0];
    state[3][0] = tmp;
}
function mixColumns(state) {
    for (let c = 0; c < 4; c++) {
        const s0 = state[0][c];
        const s1 = state[1][c];
        const s2 = state[2][c];
        const s3 = state[3][c];
        state[0][c] = mul2[s0] ^ mul3[s1] ^ s2 ^ s3;
        state[1][c] = s0 ^ mul2[s1] ^ mul3[s2] ^ s3;
        state[2][c] = s0 ^ s1 ^ mul2[s2] ^ mul3[s3];
        state[3][c] = mul3[s0] ^ s1 ^ s2 ^ mul2[s3];
    }
}
function keyExpansion(roundLimit, key) {
    const nK = key.length / 4;
    const result = [];
    for (let i = 0; i < key.length; i++) {
        if (i % 4 === 0)
            result.push([]);
        result[i >> 2].push(key[i]);
    }
    for (let i = nK; i < 4 * roundLimit; i++) {
        result[i] = [];
        const temp = result[i - 1].slice();
        if (i % nK === 0) {
            rotWord(temp);
            subWord(temp);
            const r = Rcon[i / nK];
            for (let j = 0; j < 4; j++) {
                temp[j] ^= r[j];
            }
        }
        else if (nK > 6 && (i % nK) === 4) {
            subWord(temp);
        }
        for (let j = 0; j < 4; j++) {
            result[i][j] = result[i - nK][j] ^ temp[j];
        }
    }
    return result;
}
function AES(input, key) {
    let i;
    let j;
    let round;
    let roundLimit;
    const state = [[], [], [], []];
    const output = [];
    // Since the BigNumber representation of keys ignores big endian zeroes,
    // extend incoming key arrays with zeros to the smallest standard key size.
    const ekey = Array.from(key);
    if (ekey.length <= 16) {
        while (ekey.length < 16)
            ekey.unshift(0);
        roundLimit = 11;
    }
    else if (ekey.length <= 24) {
        while (ekey.length < 24)
            ekey.unshift(0);
        roundLimit = 13;
    }
    else if (key.length <= 32) {
        while (ekey.length < 32)
            ekey.unshift(0);
        roundLimit = 15;
    }
    else {
        throw new Error('Illegal key length: ' + String(key.length));
    }
    const w = keyExpansion(roundLimit, ekey);
    for (let c = 0; c < 4; c++) {
        state[0][c] = input[c * 4];
        state[1][c] = input[c * 4 + 1];
        state[2][c] = input[c * 4 + 2];
        state[3][c] = input[c * 4 + 3];
    }
    addRoundKey(state, w, 0);
    for (round = 1; round < roundLimit; round++) {
        subBytes(state);
        shiftRows(state);
        if (round + 1 < roundLimit) {
            mixColumns(state);
        }
        addRoundKey(state, w, round * 4);
    }
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
            output.push(state[j][i]);
        }
    }
    return output;
}
exports.AES = AES;
const checkBit = function (byteArray, byteIndex, bitIndex) {
    return (byteArray[byteIndex] & (0x01 << bitIndex)) !== 0 ? 1 : 0;
};
exports.checkBit = checkBit;
const getBytes = function (numericValue) {
    return [
        (numericValue & 0xFF000000) >>> 24,
        (numericValue & 0x00FF0000) >> 16,
        (numericValue & 0x0000FF00) >> 8,
        numericValue & 0x000000FF
    ];
};
exports.getBytes = getBytes;
const createZeroBlock = function (length) {
    return new Array(length).fill(0);
};
const R = [0xe1].concat(createZeroBlock(15));
const exclusiveOR = function (block0, block1) {
    const len = block0.length;
    const result = new Array(len);
    for (let i = 0; i < len; i++) {
        result[i] = block0[i] ^ block1[i];
    }
    return result;
};
exports.exclusiveOR = exclusiveOR;
const xorInto = function (target, block) {
    for (let i = 0; i < target.length; i++) {
        target[i] ^= block[i];
    }
};
const rightShift = function (block) {
    let i;
    let carry = 0;
    let oldCarry = 0;
    for (i = 0; i < block.length; i++) {
        oldCarry = carry;
        carry = block[i] & 0x01;
        block[i] = block[i] >> 1;
        if (oldCarry !== 0) {
            block[i] = block[i] | 0x80;
        }
    }
    return block;
};
exports.rightShift = rightShift;
const multiply = function (block0, block1) {
    const v = block1.slice();
    const z = createZeroBlock(16);
    for (let i = 0; i < 16; i++) {
        for (let j = 7; j >= 0; j--) {
            if ((block0[i] & (1 << j)) !== 0) {
                xorInto(z, v);
            }
            if ((v[15] & 1) !== 0) {
                (0, exports.rightShift)(v);
                xorInto(v, R);
            }
            else {
                (0, exports.rightShift)(v);
            }
        }
    }
    return z;
};
exports.multiply = multiply;
const incrementLeastSignificantThirtyTwoBits = function (block) {
    let i;
    const result = block.slice();
    for (i = 15; i !== 11; i--) {
        result[i] = result[i] + 1;
        if (result[i] === 256) {
            result[i] = 0;
        }
        else {
            break;
        }
    }
    return result;
};
exports.incrementLeastSignificantThirtyTwoBits = incrementLeastSignificantThirtyTwoBits;
function ghash(input, hashSubKey) {
    let result = createZeroBlock(16);
    for (let i = 0; i < input.length; i += 16) {
        const block = result.slice();
        for (let j = 0; j < 16; j++) {
            block[j] ^= input[i + j] ?? 0;
        }
        result = (0, exports.multiply)(block, hashSubKey);
    }
    return result;
}
exports.ghash = ghash;
function gctr(input, initialCounterBlock, key) {
    if (input.length === 0)
        return [];
    const output = new Array(input.length);
    let counterBlock = initialCounterBlock;
    let pos = 0;
    const n = Math.ceil(input.length / 16);
    for (let i = 0; i < n; i++) {
        const counter = AES(counterBlock, key);
        const chunk = Math.min(16, input.length - pos);
        for (let j = 0; j < chunk; j++) {
            output[pos] = input[pos] ^ counter[j];
            pos++;
        }
        if (i + 1 < n) {
            counterBlock = (0, exports.incrementLeastSignificantThirtyTwoBits)(counterBlock);
        }
    }
    return output;
}
function AESGCM(plainText, additionalAuthenticatedData, initializationVector, key) {
    let preCounterBlock;
    let plainTag;
    const hashSubKey = AES(createZeroBlock(16), key);
    preCounterBlock = [...initializationVector];
    if (initializationVector.length === 12) {
        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);
    }
    else {
        if (initializationVector.length % 16 !== 0) {
            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));
        }
        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));
        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4))
            .concat((0, exports.getBytes)(initializationVector.length * 8)), hashSubKey);
    }
    const cipherText = gctr(plainText, (0, exports.incrementLeastSignificantThirtyTwoBits)(preCounterBlock), key);
    plainTag = additionalAuthenticatedData.slice();
    if (additionalAuthenticatedData.length === 0) {
        plainTag = plainTag.concat(createZeroBlock(16));
    }
    else if (additionalAuthenticatedData.length % 16 !== 0) {
        plainTag = plainTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));
    }
    plainTag = plainTag.concat(cipherText);
    if (cipherText.length === 0) {
        plainTag = plainTag.concat(createZeroBlock(16));
    }
    else if (cipherText.length % 16 !== 0) {
        plainTag = plainTag.concat(createZeroBlock(16 - (cipherText.length % 16)));
    }
    plainTag = plainTag.concat(createZeroBlock(4))
        .concat((0, exports.getBytes)(additionalAuthenticatedData.length * 8))
        .concat(createZeroBlock(4)).concat((0, exports.getBytes)(cipherText.length * 8));
    return {
        result: cipherText,
        authenticationTag: gctr(ghash(plainTag, hashSubKey), preCounterBlock, key)
    };
}
exports.AESGCM = AESGCM;
function AESGCMDecrypt(cipherText, additionalAuthenticatedData, initializationVector, authenticationTag, key) {
    let preCounterBlock;
    let compareTag;
    // Generate the hash subkey
    const hashSubKey = AES(createZeroBlock(16), key);
    preCounterBlock = [...initializationVector];
    if (initializationVector.length === 12) {
        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);
    }
    else {
        if (initializationVector.length % 16 !== 0) {
            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));
        }
        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));
        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4)).concat((0, exports.getBytes)(initializationVector.length * 8)), hashSubKey);
    }
    // Decrypt to obtain the plain text
    const plainText = gctr(cipherText, (0, exports.incrementLeastSignificantThirtyTwoBits)(preCounterBlock), key);
    compareTag = additionalAuthenticatedData.slice();
    if (additionalAuthenticatedData.length === 0) {
        compareTag = compareTag.concat(createZeroBlock(16));
    }
    else if (additionalAuthenticatedData.length % 16 !== 0) {
        compareTag = compareTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));
    }
    compareTag = compareTag.concat(cipherText);
    if (cipherText.length === 0) {
        compareTag = compareTag.concat(createZeroBlock(16));
    }
    else if (cipherText.length % 16 !== 0) {
        compareTag = compareTag.concat(createZeroBlock(16 - (cipherText.length % 16)));
    }
    compareTag = compareTag.concat(createZeroBlock(4))
        .concat((0, exports.getBytes)(additionalAuthenticatedData.length * 8))
        .concat(createZeroBlock(4)).concat((0, exports.getBytes)(cipherText.length * 8));
    // Generate the authentication tag
    const calculatedTag = gctr(ghash(compareTag, hashSubKey), preCounterBlock, key);
    // If the calculated tag does not match the provided tag, return null - the decryption failed.
    if (calculatedTag.join() !== authenticationTag.join()) {
        return null;
    }
    return plainText;
}
exports.AESGCMDecrypt = AESGCMDecrypt;

},{}],41:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Curve_js_1 = __importDefault(require("./Curve.js"));
/**
 * Base class for Point (affine coordinates) and JacobianPoint classes,
 * defining their curve and type.
 */
class BasePoint {
    constructor(type) {
        this.curve = new Curve_js_1.default(); // Always initialized, so never null
        this.type = type;
        this.precomputed = null;
    }
}
exports.default = BasePoint;

},{"./Curve.js":43}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on
 * 256-bit cryptography, this BigNumber class enables operations on larger
 * numbers.
 *
 * @class BigNumber
 */
class BigNumber {
    /**
     * Negative flag. Indicates whether the big number is a negative number.
     * - If 0, the number is positive.
     * - If 1, the number is negative.
     *
     * @property negative
     */
    get negative() {
        return this._sign;
    }
    /**
     * Sets the negative flag. Only 0 (positive) or 1 (negative) are allowed.
     */
    set negative(val) {
        this.assert(val === 0 || val === 1, 'Negative property must be 0 or 1');
        const newSign = val === 1 ? 1 : 0;
        if (this._magnitude === 0n) {
            this._sign = 0;
        }
        else {
            this._sign = newSign;
        }
    }
    get _computedWordsArray() {
        if (this._magnitude === 0n)
            return [0];
        const arr = [];
        let temp = this._magnitude;
        while (temp > 0n) {
            arr.push(Number(temp & BigNumber.WORD_MASK));
            temp >>= BigNumber.WORD_SIZE_BIGINT;
        }
        return arr.length > 0 ? arr : [0];
    }
    /**
     * Array of numbers, where each number represents a part of the value of the big number.
     *
     * @property words
     */
    get words() {
        const computed = this._computedWordsArray;
        if (this._nominalWordLength <= computed.length) {
            return computed;
        }
        const paddedWords = new Array(this._nominalWordLength).fill(0);
        for (let i = 0; i < computed.length; i++) {
            paddedWords[i] = computed[i];
        }
        return paddedWords;
    }
    /**
     * Sets the words array representing the value of the big number.
     */
    set words(newWords) {
        const oldSign = this._sign;
        let newMagnitude = 0n;
        const len = newWords.length > 0 ? newWords.length : 1;
        for (let i = len - 1; i >= 0; i--) {
            const wordVal = newWords[i] === undefined ? 0 : newWords[i];
            newMagnitude = (newMagnitude << BigNumber.WORD_SIZE_BIGINT) | BigInt(wordVal & Number(BigNumber.WORD_MASK));
        }
        this._magnitude = newMagnitude;
        this._sign = oldSign;
        this._nominalWordLength = len;
        this.normSign();
    }
    /**
     * Length of the words array.
     *
     * @property length
     */
    get length() {
        return Math.max(1, this._nominalWordLength);
    }
    /**
     * Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.
     *
     * @method isBN
     * @param num - The value to be checked.
     * @returns - Returns a boolean value determining whether or not the checked num parameter is a BigNumber.
     */
    static isBN(num) {
        if (num instanceof BigNumber)
            return true;
        return (num !== null &&
            typeof num === 'object' &&
            num.constructor?.wordSize === BigNumber.wordSize &&
            Array.isArray(num.words));
    }
    /**
     * Returns the bigger value between two BigNumbers
     *
     * @method max
     * @param left - The first BigNumber to be compared.
     * @param right - The second BigNumber to be compared.
     * @returns - Returns the bigger BigNumber between left and right.
     */
    static max(left, right) { return left.cmp(right) > 0 ? left : right; }
    /**
     * Returns the smaller value between two BigNumbers
     *
     * @method min
     * @param left - The first BigNumber to be compared.
     * @param right - The second BigNumber to be compared.
     * @returns - Returns the smaller value between left and right.
     */
    static min(left, right) { return left.cmp(right) < 0 ? left : right; }
    /**
     * @constructor
     *
     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
     * @param base - The base of number provided. By default is 10.
     * @param endian - The endianness provided. By default is 'big endian'.
     */
    constructor(number = 0, base = 10, endian = 'be') {
        this._magnitude = 0n;
        this._sign = 0;
        this._nominalWordLength = 1;
        this.red = null;
        if (number === undefined)
            number = 0;
        if (number === null) {
            this._initializeState(0n, 0);
            return;
        }
        if (typeof number === 'bigint') {
            this._initializeState(number < 0n ? -number : number, number < 0n ? 1 : 0);
            this.normSign();
            return;
        }
        let effectiveBase = base;
        let effectiveEndian = endian;
        if (base === 'le' || base === 'be') {
            effectiveEndian = base;
            effectiveBase = 10;
        }
        if (typeof number === 'number') {
            this.initNumber(number, effectiveEndian);
            return;
        }
        if (Array.isArray(number)) {
            this.initArray(number, effectiveEndian);
            return;
        }
        if (typeof number === 'string') {
            if (effectiveBase === 'hex')
                effectiveBase = 16;
            this.assert(typeof effectiveBase === 'number' && effectiveBase === (effectiveBase | 0) && effectiveBase >= 2 && effectiveBase <= 36, 'Base must be an integer between 2 and 36');
            const originalNumberStr = number.toString().replace(/\s+/g, '');
            let start = 0;
            let sign = 0;
            if (originalNumberStr.startsWith('-')) {
                start++;
                sign = 1;
            }
            else if (originalNumberStr.startsWith('+')) {
                start++;
            }
            const numStr = originalNumberStr.substring(start);
            if (numStr.length === 0) {
                this._initializeState(0n, (sign === 1 && originalNumberStr.startsWith('-')) ? 1 : 0);
                this.normSign();
                return;
            }
            if (effectiveBase === 16) {
                let tempMagnitude;
                if (effectiveEndian === 'le') {
                    const bytes = [];
                    let hexStr = numStr;
                    if (hexStr.length % 2 !== 0)
                        hexStr = '0' + hexStr;
                    for (let i = 0; i < hexStr.length; i += 2) {
                        const byteHex = hexStr.substring(i, i + 2);
                        const byteVal = parseInt(byteHex, 16);
                        if (isNaN(byteVal))
                            throw new Error('Invalid character in ' + hexStr);
                        bytes.push(byteVal);
                    }
                    this.initArray(bytes, 'le');
                    this._sign = sign;
                    this.normSign();
                    return;
                }
                else {
                    try {
                        tempMagnitude = BigInt('0x' + numStr);
                    }
                    catch (e) {
                        throw new Error('Invalid character in ' + numStr);
                    }
                }
                this._initializeState(tempMagnitude, sign);
                this.normSign();
            }
            else {
                try {
                    this._parseBaseString(numStr, effectiveBase);
                    this._sign = sign;
                    this.normSign();
                    if (effectiveEndian === 'le') {
                        const currentSign = this._sign;
                        this.initArray(this.toArray('be'), 'le');
                        this._sign = currentSign;
                        this.normSign();
                    }
                }
                catch (err) {
                    const error = err;
                    if (error.message.includes('Invalid character in string') ||
                        error.message.includes('Invalid digit for base') ||
                        error.message.startsWith('Invalid character:')) {
                        throw new Error('Invalid character');
                    }
                    throw error;
                }
            }
        }
        else if (number !== 0) {
            this.assert(false, 'Unsupported input type for BigNumber constructor');
        }
        else {
            this._initializeState(0n, 0);
        }
    }
    _bigIntToStringInBase(num, base) {
        if (num === 0n)
            return '0';
        if (base < 2 || base > 36)
            throw new Error('Base must be between 2 and 36');
        const digits = '0123456789abcdefghijklmnopqrstuvwxyz';
        let result = '';
        let currentNum = num > 0n ? num : -num;
        const bigBase = BigInt(base);
        while (currentNum > 0n) {
            result = digits[Number(currentNum % bigBase)] + result;
            currentNum /= bigBase;
        }
        return result;
    }
    _parseBaseString(numberStr, base) {
        if (numberStr.length === 0) {
            this._magnitude = 0n;
            this._finishInitialization();
            return;
        }
        this._magnitude = 0n;
        const bigBase = BigInt(base);
        let groupSize = BigNumber.groupSizes[base];
        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);
        if (groupSize === 0 || groupBaseBigInt === 0n) {
            groupSize = Math.floor(Math.log(0x3ffffff) / Math.log(base));
            if (groupSize === 0)
                groupSize = 1;
            groupBaseBigInt = bigBase ** BigInt(groupSize);
        }
        let currentPos = 0;
        const totalLen = numberStr.length;
        let firstChunkLen = totalLen % groupSize;
        if (firstChunkLen === 0 && totalLen > 0)
            firstChunkLen = groupSize;
        if (firstChunkLen > 0) {
            const chunkStr = numberStr.substring(currentPos, currentPos + firstChunkLen);
            this._magnitude = BigInt(this._parseBaseWord(chunkStr, base));
            currentPos += firstChunkLen;
        }
        while (currentPos < totalLen) {
            const chunkStr = numberStr.substring(currentPos, currentPos + groupSize);
            const wordVal = BigInt(this._parseBaseWord(chunkStr, base));
            this._magnitude = this._magnitude * groupBaseBigInt + wordVal;
            currentPos += groupSize;
        }
        this._finishInitialization();
    }
    _parseBaseWord(str, base) {
        let r = 0;
        for (let i = 0; i < str.length; i++) {
            const charCode = str.charCodeAt(i);
            let digitVal;
            if (charCode >= 48 && charCode <= 57)
                digitVal = charCode - 48;
            else if (charCode >= 65 && charCode <= 90)
                digitVal = charCode - 65 + 10;
            else if (charCode >= 97 && charCode <= 122)
                digitVal = charCode - 97 + 10;
            else
                throw new Error('Invalid character: ' + str[i]);
            if (digitVal >= base)
                throw new Error('Invalid character');
            r = r * base + digitVal;
        }
        return r;
    }
    _initializeState(magnitude, sign) {
        this._magnitude = magnitude;
        this._sign = (magnitude === 0n) ? 0 : sign;
        this._finishInitialization();
    }
    _finishInitialization() {
        if (this._magnitude === 0n) {
            this._nominalWordLength = 1;
            this._sign = 0;
        }
        else {
            const bitLen = this._magnitude.toString(2).length;
            this._nominalWordLength = Math.max(1, Math.ceil(bitLen / BigNumber.wordSize));
        }
    }
    assert(val, msg = 'Assertion failed') { if (!val)
        throw new Error(msg); }
    initNumber(number, endian = 'be') {
        this.assert(BigInt(Math.abs(number)) <= BigNumber.MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT, 'The number is larger than 2 ^ 53 (unsafe)');
        this.assert(number % 1 === 0, 'Number must be an integer for BigNumber conversion');
        this._initializeState(BigInt(Math.abs(number)), number < 0 ? 1 : 0);
        if (endian === 'le') {
            const currentSign = this._sign;
            const beBytes = this.toArray('be');
            this.initArray(beBytes, 'le');
            this._sign = currentSign;
            this.normSign();
        }
        return this;
    }
    initArray(bytes, endian) {
        if (bytes.length === 0) {
            this._initializeState(0n, 0);
            return this;
        }
        let magnitude = 0n;
        if (endian === 'be') {
            for (let i = 0; i < bytes.length; i++)
                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);
        }
        else {
            for (let i = bytes.length - 1; i >= 0; i--)
                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);
        }
        this._initializeState(magnitude, 0);
        return this;
    }
    copy(dest) { dest._magnitude = this._magnitude; dest._sign = this._sign; dest._nominalWordLength = this._nominalWordLength; dest.red = this.red; }
    static move(dest, src) { dest._magnitude = src._magnitude; dest._sign = src._sign; dest._nominalWordLength = src._nominalWordLength; dest.red = src.red; }
    clone() { const r = new BigNumber(0n); this.copy(r); return r; }
    expand(size) {
        this.assert(size >= 0, 'Expand size must be non-negative');
        this._nominalWordLength = Math.max(this._nominalWordLength, size, 1);
        return this;
    }
    strip() { this._finishInitialization(); return this.normSign(); }
    normSign() { if (this._magnitude === 0n)
        this._sign = 0; return this; }
    inspect() { return (this.red !== null ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'; }
    _getMinimalHex() {
        if (this._magnitude === 0n)
            return '0';
        return this._magnitude.toString(16);
    }
    /**
     * Converts the BigNumber instance to a string representation.
     *
     * @method toString
     * @param base - The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.
     * @param padding - Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.
     * @returns The string representation of the BigNumber instance
     */
    toString(base = 10, padding = 1) {
        if (base === 16 || base === 'hex') {
            // For toString('hex', N), N is the 'multiple-of-N characters' rule from bn.js tests
            // For toString(16, P) where P=1 (default) or P=0, it means minimal hex.
            let hexStr = this._getMinimalHex(); // e.g., "f", "123", "0"
            if (padding > 1) { // N-multiple rule for characters
                // Ensure hexStr is even length if not "0" to represent full bytes before applying multiple rule
                if (hexStr !== '0' && hexStr.length % 2 !== 0) {
                    hexStr = '0' + hexStr;
                }
                while (hexStr.length % padding !== 0) {
                    hexStr = '0' + hexStr;
                }
            }
            // If padding is 0 or 1, hexStr (minimal) is used as is.
            // "0" is always "0" unless toHex("") specific case.
            // Single digit hex like "f" is not "0f" by default from toString(16).
            return (this.isNeg() ? '-' : '') + hexStr;
        }
        if (typeof base !== 'number' || base < 2 || base > 36 || base % 1 !== 0)
            throw new Error('Base should be an integer between 2 and 36');
        return this.toBaseString(base, padding);
    }
    toBaseString(base, padding) {
        if (this._magnitude === 0n) {
            let out = '0';
            if (padding > 1) {
                while (out.length < padding)
                    out = '0' + out;
            }
            return out;
        }
        let groupSize = BigNumber.groupSizes[base];
        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);
        if (groupSize === 0 || groupBaseBigInt === 0n) {
            groupSize = Math.floor(Math.log(Number.MAX_SAFE_INTEGER) / Math.log(base));
            if (groupSize === 0)
                groupSize = 1;
            groupBaseBigInt = BigInt(base) ** BigInt(groupSize);
        }
        let out = '';
        let tempMag = this._magnitude;
        while (tempMag > 0n) {
            const remainder = tempMag % groupBaseBigInt;
            tempMag /= groupBaseBigInt;
            const chunkStr = this._bigIntToStringInBase(remainder, base);
            if (tempMag > 0n) {
                const zerosToPrepend = groupSize - chunkStr.length;
                if (zerosToPrepend > 0 && zerosToPrepend < BigNumber.zeros.length) {
                    out = BigNumber.zeros[zerosToPrepend] + chunkStr + out;
                }
                else if (zerosToPrepend > 0) {
                    out = '0'.repeat(zerosToPrepend) + chunkStr + out;
                }
                else {
                    out = chunkStr + out;
                }
            }
            else {
                out = chunkStr + out;
            }
        }
        if (padding > 0) {
            while (out.length < padding)
                out = '0' + out;
        }
        return (this._sign === 1 ? '-' : '') + out;
    }
    /**
     * Converts the BigNumber instance to a JavaScript number.
     * Please note that JavaScript numbers are only precise up to 53 bits.
     *
     * @method toNumber
     * @throws If the BigNumber instance cannot be safely stored in a JavaScript number
     * @returns The JavaScript number representation of the BigNumber instance.
     */
    toNumber() {
        const val = this._getSignedValue();
        if (val > BigNumber.MAX_SAFE_INTEGER_BIGINT || val < BigNumber.MIN_SAFE_INTEGER_BIGINT)
            throw new Error('Number can only safely store up to 53 bits');
        return Number(val);
    }
    /**
     * Converts the BigNumber instance to a JSON-formatted string.
     *
     * @method toJSON
     * @returns The JSON string representation of the BigNumber instance.
     */
    toJSON() {
        const hex = this._getMinimalHex();
        return (this.isNeg() ? '-' : '') + hex;
    }
    toArrayLikeGeneric(res, isLE) {
        let tempMag = this._magnitude;
        let position = isLE ? 0 : res.length - 1;
        const increment = isLE ? 1 : -1;
        for (let k = 0; k < res.length; ++k) {
            if (tempMag === 0n && position >= 0 && position < res.length) {
                res[position] = 0;
            }
            else if (position >= 0 && position < res.length) {
                res[position] = Number(tempMag & 0xffn);
            }
            else {
                break;
            }
            tempMag >>= 8n;
            position += increment;
        }
    }
    /**
     * Converts the BigNumber instance to an array of bytes.
     *
     * @method toArray
     * @param endian - Endianness of the output array, defaults to 'be'.
     * @param length - Optional length of the output array.
     * @returns Array of bytes representing the BigNumber.
     */
    toArray(endian = 'be', length) {
        this.strip();
        const actualByteLength = this.byteLength();
        const reqLength = length ?? Math.max(1, actualByteLength);
        this.assert(actualByteLength <= reqLength, 'byte array longer than desired length');
        this.assert(reqLength > 0, 'Requested array length <= 0');
        const res = new Array(reqLength).fill(0);
        if (this._magnitude === 0n && reqLength > 0)
            return res;
        if (this._magnitude === 0n && reqLength === 0)
            return [];
        this.toArrayLikeGeneric(res, endian === 'le');
        return res;
    }
    /**
     * Calculates the number of bits required to represent the BigNumber.
     *
     * @method bitLength
     * @returns The bit length of the BigNumber.
     */
    bitLength() { if (this._magnitude === 0n)
        return 0; return this._magnitude.toString(2).length; }
    /**
     * Converts a BigNumber to an array of bits.
     *
     * @method toBitArray
     * @param num - The BigNumber to convert.
     * @returns An array of bits.
     */
    static toBitArray(num) {
        const len = num.bitLength();
        if (len === 0)
            return [];
        const w = new Array(len);
        const mag = num._magnitude;
        for (let bit = 0; bit < len; bit++) {
            w[bit] = ((mag >> BigInt(bit)) & 1n) !== 0n ? 1 : 0;
        }
        return w;
    }
    /**
     * Instance version of {@link toBitArray}.
     */
    toBitArray() { return BigNumber.toBitArray(this); }
    /**
     * Returns the number of trailing zero bits in the big number.
     *
     * @method zeroBits
     * @returns Returns the number of trailing zero bits
     * in the binary representation of the big number.
     *
     * @example
     * const bn = new BigNumber('8'); // binary: 1000
     * const zeroBits = bn.zeroBits(); // 3
     */
    zeroBits() {
        if (this._magnitude === 0n)
            return 0;
        let c = 0;
        let t = this._magnitude;
        while ((t & 1n) === 0n && t !== 0n) {
            c++;
            t >>= 1n;
        }
        return c;
    }
    /**
     * Calculates the number of bytes required to represent the BigNumber.
     *
     * @method byteLength
     * @returns The byte length of the BigNumber.
     */
    byteLength() { if (this._magnitude === 0n)
        return 0; return Math.ceil(this.bitLength() / 8); }
    _getSignedValue() { return this._sign === 1 ? -this._magnitude : this._magnitude; }
    _setValueFromSigned(sVal) {
        if (sVal < 0n) {
            this._magnitude = -sVal;
            this._sign = 1;
        }
        else {
            this._magnitude = sVal;
            this._sign = 0;
        }
        this._finishInitialization();
        this.normSign();
    }
    toTwos(width) {
        this.assert(width >= 0);
        const Bw = BigInt(width);
        let v = this._getSignedValue();
        if (this._sign === 1 && this._magnitude !== 0n)
            v = (1n << Bw) + v;
        const m = (1n << Bw) - 1n;
        v &= m;
        const r = new BigNumber(0n);
        r._initializeState(v, 0);
        return r;
    }
    fromTwos(width) {
        this.assert(width >= 0);
        const Bw = BigInt(width);
        const m = this._magnitude;
        if (width > 0 && ((m >> (Bw - 1n)) & 1n) !== 0n && this._sign === 0) {
            const sVal = m - (1n << Bw);
            const r = new BigNumber(0n);
            r._setValueFromSigned(sVal);
            return r;
        }
        return this.clone();
    }
    isNeg() { return this._sign === 1 && this._magnitude !== 0n; }
    neg() { return this.clone().ineg(); }
    ineg() { if (this._magnitude !== 0n)
        this._sign = this._sign === 1 ? 0 : 1; return this; }
    _iuop(num, op) {
        const newMag = op(this._magnitude, num._magnitude);
        const isXor = op === ((a, b) => a ^ b);
        let targetNominalLength = this._nominalWordLength;
        if (isXor)
            targetNominalLength = Math.max(this.length, num.length);
        this._magnitude = newMag;
        this._finishInitialization();
        if (isXor)
            this._nominalWordLength = Math.max(this._nominalWordLength, targetNominalLength);
        return this.strip();
    }
    iuor(num) { return this._iuop(num, (a, b) => a | b); }
    iuand(num) { return this._iuop(num, (a, b) => a & b); }
    iuxor(num) { return this._iuop(num, (a, b) => a ^ b); }
    _iop(num, op) { this.assert(this._sign === 0 && num._sign === 0); return this._iuop(num, op); }
    ior(num) { return this._iop(num, (a, b) => a | b); }
    iand(num) { return this._iop(num, (a, b) => a & b); }
    ixor(num) { return this._iop(num, (a, b) => a ^ b); }
    _uop_new(num, opName) { if (this.length >= num.length)
        return this.clone()[opName](num); return num.clone()[opName](this); }
    or(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuor'); }
    uor(num) { return this._uop_new(num, 'iuor'); }
    and(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuand'); }
    uand(num) { return this._uop_new(num, 'iuand'); }
    xor(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuxor'); }
    uxor(num) { return this._uop_new(num, 'iuxor'); }
    inotn(width) {
        this.assert(typeof width === 'number' && width >= 0);
        const Bw = BigInt(width);
        const m = (1n << Bw) - 1n;
        this._magnitude = (~this._magnitude) & m;
        const wfw = width === 0 ? 1 : Math.ceil(width / BigNumber.wordSize);
        this._nominalWordLength = Math.max(1, wfw);
        this.strip();
        this._nominalWordLength = Math.max(this._nominalWordLength, Math.max(1, wfw));
        return this;
    }
    notn(width) { return this.clone().inotn(width); }
    setn(bit, val) { this.assert(typeof bit === 'number' && bit >= 0); const Bb = BigInt(bit); if (val === 1 || val === true)
        this._magnitude |= (1n << Bb);
    else
        this._magnitude &= ~(1n << Bb); const wnb = Math.floor(bit / BigNumber.wordSize) + 1; this._nominalWordLength = Math.max(this._nominalWordLength, wnb); this._finishInitialization(); return this.strip(); }
    iadd(num) { this._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return this; }
    add(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return r; }
    isub(num) { this._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return this; }
    sub(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return r; }
    mul(num) {
        const r = new BigNumber(0n);
        r._magnitude = this._magnitude * num._magnitude;
        r._sign = r._magnitude === 0n ? 0 : (this._sign ^ num._sign);
        r._nominalWordLength = this.length + num.length;
        r.red = null;
        return r.normSign();
    }
    imul(num) {
        this._magnitude *= num._magnitude;
        this._sign = this._magnitude === 0n ? 0 : (this._sign ^ num._sign);
        this._nominalWordLength = this.length + num.length;
        this.red = null;
        return this.normSign();
    }
    imuln(num) { this.assert(typeof num === 'number', 'Assertion failed'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() * BigInt(num)); return this; }
    muln(num) { return this.clone().imuln(num); }
    sqr() {
        const r = new BigNumber(0n);
        r._magnitude = this._magnitude * this._magnitude;
        r._sign = 0;
        r._nominalWordLength = this.length * 2;
        r.red = null;
        return r;
    }
    isqr() {
        this._magnitude *= this._magnitude;
        this._sign = 0;
        this._nominalWordLength = this.length * 2;
        this.red = null;
        return this;
    }
    pow(num) {
        this.assert(num._sign === 0, 'Exponent for pow must be non-negative');
        if (num.isZero())
            return new BigNumber(1n);
        const res = new BigNumber(1n);
        const currentBase = this.clone();
        const exp = num.clone();
        const baseIsNegative = currentBase.isNeg();
        const expIsOdd = exp.isOdd();
        if (baseIsNegative)
            currentBase.ineg();
        while (!exp.isZero()) {
            if (exp.isOdd()) {
                res.imul(currentBase);
            }
            currentBase.isqr();
            exp.iushrn(1);
        }
        if (baseIsNegative && expIsOdd) {
            res.ineg();
        }
        return res;
    }
    iushln(bits) { this.assert(typeof bits === 'number' && bits >= 0); if (bits === 0)
        return this; this._magnitude <<= BigInt(bits); this._finishInitialization(); return this.strip(); }
    ishln(bits) { this.assert(this._sign === 0, 'ishln requires positive number'); return this.iushln(bits); }
    iushrn(bits, hint, extended) {
        this.assert(typeof bits === 'number' && bits >= 0);
        if (bits === 0) {
            if (extended != null)
                extended._initializeState(0n, 0);
            return this;
        }
        if (extended != null) {
            const m = (1n << BigInt(bits)) - 1n;
            const sOut = this._magnitude & m;
            extended._initializeState(sOut, 0);
        }
        this._magnitude >>= BigInt(bits);
        this._finishInitialization();
        return this.strip();
    }
    ishrn(bits, hint, extended) {
        this.assert(this._sign === 0, 'ishrn requires positive number');
        return this.iushrn(bits, hint, extended);
    }
    shln(bits) { return this.clone().ishln(bits); }
    ushln(bits) { return this.clone().iushln(bits); }
    shrn(bits) { return this.clone().ishrn(bits); }
    ushrn(bits) { return this.clone().iushrn(bits); }
    testn(bit) {
        this.assert(typeof bit === 'number' && bit >= 0);
        return ((this._magnitude >> BigInt(bit)) & 1n) !== 0n;
    }
    imaskn(bits) {
        this.assert(typeof bits === 'number' && bits >= 0);
        this.assert(this._sign === 0, 'imaskn works only with positive numbers');
        const Bb = BigInt(bits);
        const m = Bb === 0n ? 0n : (1n << Bb) - 1n;
        this._magnitude &= m;
        const wfm = bits === 0 ? 1 : Math.max(1, Math.ceil(bits / BigNumber.wordSize));
        this._nominalWordLength = wfm;
        this._finishInitialization();
        this._nominalWordLength = Math.max(this._nominalWordLength, wfm);
        return this.strip();
    }
    maskn(bits) { return this.clone().imaskn(bits); }
    iaddn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large'); this._setValueFromSigned(this._getSignedValue() + BigInt(num)); return this; }
    _iaddn(num) { return this.iaddn(num); }
    isubn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() - BigInt(num)); return this; }
    addn(num) { return this.clone().iaddn(num); }
    subn(num) { return this.clone().isubn(num); }
    iabs() { this._sign = 0; return this; }
    abs() { return this.clone().iabs(); }
    divmod(num, mode, positive) {
        this.assert(!num.isZero(), 'Division by zero');
        if (this.isZero()) {
            const z = new BigNumber(0n);
            return { div: mode !== 'mod' ? z : null, mod: mode !== 'div' ? z : null };
        }
        const tV = this._getSignedValue();
        const nV = num._getSignedValue();
        let dV = null;
        let mV = null;
        if (mode !== 'mod')
            dV = tV / nV;
        if (mode !== 'div') {
            mV = tV % nV;
            if (positive === true && mV < 0n)
                mV += nV < 0n ? -nV : nV;
        }
        const rd = dV !== null ? new BigNumber(0n) : null;
        if (rd !== null && dV !== null)
            rd._setValueFromSigned(dV);
        const rm = mV !== null ? new BigNumber(0n) : null;
        if (rm !== null && mV !== null)
            rm._setValueFromSigned(mV);
        return { div: rd, mod: rm };
    }
    div(num) {
        return this.divmod(num, 'div', false).div;
    }
    mod(num) {
        return this.divmod(num, 'mod', false).mod;
    }
    umod(num) {
        return this.divmod(num, 'mod', true).mod;
    }
    divRound(num) {
        this.assert(!num.isZero());
        const tV = this._getSignedValue();
        const nV = num._getSignedValue();
        let d = tV / nV;
        const m = tV % nV;
        if (m === 0n) {
            const r = new BigNumber(0n);
            r._setValueFromSigned(d);
            return r;
        }
        const absM = m < 0n ? -m : m;
        const absNV = nV < 0n ? -nV : nV;
        if (absM * 2n >= absNV) {
            if ((tV > 0n && nV > 0n) || (tV < 0n && nV < 0n)) {
                d += 1n;
            }
            else {
                d -= 1n;
            }
        }
        const r = new BigNumber(0n);
        r._setValueFromSigned(d);
        return r;
    }
    modrn(numArg) {
        this.assert(numArg !== 0, 'Division by zero in modrn');
        const absDivisor = BigInt(Math.abs(numArg));
        if (absDivisor === 0n)
            throw new Error('Division by zero in modrn');
        const remainderMag = this._magnitude % absDivisor;
        return numArg < 0 ? Number(-remainderMag) : Number(remainderMag);
    }
    idivn(num) {
        this.assert(num !== 0);
        this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large');
        this._setValueFromSigned(this._getSignedValue() / BigInt(num));
        return this;
    }
    divn(num) { return this.clone().idivn(num); }
    egcd(p) {
        this.assert(p._sign === 0, 'p must not be negative');
        this.assert(!p.isZero(), 'p must not be zero');
        let uV = this._getSignedValue();
        let vV = p._magnitude;
        let a = 1n;
        let pa = 0n;
        let b = 0n;
        let pb = 1n;
        while (vV !== 0n) {
            const q = uV / vV;
            let t = vV;
            vV = uV % vV;
            uV = t;
            t = pa;
            pa = a - q * pa;
            a = t;
            t = pb;
            pb = b - q * pb;
            b = t;
        }
        const ra = new BigNumber(0n);
        ra._setValueFromSigned(a);
        const rb = new BigNumber(0n);
        rb._setValueFromSigned(b);
        const rg = new BigNumber(0n);
        rg._initializeState(uV < 0n ? -uV : uV, 0);
        return { a: ra, b: rb, gcd: rg };
    }
    gcd(num) {
        let u = this._magnitude;
        let v = num._magnitude;
        if (u === 0n) {
            const r = new BigNumber(0n);
            r._setValueFromSigned(v);
            return r.iabs();
        }
        if (v === 0n) {
            const r = new BigNumber(0n);
            r._setValueFromSigned(u);
            return r.iabs();
        }
        while (v !== 0n) {
            const t = u % v;
            u = v;
            v = t;
        }
        const res = new BigNumber(0n);
        res._initializeState(u, 0);
        return res;
    }
    invm(num) {
        this.assert(!num.isZero() && num._sign === 0, 'Modulus for invm must be positive and non-zero');
        const eg = this.egcd(num);
        if (!eg.gcd.eqn(1)) {
            throw new Error('Inverse does not exist (numbers are not coprime).');
        }
        return eg.a.umod(num);
    }
    isEven() { return this._magnitude % 2n === 0n; }
    isOdd() { return this._magnitude % 2n === 1n; }
    andln(num) { this.assert(num >= 0); return Number(this._magnitude & BigInt(num)); }
    bincn(bit) { this.assert(typeof bit === 'number' && bit >= 0); const BVal = 1n << BigInt(bit); this._setValueFromSigned(this._getSignedValue() + BVal); return this; }
    isZero() { return this._magnitude === 0n; }
    cmpn(num) { this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Number is too big'); const tV = this._getSignedValue(); const nV = BigInt(num); if (tV < nV)
        return -1; if (tV > nV)
        return 1; return 0; }
    cmp(num) { const tV = this._getSignedValue(); const nV = num._getSignedValue(); if (tV < nV)
        return -1; if (tV > nV)
        return 1; return 0; }
    ucmp(num) { if (this._magnitude < num._magnitude)
        return -1; if (this._magnitude > num._magnitude)
        return 1; return 0; }
    gtn(num) { return this.cmpn(num) === 1; }
    gt(num) { return this.cmp(num) === 1; }
    gten(num) { return this.cmpn(num) >= 0; }
    gte(num) { return this.cmp(num) >= 0; }
    ltn(num) { return this.cmpn(num) === -1; }
    lt(num) { return this.cmp(num) === -1; }
    lten(num) { return this.cmpn(num) <= 0; }
    lte(num) { return this.cmp(num) <= 0; }
    eqn(num) { return this.cmpn(num) === 0; }
    eq(num) { return this.cmp(num) === 0; }
    toRed(ctx) { this.assert(this.red == null, 'Already a number in reduction context'); this.assert(this._sign === 0, 'toRed works only with positives'); return ctx.convertTo(this).forceRed(ctx); }
    fromRed() { this.assert(this.red, 'fromRed works only with numbers in reduction context'); return this.red.convertFrom(this); }
    forceRed(ctx) { this.red = ctx; return this; }
    redAdd(num) { this.assert(this.red, 'redAdd works only with red numbers'); return this.red.add(this, num); }
    redIAdd(num) { this.assert(this.red, 'redIAdd works only with red numbers'); return this.red.iadd(this, num); }
    redSub(num) { this.assert(this.red, 'redSub works only with red numbers'); return this.red.sub(this, num); }
    redISub(num) { this.assert(this.red, 'redISub works only with red numbers'); return this.red.isub(this, num); }
    redShl(num) { this.assert(this.red, 'redShl works only with red numbers'); return this.red.shl(this, num); }
    redMul(num) { this.assert(this.red, 'redMul works only with red numbers'); this.red.verify2(this, num); return this.red.mul(this, num); }
    redIMul(num) { this.assert(this.red, 'redIMul works only with red numbers'); this.red.verify2(this, num); return this.red.imul(this, num); }
    redSqr() { this.assert(this.red, 'redSqr works only with red numbers'); this.red.verify1(this); return this.red.sqr(this); }
    redISqr() { this.assert(this.red, 'redISqr works only with red numbers'); this.red.verify1(this); return this.red.isqr(this); }
    redSqrt() { this.assert(this.red, 'redSqrt works only with red numbers'); this.red.verify1(this); return this.red.sqrt(this); }
    redInvm() { this.assert(this.red, 'redInvm works only with red numbers'); this.red.verify1(this); return this.red.invm(this); }
    redNeg() { this.assert(this.red, 'redNeg works only with red numbers'); this.red.verify1(this); return this.red.neg(this); }
    redPow(num) { this.assert(this.red != null && num.red == null, 'redPow(normalNum)'); this.red.verify1(this); return this.red.pow(this, num); }
    /**
     * Creates a BigNumber from a hexadecimal string.
     *
     * @static
     * @method fromHex
     * @param hex - The hexadecimal string to create a BigNumber from.
     * @param endian - Optional endianness for parsing the hex string.
     * @returns Returns a BigNumber created from the hexadecimal input string.
     *
     * @example
     * const exampleHex = 'a1b2c3';
     * const bigNumber = BigNumber.fromHex(exampleHex);
     */
    static fromHex(hex, endian) {
        let eE = 'be';
        if (endian === 'little' || endian === 'le')
            eE = 'le';
        return new BigNumber(hex, 16, eE);
    }
    /**
     * Converts this BigNumber to a hexadecimal string.
     *
     * @method toHex
     * @param length - The minimum length of the hex string
     * @returns Returns a string representing the hexadecimal value of this BigNumber.
     *
     * @example
     * const bigNumber = new BigNumber(255)
     * const hex = bigNumber.toHex()
     */
    toHex(byteLength = 0) {
        if (this.isZero() && byteLength === 0)
            return '';
        let hexStr = this._getMinimalHex(); // Raw hex: "0", "f", "10", "123"
        // Ensure even length for non-zero values (byte alignment)
        if (hexStr !== '0' && hexStr.length % 2 !== 0) {
            hexStr = '0' + hexStr;
        }
        // Pad to minimum character length (byteLength * 2)
        const minChars = byteLength * 2;
        while (hexStr.length < minChars) {
            hexStr = '0' + hexStr;
        }
        return (this.isNeg() ? '-' : '') + hexStr;
    }
    /**
     * Creates a BigNumber from a JSON-serialized string.
     *
     * @static
     * @method fromJSON
     * @param str - The JSON-serialized string to create a BigNumber from.
     * @returns Returns a BigNumber created from the JSON input string.
     */
    static fromJSON(str) { return new BigNumber(str, 16); }
    /**
     * Creates a BigNumber from a number.
     *
     * @static
     * @method fromNumber
     * @param n - The number to create a BigNumber from.
     * @returns Returns a BigNumber equivalent to the input number.
     */
    static fromNumber(n) { return new BigNumber(n); }
    /**
     * Creates a BigNumber from a string, considering an optional base.
     *
     * @static
     * @method fromString
     * @param str - The string to create a BigNumber from.
     * @param base - The base used for conversion. If not provided, base 10 is assumed.
     * @returns Returns a BigNumber equivalent to the string after conversion from the specified base.
     */
    static fromString(str, base) { return new BigNumber(str, base); }
    /**
     * Creates a BigNumber from a signed magnitude number.
     *
     * @static
     * @method fromSm
     * @param bytes - The signed magnitude number to convert to a BigNumber.
     * @param endian - Defines endianess. If not provided, big endian is assumed.
     * @returns Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.
     */
    static fromSm(bytes, endian = 'big') {
        if (bytes.length === 0)
            return new BigNumber(0n);
        let sign = 0;
        let hex = '';
        if (endian === 'little') {
            const last = bytes.length - 1;
            let firstByte = bytes[last];
            if ((firstByte & 0x80) !== 0) {
                sign = 1;
                firstByte &= 0x7f;
            }
            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);
            for (let i = last - 1; i >= 0; i--) {
                const b = bytes[i];
                hex += (b < 16 ? '0' : '') + b.toString(16);
            }
        }
        else {
            let firstByte = bytes[0];
            if ((firstByte & 0x80) !== 0) {
                sign = 1;
                firstByte &= 0x7f;
            }
            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);
            for (let i = 1; i < bytes.length; i++) {
                const b = bytes[i];
                hex += (b < 16 ? '0' : '') + b.toString(16);
            }
        }
        const mag = hex === '' ? 0n : BigInt('0x' + hex);
        const r = new BigNumber(0n);
        r._initializeState(mag, sign);
        return r;
    }
    /**
     * Converts this BigNumber to a signed magnitude number.
     *
     * @method toSm
     * @param endian - Defines endianess. If not provided, big endian is assumed.
     * @returns Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.
     */
    toSm(endian = 'big') {
        if (this._magnitude === 0n) {
            return this._sign === 1 ? [0x80] : [];
        }
        let hex = this._getMinimalHex();
        if (hex.length % 2 !== 0)
            hex = '0' + hex;
        const byteLen = hex.length / 2;
        const bytes = new Array(byteLen);
        for (let i = 0, j = 0; i < hex.length; i += 2) {
            bytes[j++] = parseInt(hex.slice(i, i + 2), 16);
        }
        if (this._sign === 1) {
            if ((bytes[0] & 0x80) !== 0)
                bytes.unshift(0x80);
            else
                bytes[0] |= 0x80;
        }
        else if ((bytes[0] & 0x80) !== 0) {
            bytes.unshift(0x00);
        }
        return endian === 'little' ? bytes.reverse() : bytes;
    }
    /**
     * Creates a BigNumber from a number representing the "bits" value in a block header.
     *
     * @static
     * @method fromBits
     * @param bits - The number representing the bits value in a block header.
     * @param strict - If true, an error is thrown if the number has negative bit set.
     * @returns Returns a BigNumber equivalent to the "bits" value in a block header.
     * @throws Will throw an error if `strict` is `true` and the number has negative bit set.
     */
    static fromBits(bits, strict = false) {
        const nSize = bits >>> 24;
        const nWordCompact = bits & 0x007fffff;
        const isNegativeFromBit = (bits & 0x00800000) !== 0;
        if (strict && isNegativeFromBit) {
            throw new Error('negative bit set');
        }
        if (nSize === 0 && nWordCompact === 0) {
            if (isNegativeFromBit && strict)
                throw new Error('negative bit set for zero value');
            return new BigNumber(0n);
        }
        const bn = new BigNumber(nWordCompact);
        // This logic comes from original bn.js `fromCompact`
        if (nSize <= 3) {
            bn.iushrn((3 - nSize) * 8);
        }
        else {
            bn.iushln((nSize - 3) * 8);
        }
        if (isNegativeFromBit) {
            bn.ineg();
        }
        return bn;
    }
    /**
     * Converts this BigNumber to a number representing the "bits" value in a block header.
     *
     * @method toBits
     * @returns Returns a number equivalent to the "bits" value in a block header.
     */
    toBits() {
        this.strip();
        if (this.isZero() && !this.isNeg())
            return 0;
        const isActualNegative = this.isNeg();
        const bnAbs = this.abs(); // Work with absolute value for magnitude
        // Get byte array of absolute value
        let mB = bnAbs.toArray('be'); // Minimal byte array
        // Remove leading zeros from byte array, if any (toArray('be') might already do this if no length specified)
        let firstNonZeroIdx = 0;
        while (firstNonZeroIdx < mB.length - 1 && mB[firstNonZeroIdx] === 0) { // Keep last byte if it's [0]
            firstNonZeroIdx++;
        }
        mB = mB.slice(firstNonZeroIdx);
        let nSize = mB.length;
        if (nSize === 0 && !bnAbs.isZero()) { // Should not happen if bnAbs is truly non-zero and toArray is correct
            mB = [0]; // Should not be needed if toArray works for small numbers
            nSize = 1;
        }
        if (bnAbs.isZero()) { // if original was, e.g., -0, bnAbs is 0.
            nSize = 0; // Size for 0 is 0, unless it's negative 0 to be encoded
            mB = [];
        }
        let nWordNum;
        if (nSize === 0) {
            nWordNum = 0;
        }
        else if (nSize <= 3) {
            nWordNum = 0;
            for (let i = 0; i < nSize; i++) {
                nWordNum = (nWordNum << 8) | mB[i];
            }
        }
        else { // nSize > 3
            nWordNum = (mB[0] << 16) | (mB[1] << 8) | mB[2];
        }
        if ((nWordNum & 0x00800000) !== 0 && nSize <= 0xff) { // MSB of 3-byte mantissa is set
            nWordNum >>>= 8; // Shift mantissa over by one byte
            nSize++; // Increase size component by one
        }
        let b = (nSize << 24) | nWordNum;
        if (isActualNegative)
            b |= 0x00800000;
        return b >>> 0;
    }
    /**
     * Creates a BigNumber from the format used in Bitcoin scripts.
     *
     * @static
     * @method fromScriptNum
     * @param num - The number in the format used in Bitcoin scripts.
     * @param requireMinimal - If true, non-minimally encoded values will throw an error.
     * @param maxNumSize - The maximum allowed size for the number.
     * @returns Returns a BigNumber equivalent to the number used in a Bitcoin script.
     */
    static fromScriptNum(num, requireMinimal = false, maxNumSize) {
        if (maxNumSize !== undefined && num.length > maxNumSize)
            throw new Error('script number overflow');
        if (num.length === 0)
            return new BigNumber(0n);
        if (requireMinimal) {
            if ((num[num.length - 1] & 0x7f) === 0) {
                if (num.length <= 1 || (num[num.length - 2] & 0x80) === 0) {
                    throw new Error('non-minimally encoded script number');
                }
            }
        }
        return BigNumber.fromSm(num, 'little');
    }
    /**
     * Converts this BigNumber to a number in the format used in Bitcoin scripts.
     *
     * @method toScriptNum
     * @returns Returns the equivalent to this BigNumber as a Bitcoin script number.
     */
    toScriptNum() { return this.toSm('little'); }
    /**
     * Compute the multiplicative inverse of the current BigNumber in the modulus field specified by `p`.
     * The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.
     *
     * @method _invmp
     * @param p - The `BigNumber` specifying the modulus field.
     * @returns The multiplicative inverse `BigNumber` in the modulus field specified by `p`.
     */
    _invmp(p) {
        this.assert(p._sign === 0, 'p must not be negative for _invmp');
        this.assert(!p.isZero(), 'p must not be zero for _invmp');
        const aBN = this.umod(p);
        let aVal = aBN._magnitude;
        let bVal = p._magnitude;
        let x1Val = 1n;
        let x2Val = 0n;
        const modulus = p._magnitude;
        while (aVal > 1n && bVal > 1n) {
            let i = 0;
            while (((aVal >> BigInt(i)) & 1n) === 0n)
                i++;
            if (i > 0) {
                aVal >>= BigInt(i);
                for (let k = 0; k < i; ++k) {
                    if ((x1Val & 1n) !== 0n)
                        x1Val += modulus;
                    x1Val >>= 1n;
                }
            }
            let j = 0;
            while (((bVal >> BigInt(j)) & 1n) === 0n)
                j++;
            if (j > 0) {
                bVal >>= BigInt(j);
                for (let k = 0; k < j; ++k) {
                    if ((x2Val & 1n) !== 0n)
                        x2Val += modulus;
                    x2Val >>= 1n;
                }
            }
            if (aVal >= bVal) {
                aVal -= bVal;
                x1Val -= x2Val;
            }
            else {
                bVal -= aVal;
                x2Val -= x1Val;
            }
        }
        let resultVal;
        if (aVal === 1n)
            resultVal = x1Val;
        else if (bVal === 1n)
            resultVal = x2Val;
        else if (aVal === 0n && bVal === 1n)
            resultVal = x2Val;
        else if (bVal === 0n && aVal === 1n)
            resultVal = x1Val;
        else
            throw new Error('_invmp: GCD is not 1, inverse does not exist. aVal=' + aVal + ', bVal=' + bVal);
        resultVal %= modulus;
        if (resultVal < 0n)
            resultVal += modulus;
        const resultBN = new BigNumber(0n);
        resultBN._initializeState(resultVal, 0);
        return resultBN;
    }
    /**
     * Performs multiplication between the BigNumber instance and a given BigNumber.
     * It chooses the multiplication method based on the lengths of the numbers to optimize execution time.
     *
     * @method mulTo
     * @param num - The BigNumber multiply with.
     * @param out - The BigNumber where to store the result.
     * @returns The BigNumber resulting from the multiplication operation.
     */
    mulTo(num, out) {
        out._magnitude = this._magnitude * num._magnitude;
        out._sign = out._magnitude === 0n ? 0 : (this._sign ^ num._sign);
        out._nominalWordLength = this.length + num.length;
        out.red = null;
        out.normSign();
        return out;
    }
}
/**
 * @privateinitializer
 */
BigNumber.zeros = [
    '', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000',
    '000000000', '0000000000', '00000000000', '000000000000', '0000000000000',
    '00000000000000', '000000000000000', '0000000000000000', '00000000000000000',
    '000000000000000000', '0000000000000000000', '00000000000000000000',
    '000000000000000000000', '0000000000000000000000', '00000000000000000000000',
    '000000000000000000000000', '0000000000000000000000000'
];
/**
 * @privateinitializer
 */
BigNumber.groupSizes = [
    0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
];
/**
 * @privateinitializer
 */
BigNumber.groupBases = [
    0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343,
    7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000,
    28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];
/**
 * The word size of big number chunks.
 *
 * @property wordSize
 *
 * @example
 * console.log(BigNumber.wordSize);  // output: 26
 */
BigNumber.wordSize = 26;
BigNumber.WORD_SIZE_BIGINT = BigInt(BigNumber.wordSize);
BigNumber.WORD_MASK = (1n << BigNumber.WORD_SIZE_BIGINT) - 1n;
BigNumber.MAX_SAFE_INTEGER_BIGINT = BigInt(Number.MAX_SAFE_INTEGER);
BigNumber.MIN_SAFE_INTEGER_BIGINT = BigInt(Number.MIN_SAFE_INTEGER);
BigNumber.MAX_IMULN_ARG = 0x4000000 - 1;
BigNumber.MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT = (1n << 53n) - 1n;
exports.default = BigNumber;

},{}],43:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const ReductionContext_js_1 = __importDefault(require("./ReductionContext.js"));
const MontgomoryMethod_js_1 = __importDefault(require("./MontgomoryMethod.js"));
const Point_js_1 = __importDefault(require("./Point.js"));
const utils_js_1 = require("./utils.js");
// This ensures that only one curve is ever created, enhancing performance.
// This assumes there is never a need to have multiple distinct Curve instances.
// So far, this assumption has proven to be valid.
let globalCurve;
class Curve {
    // Represent num in a w-NAF form
    static assert(expression, message = 'Elliptic curve assertion failed') {
        if (!expression) {
            throw new Error(message);
        }
    }
    getNAF(num, w, bits) {
        const naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        const ws = 1 << (w + 1);
        const k = num.clone();
        for (let i = 0; i < naf.length; i++) {
            let z;
            const mod = k.andln(ws - 1);
            if (k.isOdd()) {
                if (mod > (ws >> 1) - 1) {
                    z = (ws >> 1) - mod;
                }
                else {
                    z = mod;
                }
                k.isubn(z);
            }
            else {
                z = 0;
            }
            naf[i] = z;
            k.iushrn(1);
        }
        return naf;
    }
    // Represent k1, k2 in a Joint Sparse Form
    getJSF(k1, k2) {
        const jsf = [[], []];
        k1 = k1.clone();
        k2 = k2.clone();
        let d1 = 0;
        let d2 = 0;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
            // First phase
            let m14 = (k1.andln(3) + d1) & 3;
            let m24 = (k2.andln(3) + d2) & 3;
            if (m14 === 3) {
                m14 = -1;
            }
            if (m24 === 3) {
                m24 = -1;
            }
            let u1;
            if ((m14 & 1) === 0) {
                u1 = 0;
            }
            else {
                const m8 = (k1.andln(7) + d1) & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) {
                    u1 = -m14;
                }
                else {
                    u1 = m14;
                }
            }
            jsf[0].push(u1);
            let u2;
            if ((m24 & 1) === 0) {
                u2 = 0;
            }
            else {
                const m8 = (k2.andln(7) + d2) & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) {
                    u2 = -m24;
                }
                else {
                    u2 = m24;
                }
            }
            jsf[1].push(u2);
            // Second phase
            if (2 * d1 === u1 + 1) {
                d1 = 1 - d1;
            }
            if (2 * d2 === u2 + 1) {
                d2 = 1 - d2;
            }
            k1.iushrn(1);
            k2.iushrn(1);
        }
        return jsf;
    }
    static cachedProperty(obj, name, computer) {
        const key = '_' + name;
        obj.prototype[name] = function cachedProperty() {
            const r = this[key] !== undefined ? this[key] : (this[key] = computer.call(this));
            return r;
        };
    }
    static parseBytes(bytes) {
        return typeof bytes === 'string' ? (0, utils_js_1.toArray)(bytes, 'hex') : bytes;
    }
    static intFromLE(bytes) {
        return new BigNumber_js_1.default(bytes, 'hex', 'le');
    }
    constructor() {
        if (typeof globalCurve !== 'undefined') {
            return globalCurve;
        }
        else {
            /* eslint-disable @typescript-eslint/no-this-alias */
            globalCurve = this;
        }
        const precomputed = {
            doubles: {
                step: 4,
                points: [
                    [
                        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                    ],
                    [
                        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                    ],
                    [
                        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                    ],
                    [
                        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                    ],
                    [
                        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                    ],
                    [
                        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                    ],
                    [
                        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                    ],
                    [
                        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                    ],
                    [
                        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                    ],
                    [
                        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                    ],
                    [
                        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                    ],
                    [
                        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                    ],
                    [
                        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                    ],
                    [
                        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                    ],
                    [
                        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                    ],
                    [
                        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                    ],
                    [
                        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                    ],
                    [
                        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                    ],
                    [
                        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                    ],
                    [
                        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                    ],
                    [
                        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                    ],
                    [
                        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                    ],
                    [
                        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                    ],
                    [
                        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                    ],
                    [
                        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                    ],
                    [
                        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                    ],
                    [
                        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                    ],
                    [
                        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                    ],
                    [
                        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                    ],
                    [
                        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                    ],
                    [
                        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                    ],
                    [
                        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                    ],
                    [
                        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                    ],
                    [
                        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                    ],
                    [
                        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                    ],
                    [
                        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                    ],
                    [
                        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                    ],
                    [
                        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                    ],
                    [
                        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                    ],
                    [
                        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                    ],
                    [
                        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                    ],
                    [
                        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                    ],
                    [
                        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                    ],
                    [
                        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                    ],
                    [
                        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                    ],
                    [
                        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                    ],
                    [
                        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                    ],
                    [
                        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                    ],
                    [
                        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                    ],
                    [
                        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                    ],
                    [
                        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                    ],
                    [
                        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                    ],
                    [
                        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                    ],
                    [
                        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                    ],
                    [
                        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                    ],
                    [
                        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                    ],
                    [
                        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                    ],
                    [
                        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                    ],
                    [
                        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                    ],
                    [
                        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                    ],
                    [
                        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                    ],
                    [
                        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                    ],
                    [
                        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                    ],
                    [
                        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                    ],
                    [
                        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                    ]
                ]
            },
            naf: {
                wnd: 7,
                points: [
                    [
                        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                    ],
                    [
                        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                    ],
                    [
                        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                    ],
                    [
                        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                    ],
                    [
                        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                    ],
                    [
                        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                    ],
                    [
                        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                    ],
                    [
                        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                    ],
                    [
                        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                    ],
                    [
                        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                    ],
                    [
                        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                    ],
                    [
                        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                    ],
                    [
                        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                    ],
                    [
                        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                    ],
                    [
                        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                    ],
                    [
                        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                    ],
                    [
                        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                    ],
                    [
                        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                    ],
                    [
                        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                    ],
                    [
                        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                    ],
                    [
                        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                    ],
                    [
                        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                    ],
                    [
                        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                    ],
                    [
                        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                    ],
                    [
                        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                    ],
                    [
                        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                    ],
                    [
                        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                    ],
                    [
                        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                    ],
                    [
                        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                    ],
                    [
                        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                    ],
                    [
                        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                    ],
                    [
                        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                    ],
                    [
                        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                    ],
                    [
                        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                    ],
                    [
                        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                    ],
                    [
                        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                    ],
                    [
                        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                    ],
                    [
                        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                    ],
                    [
                        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                    ],
                    [
                        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                    ],
                    [
                        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                    ],
                    [
                        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                    ],
                    [
                        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                    ],
                    [
                        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                    ],
                    [
                        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                    ],
                    [
                        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                    ],
                    [
                        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                    ],
                    [
                        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                    ],
                    [
                        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                    ],
                    [
                        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                    ],
                    [
                        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                    ],
                    [
                        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                    ],
                    [
                        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                    ],
                    [
                        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                    ],
                    [
                        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                    ],
                    [
                        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                    ],
                    [
                        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                    ],
                    [
                        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                    ],
                    [
                        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                    ],
                    [
                        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                    ],
                    [
                        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                    ],
                    [
                        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                    ],
                    [
                        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                    ],
                    [
                        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                    ],
                    [
                        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                    ],
                    [
                        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                    ],
                    [
                        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                    ],
                    [
                        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                    ],
                    [
                        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                    ],
                    [
                        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                    ],
                    [
                        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                    ],
                    [
                        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                    ],
                    [
                        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                    ],
                    [
                        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                    ],
                    [
                        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                    ],
                    [
                        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                    ],
                    [
                        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                    ],
                    [
                        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                    ],
                    [
                        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                    ],
                    [
                        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                    ],
                    [
                        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                    ],
                    [
                        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                    ],
                    [
                        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                    ],
                    [
                        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                    ],
                    [
                        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                    ],
                    [
                        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                    ],
                    [
                        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                    ],
                    [
                        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                    ],
                    [
                        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                    ],
                    [
                        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                    ],
                    [
                        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                    ],
                    [
                        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                    ],
                    [
                        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                    ],
                    [
                        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                    ],
                    [
                        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                    ],
                    [
                        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                    ],
                    [
                        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                    ],
                    [
                        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                    ],
                    [
                        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                    ],
                    [
                        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                    ],
                    [
                        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                    ],
                    [
                        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                    ],
                    [
                        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                    ],
                    [
                        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                    ],
                    [
                        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                    ],
                    [
                        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                    ],
                    [
                        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                    ],
                    [
                        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                    ],
                    [
                        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                    ],
                    [
                        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                    ],
                    [
                        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                    ],
                    [
                        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                    ],
                    [
                        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                    ],
                    [
                        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                    ],
                    [
                        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                    ],
                    [
                        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                    ],
                    [
                        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                    ],
                    [
                        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                    ],
                    [
                        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                    ],
                    [
                        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                    ],
                    [
                        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                    ],
                    [
                        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                    ],
                    [
                        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                    ],
                    [
                        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                    ],
                    [
                        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                    ],
                    [
                        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                    ],
                    [
                        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                    ]
                ]
            }
        };
        const conf = {
            prime: 'k256',
            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
            a: '0',
            b: '7',
            n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
            h: '1',
            // Precomputed endomorphism
            beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
            lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
            basis: [
                {
                    a: '3086d221a7d46bcde86c90e49284eb15',
                    b: '-e4437ed6010e88286f547fa90abfe4c3'
                },
                {
                    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                    b: '3086d221a7d46bcde86c90e49284eb15'
                }
            ],
            gRed: false,
            g: [
                '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                precomputed
            ]
        };
        this.p = new BigNumber_js_1.default(conf.p, 16);
        // Use Montgomery, when there is no fast reduction for the prime
        this.red = new ReductionContext_js_1.default(conf.prime);
        // Useful for many curves
        this.zero = new BigNumber_js_1.default(0).toRed(this.red);
        this.one = new BigNumber_js_1.default(1).toRed(this.red);
        this.two = new BigNumber_js_1.default(2).toRed(this.red);
        // Curve configuration, optional
        this.n = new BigNumber_js_1.default(conf.n, 16);
        this.g = Point_js_1.default.fromJSON(conf.g, conf.gRed);
        // Temporary arrays
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n.bitLength();
        this.redN = this.n.toRed(this.red);
        this.a = new BigNumber_js_1.default(conf.a, 16).toRed(this.red);
        this.b = new BigNumber_js_1.default(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        // If the curve is endomorphic, precalculate beta and lambda
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
    }
    _getEndomorphism(conf) {
        // No efficient endomorphism
        if (!this.zeroA || this.p.modrn(3) !== 1) {
            return;
        }
        // Compute beta and lambda, that lambda * P = (beta * Px; Py)
        let beta;
        let lambda;
        if (conf.beta !== undefined) {
            beta = new BigNumber_js_1.default(conf.beta, 16).toRed(this.red);
        }
        else {
            const betas = this._getEndoRoots(this.p);
            if (betas === null) {
                throw new Error('Failed to get endomorphism roots for beta.');
            }
            // Choose the smallest beta
            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
            beta = beta.toRed(this.red);
        }
        if (conf.lambda !== undefined) {
            lambda = new BigNumber_js_1.default(conf.lambda, 16);
        }
        else {
            // Choose the lambda that matches selected beta
            const lambdas = this._getEndoRoots(this.n);
            if (lambdas === null) {
                throw new Error('Failed to get endomorphism roots for lambda.');
            }
            if (this.g == null) {
                throw new Error('Curve generator point (g) is not defined.');
            }
            const gMulX = this.g.mul(lambdas[0])?.x;
            const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;
            if ((gMulX != null) && (gXRedMulBeta != null) && gMulX.cmp(gXRedMulBeta) === 0) {
                lambda = lambdas[0];
            }
            else {
                lambda = lambdas[1];
                if (this.g == null) {
                    throw new Error('Curve generator point (g) is not defined.');
                }
                const gMulX = this.g.mul(lambda)?.x;
                const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;
                if ((gMulX == null) || (gXRedMulBeta == null)) {
                    throw new Error('Lambda computation failed: g.mul(lambda).x or g.x.redMul(beta) is undefined.');
                }
                Curve.assert(gMulX.cmp(gXRedMulBeta) === 0, 'Lambda selection does not match computed beta.');
            }
        }
        // Get basis vectors, used for balanced length-two representation
        let basis;
        if (typeof conf.basis === 'object' && conf.basis !== null) {
            basis = conf.basis.map(function (vec) {
                return {
                    a: new BigNumber_js_1.default(vec.a, 16),
                    b: new BigNumber_js_1.default(vec.b, 16)
                };
            });
        }
        else {
            basis = this._getEndoBasis(lambda);
        }
        return {
            beta,
            lambda,
            basis
        };
    }
    _getEndoRoots(num) {
        // Find roots of for x^2 + x + 1 in F
        // Root = (-1 +- Sqrt(-3)) / 2
        //
        const red = num === this.p ? this.red : new MontgomoryMethod_js_1.default(num);
        const tinv = new BigNumber_js_1.default(2).toRed(red).redInvm();
        const ntinv = tinv.redNeg();
        const s = new BigNumber_js_1.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        const l1 = ntinv.redAdd(s).fromRed();
        const l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
    }
    _getEndoBasis(lambda) {
        // aprxSqrt >= sqrt(this.n)
        const aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        // 3.74
        // Run EGCD, until r(L + 1) < aprxSqrt
        let u = lambda;
        let v = this.n.clone();
        let x1 = new BigNumber_js_1.default(1);
        let y1 = new BigNumber_js_1.default(0);
        let x2 = new BigNumber_js_1.default(0);
        let y2 = new BigNumber_js_1.default(1);
        // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
        let a0;
        let b0;
        // First vector
        let a1;
        let b1;
        // Second vector
        let a2;
        let b2;
        let prevR = new BigNumber_js_1.default(0);
        let i = 0;
        let r = new BigNumber_js_1.default(0);
        let x = new BigNumber_js_1.default(0); // Ensure x is initialized
        while (u.cmpn(0) !== 0) {
            const q = v.div(u);
            r = v.sub(q.mul(u));
            x = x2.sub(q.mul(x1)); // Now TypeScript knows x is always assigned
            const y = y2.sub(q.mul(y1));
            if (a1 === undefined && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
            }
            else if (a1 !== undefined && ++i === 2) {
                break;
            }
            prevR = r;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
            y2 = y1;
            y1 = y;
        }
        // Ensure a0 and b0 have been assigned
        if (a0 === undefined ||
            b0 === undefined ||
            a1 === undefined ||
            b1 === undefined) {
            throw new Error('Failed to compute Endo Basis values');
        }
        a2 = r.neg();
        b2 = x;
        const len1 = a1.sqr().add(b1.sqr());
        const len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
            a2 = a0;
            b2 = b0;
        }
        // Normalize signs
        if (a1.negative !== 0) {
            a1 = a1.neg();
            b1 = b1.neg();
        }
        if (a2.negative !== 0) {
            a2 = a2.neg();
            b2 = b2.neg();
        }
        return [
            { a: a1, b: b1 },
            { a: a2, b: b2 }
        ];
    }
    _endoSplit(k) {
        if (this.endo == null) {
            throw new Error('Endomorphism is not defined.');
        }
        const basis = this.endo.basis;
        const v1 = basis[0];
        const v2 = basis[1];
        const c1 = v2.b.mul(k).divRound(this.n);
        const c2 = v1.b.neg().mul(k).divRound(this.n);
        const p1 = c1.mul(v1.a);
        const p2 = c2.mul(v2.a);
        const q1 = c1.mul(v1.b);
        const q2 = c2.mul(v2.b);
        // Calculate answer
        const k1 = k.sub(p1).sub(p2);
        const k2 = q1.add(q2).neg();
        return { k1, k2 };
    }
    validate(point) {
        if (point.inf) {
            return true;
        }
        const x = point.x;
        const y = point.y;
        // Ensure x and y are not null before proceeding
        if (x === null || y === null) {
            throw new Error('Point coordinates cannot be null');
        }
        const ax = this.a.redMul(x);
        const rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
    }
}
exports.default = Curve;

},{"./BigNumber.js":42,"./MontgomoryMethod.js":50,"./Point.js":51,"./ReductionContext.js":56,"./utils.js":62}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Hash_js_1 = require("./Hash.js");
const utils_js_1 = require("./utils.js");
/**
 * This class behaves as a HMAC-based deterministic random bit generator (DRBG). It implements a deterministic random number generator using SHA256HMAC HASH function. It takes an initial entropy and nonce when instantiated for seeding purpose.
 * @class DRBG
 *
 * @constructor
 * @param entropy - Initial entropy either in number array or hexadecimal string.
 * @param nonce - Initial nonce either in number array or hexadecimal string.
 *
 * @throws Throws an error message 'Not enough entropy. Minimum is 256 bits' when entropy's length is less than 32.
 *
 * @example
 * const drbg = new DRBG('af12de...', '123ef...');
 */
class DRBG {
    constructor(entropy, nonce) {
        entropy = (0, utils_js_1.toArray)(entropy, 'hex');
        nonce = (0, utils_js_1.toArray)(nonce, 'hex');
        if (entropy.length < 32) {
            throw new Error('Not enough entropy. Minimum is 256 bits');
        }
        const seed = entropy.concat(nonce);
        this.K = new Array(32);
        this.V = new Array(32);
        for (let i = 0; i < 32; i++) {
            this.K[i] = 0x00;
            this.V[i] = 0x01;
        }
        this.update(seed);
    }
    /**
     * Generates HMAC using the K value of the instance. This method is used internally for operations.
     *
     * @method hmac
     * @returns The SHA256HMAC object created with K value.
     *
     * @example
     * const hmac = drbg.hmac();
     */
    hmac() {
        return new Hash_js_1.SHA256HMAC(this.K);
    }
    /**
     * Updates the `K` and `V` values of the instance based on the seed.
     * The seed if not provided uses `V` as seed.
     *
     * @method update
     * @param seed - an optional value that used to update `K` and `V`. Default is `undefined`.
     * @returns Nothing, but updates the internal state `K` and `V` value.
     *
     * @example
     * drbg.update('e13af...');
     */
    update(seed) {
        let kmac = this.hmac().update(this.V).update([0x00]);
        if (seed !== undefined) {
            kmac = kmac.update(seed);
        }
        this.K = kmac.digest();
        this.V = this.hmac().update(this.V).digest();
        if (seed === undefined) {
            return;
        }
        this.K = this.hmac().update(this.V).update([0x01]).update(seed).digest();
        this.V = this.hmac().update(this.V).digest();
    }
    /**
     * Generates deterministic random hexadecimal string of given length.
     * In every generation process, it also updates the internal state `K` and `V`.
     *
     * @method generate
     * @param len - The length of required random number.
     * @returns The required deterministic random hexadecimal string.
     *
     * @example
     * const randomHex = drbg.generate(256);
     */
    generate(len) {
        let temp = [];
        while (temp.length < len) {
            this.V = this.hmac().update(this.V).digest();
            temp = temp.concat(this.V);
        }
        const res = temp.slice(0, len);
        this.update();
        return (0, utils_js_1.toHex)(res);
    }
}
exports.default = DRBG;

},{"./Hash.js":46,"./utils.js":62}],45:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Signature_js_1 = __importDefault(require("./Signature.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const Point_js_1 = require("./Point.js");
const DRBG_js_1 = __importDefault(require("./DRBG.js"));
/**
 * Truncates a BigNumber message to the length of the curve order n, in the context of the Elliptic Curve Digital Signature Algorithm (ECDSA).
 * This method is used as part of ECDSA signing and verification.
 *
 * The method calculates `delta`, which is a difference obtained by subtracting the bit length of the curve order `n` from the byte length of the message in bits.
 * If `delta` is greater than zero, logical shifts msg to the right by `delta`, retaining the sign.
 *
 * Another condition is tested, but only if `truncOnly` is false. This condition compares the value of msg to curve order `n`.
 * If msg is greater or equal to `n`, it is decreased by `n` and returned.
 *
 * @method truncateToN
 * @param msg - The BigNumber message to be truncated.
 * @param truncOnly - An optional boolean parameter that if set to true, the method will only perform truncation of the BigNumber without doing the additional subtraction from the curve order.
 * @returns Returns the truncated BigNumber value, potentially subtracted by the curve order n.
 *
 * @example
 * let msg = new BigNumber('1234567890abcdef', 16);
 * let truncatedMsg = truncateToN(msg);
 */
function truncateToN(msg, truncOnly, curve = new Curve_js_1.default()) {
    const delta = msg.byteLength() * 8 - curve.n.bitLength();
    if (delta > 0) {
        msg.iushrn(delta);
    }
    if (truncOnly === null && msg.cmp(curve.n) >= 0) {
        return msg.sub(curve.n);
    }
    else {
        return msg;
    }
}
const curve = new Curve_js_1.default();
const bytes = curve.n.byteLength();
const ns1 = curve.n.subn(1);
const halfN = Point_js_1.N_BIGINT >> 1n;
/**
 * Generates a digital signature for a given message.
 *
 * @function sign
 * @param msg - The BigNumber message for which the signature has to be computed.
 * @param key - Private key in BigNumber.
 * @param forceLowS - Optional boolean flag if True forces "s" to be the lower of two possible values.
 * @param customK - Optional specification for k value, which can be a function or BigNumber.
 * @returns Returns the elliptic curve digital signature of the message.
 *
 * @example
 * const msg = new BigNumber('2664878')
 * const key = new BigNumber('123456')
 * const signature = sign(msg, key)
 */
const sign = (msg, key, forceLowS = false, customK) => {
    // —— prepare inputs ────────────────────────────────────────────────────────
    msg = truncateToN(msg);
    const msgBig = BigInt('0x' + msg.toString(16));
    const keyBig = BigInt('0x' + key.toString(16));
    // DRBG seeding identical to previous implementation
    const bkey = key.toArray('be', bytes);
    const nonce = msg.toArray('be', bytes);
    const drbg = new DRBG_js_1.default(bkey, nonce);
    for (let iter = 0;; iter++) {
        // —— k generation & basic validity checks ───────────────────────────────
        let kBN = typeof customK === 'function'
            ? customK(iter)
            : BigNumber_js_1.default.isBN(customK)
                ? customK
                : new BigNumber_js_1.default(drbg.generate(bytes), 16);
        if (kBN == null)
            throw new Error('k is undefined');
        kBN = truncateToN(kBN, true);
        if (kBN.cmpn(1) <= 0 || kBN.cmp(ns1) >= 0) {
            if (BigNumber_js_1.default.isBN(customK)) {
                throw new Error('Invalid fixed custom K value (must be >1 and <N‑1)');
            }
            continue;
        }
        const kBig = BigInt('0x' + kBN.toString(16));
        // —— R = k·G (Jacobian, window‑NAF) ──────────────────────────────────────
        const R = (0, Point_js_1.scalarMultiplyWNAF)(kBig, { x: Point_js_1.GX_BIGINT, y: Point_js_1.GY_BIGINT });
        if (R.Z === 0n) { // point at infinity – should never happen for valid k
            if (BigNumber_js_1.default.isBN(customK)) {
                throw new Error('Invalid fixed custom K value (k·G at infinity)');
            }
            continue;
        }
        // affine X coordinate of R
        const zInv = (0, Point_js_1.biModInv)(R.Z);
        const zInv2 = (0, Point_js_1.biModMul)(zInv, zInv);
        const xAff = (0, Point_js_1.biModMul)(R.X, zInv2);
        const rBig = (0, Point_js_1.modN)(xAff);
        if (rBig === 0n) {
            if (BigNumber_js_1.default.isBN(customK)) {
                throw new Error('Invalid fixed custom K value (r == 0)');
            }
            continue;
        }
        // —— s = k⁻¹ · (msg + r·key)  mod n ─────────────────────────────────────
        const kInv = (0, Point_js_1.modInvN)(kBig);
        const rTimesKey = (0, Point_js_1.modMulN)(rBig, keyBig);
        const sum = (0, Point_js_1.modN)(msgBig + rTimesKey);
        let sBig = (0, Point_js_1.modMulN)(kInv, sum);
        if (sBig === 0n) {
            if (BigNumber_js_1.default.isBN(customK)) {
                throw new Error('Invalid fixed custom K value (s == 0)');
            }
            continue;
        }
        // low‑S mitigation (BIP‑62/BIP‑340 style)
        if (forceLowS && sBig > halfN) {
            sBig = Point_js_1.N_BIGINT - sBig;
        }
        // —— convert back to BigNumber & return ─────────────────────────────────
        const r = new BigNumber_js_1.default(rBig.toString(16), 16);
        const s = new BigNumber_js_1.default(sBig.toString(16), 16);
        return new Signature_js_1.default(r, s);
    }
};
exports.sign = sign;
/**
 * Verifies a digital signature of a given message.
 *
 * Message and key used during the signature generation process, and the previously computed signature
 * are used to validate the authenticity of the digital signature.
 *
 * @function verify
 * @param msg - The BigNumber message for which the signature has to be verified.
 * @param sig - Signature object consisting of parameters 'r' and 's'.
 * @param key - Public key in Point.
 * @returns Returns true if the signature is valid and false otherwise.
 *
 * @example
 * const msg = new BigNumber('2664878', 16)
 * const key = new Point(new BigNumber(10), new BigNumber(20)
 * const signature = sign(msg, new BigNumber('123456'))
 * const isVerified = verify(msg, sig, key)
 */
const verify = (msg, sig, key) => {
    // Convert inputs to BigInt
    const hash = BigInt('0x' + msg.toString(16));
    if ((key.x == null) || (key.y == null)) {
        throw new Error('Invalid public key: missing coordinates.');
    }
    const publicKey = {
        x: BigInt('0x' + key.x.toString(16)),
        y: BigInt('0x' + key.y.toString(16))
    };
    const signature = {
        r: BigInt('0x' + sig.r.toString(16)),
        s: BigInt('0x' + sig.s.toString(16))
    };
    const { r, s } = signature;
    const z = hash;
    // Check r and s are in [1, n - 1]
    if (r <= Point_js_1.BI_ZERO || r >= Point_js_1.N_BIGINT || s <= Point_js_1.BI_ZERO || s >= Point_js_1.N_BIGINT) {
        return false;
    }
    // ── compute u₁ = z·s⁻¹ mod n  and  u₂ = r·s⁻¹ mod n ───────────────────────
    const w = (0, Point_js_1.modInvN)(s); // s⁻¹ mod n
    if (w === 0n)
        return false; // should never happen
    const u1 = (0, Point_js_1.modMulN)(z, w);
    const u2 = (0, Point_js_1.modMulN)(r, w);
    // ── R = u₁·G + u₂·Q  (Jacobian, window‑NAF) ──────────────────────────────
    const RG = (0, Point_js_1.scalarMultiplyWNAF)(u1, { x: Point_js_1.GX_BIGINT, y: Point_js_1.GY_BIGINT });
    const RQ = (0, Point_js_1.scalarMultiplyWNAF)(u2, publicKey);
    const R = (0, Point_js_1.jpAdd)(RG, RQ);
    if (R.Z === 0n)
        return false; // point at infinity
    // ── affine x‑coordinate of R  (mod p) ─────────────────────────────────────
    const zInv = (0, Point_js_1.biModInv)(R.Z); // (Z⁻¹ mod p)
    const zInv2 = (0, Point_js_1.biModMul)(zInv, zInv); // Z⁻²
    const xAff = (0, Point_js_1.biModMul)(R.X, zInv2); // X / Z²  mod p
    // ── v = xAff mod n  and final check ───────────────────────────────────────
    const v = (0, Point_js_1.modN)(xAff);
    return v === r;
};
exports.verify = verify;

},{"./BigNumber.js":42,"./Curve.js":43,"./DRBG.js":44,"./Point.js":51,"./Signature.js":58}],46:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbkdf2 = exports.sha512hmac = exports.sha256hmac = exports.hash160 = exports.hash256 = exports.sha512 = exports.sha256 = exports.sha1 = exports.ripemd160 = exports.SHA512HMAC = exports.SHA1HMAC = exports.SHA256HMAC = exports.SHA512 = exports.SHA1 = exports.SHA256 = exports.RIPEMD160 = exports.toArray = void 0;
// @ts-nocheck
/* eslint-disable @typescript-eslint/naming-convention */
const assert = (expression, message = 'Hash assertion failed') => {
    if (!expression) {
        throw new Error(message);
    }
};
/**
 * The BaseHash class is an abstract base class for cryptographic hash functions.
 * It provides a common structure and functionality for hash function classes.
 *
 * @class BaseHash
 *
 * @property pending - Stores partially processed message segments.
 * @property pendingTotal - The total number of characters that are being stored in `pending`
 * @property blockSize - The size of each block to processed.
 * @property outSize - The size of the final hash output.
 * @property endian - The endianness used during processing, can either be 'big' or 'little'.
 * @property _delta8 - The block size divided by 8, useful in various computations.
 * @property _delta32 - The block size divided by 32, useful in various computations.
 * @property padLength - The length of padding to be added to finalize the computation.
 * @property hmacStrength - The HMAC strength value.
 *
 * @param blockSize - The size of the block to be hashed.
 * @param outSize - The size of the resulting hash.
 * @param hmacStrength - The strength of the HMAC.
 * @param padLength - The length of the padding to be added.
 *
 * @example
 * Sub-classes would extend this base BaseHash class like:
 * class RIPEMD160 extends BaseHash {
 *   constructor () {
 *     super(512, 160, 192, 64);
 *     // ...
 *   }
 *   // ...
 * }
 */
class BaseHash {
    constructor(blockSize, outSize, hmacStrength, padLength) {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = blockSize;
        this.outSize = outSize;
        this.hmacStrength = hmacStrength;
        this.padLength = padLength / 8;
        this.endian = 'big';
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
    }
    _update(msg, start) {
        throw new Error('Not implemented');
    }
    _digest() {
        throw new Error('Not implemented');
    }
    _digestHex() {
        throw new Error('Not implemented');
    }
    /**
     * Converts the input message into an array, pads it, and joins into 32bit blocks.
     * If there is enough data, it tries updating the hash computation.
     *
     * @method update
     * @param msg - The message segment to include in the hashing computation.
     * @param enc - The encoding of the message. If 'hex', the string will be treated as such, 'utf8' otherwise.
     *
     * @returns Returns the instance of the object for chaining.
     *
     * @example
     * sha256.update('Hello World', 'utf8');
     */
    update(msg, enc) {
        // Convert message to array, pad it, and join into 32bit blocks
        msg = toArray(msg, enc);
        if (this.pending == null) {
            this.pending = msg;
        }
        else {
            this.pending = this.pending.concat(msg);
        }
        this.pendingTotal += msg.length;
        // Enough data, try updating
        if (this.pending.length >= this._delta8) {
            msg = this.pending;
            // Process pending data in blocks
            const r = msg.length % this._delta8;
            this.pending = msg.slice(msg.length - r, msg.length);
            if (this.pending.length === 0) {
                this.pending = null;
            }
            msg = join32(msg, 0, msg.length - r, this.endian);
            for (let i = 0; i < msg.length; i += this._delta32) {
                this._update(msg, i);
            }
        }
        return this;
    }
    /**
     * Finalizes the hash computation and returns the hash value/result.
     *
     * @method digest
     *
     * @returns Returns the final hash value.
     *
     * @example
     * const hash = sha256.digest();
     */
    digest() {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest();
    }
    /**
     * Finalizes the hash computation and returns the hash value/result as a hex string.
     *
     * @method digest
     *
     * @returns Returns the final hash value as a hex string.
     *
     * @example
     * const hash = sha256.digestHex();
     */
    digestHex() {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digestHex();
    }
    /**
     * [Private Method] Used internally to prepare the padding for the final stage of the hash computation.
     *
     * @method _pad
     * @private
     *
     * @returns Returns an array denoting the padding.
     */
    _pad() {
        //
        let len = this.pendingTotal;
        const bytes = this._delta8;
        const k = bytes - ((len + this.padLength) % bytes);
        const res = new Array(k + this.padLength);
        res[0] = 0x80;
        let i;
        for (i = 1; i < k; i++) {
            res[i] = 0;
        }
        // Append length
        len <<= 3;
        let t;
        if (this.endian === 'big') {
            for (t = 8; t < this.padLength; t++) {
                res[i++] = 0;
            }
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = (len >>> 24) & 0xff;
            res[i++] = (len >>> 16) & 0xff;
            res[i++] = (len >>> 8) & 0xff;
            res[i++] = len & 0xff;
        }
        else {
            res[i++] = len & 0xff;
            res[i++] = (len >>> 8) & 0xff;
            res[i++] = (len >>> 16) & 0xff;
            res[i++] = (len >>> 24) & 0xff;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            for (t = 8; t < this.padLength; t++) {
                res[i++] = 0;
            }
        }
        return res;
    }
}
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xfc00) !== 0xd800) {
        return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
        return false;
    }
    return (msg.charCodeAt(i + 1) & 0xfc00) === 0xdc00;
}
/**
 *
 * @param msg
 * @param enc Optional. Encoding to use if msg is string. Default is 'utf8'.
 * @returns array of byte values from msg. If msg is an array, a copy is returned.
 */
function toArray(msg, enc) {
    if (Array.isArray(msg)) {
        return msg.slice();
    }
    if (!msg) {
        return [];
    }
    const res = [];
    if (typeof msg === 'string') {
        if (enc !== 'hex') {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            let p = 0;
            for (let i = 0; i < msg.length; i++) {
                let c = msg.charCodeAt(i);
                if (c < 128) {
                    res[p++] = c;
                }
                else if (c < 2048) {
                    res[p++] = (c >> 6) | 192;
                    res[p++] = (c & 63) | 128;
                }
                else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03ff) << 10) + (msg.charCodeAt(++i) & 0x03ff);
                    res[p++] = (c >> 18) | 240;
                    res[p++] = ((c >> 12) & 63) | 128;
                    res[p++] = ((c >> 6) & 63) | 128;
                    res[p++] = (c & 63) | 128;
                }
                else {
                    res[p++] = (c >> 12) | 224;
                    res[p++] = ((c >> 6) & 63) | 128;
                    res[p++] = (c & 63) | 128;
                }
            }
        }
        else {
            msg = msg.replace(/[^a-z0-9]+/gi, '');
            if (msg.length % 2 !== 0) {
                msg = '0' + msg;
            }
            for (let i = 0; i < msg.length; i += 2) {
                res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
        }
    }
    else {
        msg = msg;
        for (let i = 0; i < msg.length; i++) {
            res[i] = msg[i] | 0;
        }
    }
    return res;
}
exports.toArray = toArray;
function htonl(w) {
    const res = (w >>> 24) |
        ((w >>> 8) & 0xff00) |
        ((w << 8) & 0xff0000) |
        ((w & 0xff) << 24);
    return res >>> 0;
}
function toHex32(msg, endian) {
    let res = '';
    for (let i = 0; i < msg.length; i++) {
        let w = msg[i];
        if (endian === 'little') {
            w = htonl(w);
        }
        res += zero8(w.toString(16));
    }
    return res;
}
function zero8(word) {
    if (word.length === 7) {
        return '0' + word;
    }
    else if (word.length === 6) {
        return '00' + word;
    }
    else if (word.length === 5) {
        return '000' + word;
    }
    else if (word.length === 4) {
        return '0000' + word;
    }
    else if (word.length === 3) {
        return '00000' + word;
    }
    else if (word.length === 2) {
        return '000000' + word;
    }
    else if (word.length === 1) {
        return '0000000' + word;
    }
    else {
        return word;
    }
}
function bytesToHex(data) {
    let res = '';
    for (const b of data)
        res += b.toString(16).padStart(2, '0');
    return res;
}
function join32(msg, start, end, endian) {
    const len = end - start;
    assert(len % 4 === 0);
    const res = new Array(len / 4);
    for (let i = 0, k = start; i < res.length; i++, k += 4) {
        let w;
        if (endian === 'big') {
            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
        }
        else {
            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
        }
        res[i] = w >>> 0;
    }
    return res;
}
function split32(msg, endian) {
    const res = new Array(msg.length * 4);
    for (let i = 0, k = 0; i < msg.length; i++, k += 4) {
        const m = msg[i];
        if (endian === 'big') {
            res[k] = m >>> 24;
            res[k + 1] = (m >>> 16) & 0xff;
            res[k + 2] = (m >>> 8) & 0xff;
            res[k + 3] = m & 0xff;
        }
        else {
            res[k + 3] = m >>> 24;
            res[k + 2] = (m >>> 16) & 0xff;
            res[k + 1] = (m >>> 8) & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
function rotr32(w, b) {
    return (w >>> b) | (w << (32 - b));
}
function rotl32(w, b) {
    return (w << b) | (w >>> (32 - b));
}
function sum32(a, b) {
    return (a + b) >>> 0;
}
function SUM32_3(a, b, c) {
    return (a + b + c) >>> 0;
}
function SUM32_4(a, b, c, d) {
    return (a + b + c + d) >>> 0;
}
function SUM32_5(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
}
function FT_1(s, x, y, z) {
    if (s === 0) {
        return ch32(x, y, z);
    }
    if (s === 1 || s === 3) {
        return p32(x, y, z);
    }
    if (s === 2) {
        return maj32(x, y, z);
    }
    return 0;
}
function ch32(x, y, z) {
    return (x & y) ^ (~x & z);
}
function maj32(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
}
function p32(x, y, z) {
    return x ^ y ^ z;
}
function S0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
function S1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
function G0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
function G1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
const r = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15,
    3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11,
    5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7,
    12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];
const rh = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,
    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0,
    4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1,
    5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];
const s = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7,
    15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5,
    12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5,
    11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];
const sh = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,
    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,
    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,
    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];
function f(j, x, y, z) {
    if (j <= 15) {
        return x ^ y ^ z;
    }
    else if (j <= 31) {
        return (x & y) | (~x & z);
    }
    else if (j <= 47) {
        return (x | ~y) ^ z;
    }
    else if (j <= 63) {
        return (x & z) | (y & ~z);
    }
    else {
        return x ^ (y | ~z);
    }
}
function K(j) {
    if (j <= 15) {
        return 0x00000000;
    }
    else if (j <= 31) {
        return 0x5a827999;
    }
    else if (j <= 47) {
        return 0x6ed9eba1;
    }
    else if (j <= 63) {
        return 0x8f1bbcdc;
    }
    else {
        return 0xa953fd4e;
    }
}
function Kh(j) {
    if (j <= 15) {
        return 0x50a28be6;
    }
    else if (j <= 31) {
        return 0x5c4dd124;
    }
    else if (j <= 47) {
        return 0x6d703ef3;
    }
    else if (j <= 63) {
        return 0x7a6d76e9;
    }
    else {
        return 0x00000000;
    }
}
/**
 * An implementation of RIPEMD160 cryptographic hash function. Extends the BaseHash class.
 * It provides a way to compute a 'digest' for any kind of input data; transforming the data
 * into a unique output of fixed size. The output is deterministic; it will always be
 * the same for the same input.
 *
 * @class RIPEMD160
 * @param None
 *
 * @constructor
 * Use the RIPEMD160 constructor to create an instance of RIPEMD160 hash function.
 *
 * @example
 * const ripemd160 = new RIPEMD160();
 *
 * @property h - Array that is updated iteratively as part of hashing computation.
 */
class RIPEMD160 extends BaseHash {
    constructor() {
        super(512, 160, 192, 64);
        this.endian = 'little';
        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        this.endian = 'little';
    }
    _update(msg, start) {
        let A = this.h[0];
        let B = this.h[1];
        let C = this.h[2];
        let D = this.h[3];
        let E = this.h[4];
        let Ah = A;
        let Bh = B;
        let Ch = C;
        let Dh = D;
        let Eh = E;
        let T;
        for (let j = 0; j < 80; j++) {
            T = sum32(rotl32(SUM32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
            A = E;
            E = D;
            D = rotl32(C, 10);
            C = B;
            B = T;
            T = sum32(rotl32(SUM32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
            Ah = Eh;
            Eh = Dh;
            Dh = rotl32(Ch, 10);
            Ch = Bh;
            Bh = T;
        }
        T = SUM32_3(this.h[1], C, Dh);
        this.h[1] = SUM32_3(this.h[2], D, Eh);
        this.h[2] = SUM32_3(this.h[3], E, Ah);
        this.h[3] = SUM32_3(this.h[4], A, Bh);
        this.h[4] = SUM32_3(this.h[0], B, Ch);
        this.h[0] = T;
    }
    _digest() {
        return split32(this.h, 'little');
    }
    _digestHex() {
        return toHex32(this.h, 'little');
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * An implementation of SHA256 cryptographic hash function. Extends the BaseHash class.
 * It provides a way to compute a 'digest' for any kind of input data; transforming the data
 * into a unique output of fixed size. The output is deterministic; it will always be
 * the same for the same input.
 *
 * @class SHA256
 * @param None
 *
 * @constructor
 * Use the SHA256 constructor to create an instance of SHA256 hash function.
 *
 * @example
 * const sha256 = new SHA256();
 *
 * @property h - The initial hash constants
 * @property W - Provides a way to recycle usage of the array memory.
 * @property k - The round constants used for each round of SHA-256
 */
class SHA256 {
    constructor() {
        this.h = new FastSHA256();
    }
    update(msg, enc) {
        const data = Uint8Array.from(toArray(msg, enc));
        this.h.update(data);
        return this;
    }
    digest() {
        return Array.from(this.h.digest());
    }
    digestHex() {
        return bytesToHex(this.h.digest());
    }
}
exports.SHA256 = SHA256;
/**
 * An implementation of SHA1 cryptographic hash function. Extends the BaseHash class.
 * It provides a way to compute a 'digest' for any kind of input data; transforming the data
 * into a unique output of fixed size. The output is deterministic; it will always be
 * the same for the same input.
 *
 * @class SHA1
 * @param None
 *
 * @constructor
 * Use the SHA1 constructor to create an instance of SHA1 hash function.
 *
 * @example
 * const sha1 = new SHA1();
 *
 * @property h - The initial hash constants.
 * @property W - Provides a way to recycle usage of the array memory.
 * @property k - The round constants used for each round of SHA-1.
 */
class SHA1 extends BaseHash {
    constructor() {
        super(512, 160, 80, 64);
        this.k = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        this.W = new Array(80);
    }
    _update(msg, start) {
        const W = this.W;
        // Default start to 0
        if (start === undefined) {
            start = 0;
        }
        let i;
        for (i = 0; i < 16; i++) {
            W[i] = msg[start + i];
        }
        for (; i < W.length; i++) {
            W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }
        let a = this.h[0];
        let b = this.h[1];
        let c = this.h[2];
        let d = this.h[3];
        let e = this.h[4];
        for (i = 0; i < W.length; i++) {
            const s = ~~(i / 20);
            const t = SUM32_5(rotl32(a, 5), FT_1(s, b, c, d), e, W[i], this.k[s]);
            e = d;
            d = c;
            c = rotl32(b, 30);
            b = a;
            a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
    }
    _digest() {
        return split32(this.h, 'big');
    }
    _digestHex() {
        return toHex32(this.h, 'big');
    }
}
exports.SHA1 = SHA1;
/**
 * An implementation of SHA512 cryptographic hash function. Extends the BaseHash class.
 * It provides a way to compute a 'digest' for any kind of input data; transforming the data
 * into a unique output of fixed size. The output is deterministic; it will always be
 * the same for the same input.
 *
 * @class SHA512
 * @param None
 *
 * @constructor
 * Use the SHA512 constructor to create an instance of SHA512 hash function.
 *
 * @example
 * const sha512 = new SHA512();
 *
 * @property h - The initial hash constants.
 * @property W - Provides a way to recycle usage of the array memory.
 * @property k - The round constants used for each round of SHA-512.
 */
class SHA512 {
    constructor() {
        this.h = new FastSHA512();
    }
    update(msg, enc) {
        const data = Uint8Array.from(toArray(msg, enc));
        this.h.update(data);
        return this;
    }
    digest() {
        return Array.from(this.h.digest());
    }
    digestHex() {
        return bytesToHex(this.h.digest());
    }
}
exports.SHA512 = SHA512;
/**
 * The `SHA256HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-256 cryptographic hash function.
 *
 * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.
 *
 * This class also uses the SHA-256 cryptographic hash algorithm that produces a 256-bit (32-byte) hash value.
 *
 * @property inner - Represents the inner hash of SHA-256.
 * @property outer - Represents the outer hash of SHA-256.
 * @property blockSize - The block size for the SHA-256 hash function, in bytes. It's set to 64 bytes.
 * @property outSize - The output size of the SHA-256 hash function, in bytes. It's set to 32 bytes.
 */
class SHA256HMAC {
    /**
     * The constructor for the `SHA256HMAC` class.
     *
     * It initializes the `SHA256HMAC` object and sets up the inner and outer padded keys.
     * If the key size is larger than the blockSize, it is digested using SHA-256.
     * If the key size is less than the blockSize, it is padded with zeroes.
     *
     * @constructor
     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.
     *
     * @example
     * const myHMAC = new SHA256HMAC('deadbeef');
     */
    constructor(key) {
        this.blockSize = 64;
        this.outSize = 32;
        const k = Uint8Array.from(toArray(key, 'hex'));
        this.h = new HMAC(sha256Fast, k);
    }
    /**
     * Updates the `SHA256HMAC` object with part of the message to be hashed.
     *
     * @method update
     * @param msg - Part of the message to hash. Can be a number array or a string.
     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.
     * @returns Returns the instance of `SHA256HMAC` for chaining calls.
     *
     * @example
     * myHMAC.update('deadbeef', 'hex');
     */
    update(msg, enc) {
        this.h.update(Uint8Array.from(toArray(msg, enc)));
        return this;
    }
    /**
     * Finalizes the HMAC computation and returns the resultant hash.
     *
     * @method digest
     * @returns Returns the digest of the hashed data. Can be a number array or a string.
     *
     * @example
     * let hashedMessage = myHMAC.digest();
     */
    digest() {
        return Array.from(this.h.digest());
    }
    /**
     * Finalizes the HMAC computation and returns the resultant hash as a hex string.
     *
     * @method digest
     * @returns Returns the digest of the hashed data as a hex string
     *
     * @example
     * let hashedMessage = myHMAC.digestHex();
     */
    digestHex() {
        return bytesToHex(this.h.digest());
    }
}
exports.SHA256HMAC = SHA256HMAC;
class SHA1HMAC {
    constructor(key) {
        this.blockSize = 64;
        key = toArray(key, 'hex');
        // Shorten key, if needed
        if (key.length > this.blockSize) {
            key = new SHA1().update(key).digest();
        }
        // Keys shorter than block size are padded with zeros on the right
        let i;
        for (i = key.length; i < this.blockSize; i++) {
            key.push(0);
        }
        for (i = 0; i < key.length; i++) {
            key[i] ^= 0x36;
        }
        this.inner = new SHA1().update(key);
        // 0x36 ^ 0x5c = 0x6a
        for (i = 0; i < key.length; i++) {
            key[i] ^= 0x6a;
        }
        this.outer = new SHA1().update(key);
    }
    update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
    }
    digest() {
        this.outer.update(this.inner.digest());
        return this.outer.digest();
    }
    digestHex() {
        this.outer.update(this.inner.digest());
        return this.outer.digestHex();
    }
}
exports.SHA1HMAC = SHA1HMAC;
/**
 * The `SHA512HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-512 cryptographic hash function.
 *
 * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.
 *
 * This class also uses the SHA-512 cryptographic hash algorithm that produces a 512-bit (64-byte) hash value.
 *
 * @property inner - Represents the inner hash of SHA-512.
 * @property outer - Represents the outer hash of SHA-512.
 * @property blockSize - The block size for the SHA-512 hash function, in bytes. It's set to 128 bytes.
 * @property outSize - The output size of the SHA-512 hash function, in bytes. It's set to 64 bytes.
 */
class SHA512HMAC {
    /**
     * The constructor for the `SHA512HMAC` class.
     *
     * It initializes the `SHA512HMAC` object and sets up the inner and outer padded keys.
     * If the key size is larger than the blockSize, it is digested using SHA-512.
     * If the key size is less than the blockSize, it is padded with zeroes.
     *
     * @constructor
     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.
     *
     * @example
     * const myHMAC = new SHA512HMAC('deadbeef');
     */
    constructor(key) {
        this.blockSize = 128;
        this.outSize = 32;
        const k = Uint8Array.from(toArray(key, 'hex'));
        this.h = new HMAC(sha512Fast, k);
    }
    /**
     * Updates the `SHA512HMAC` object with part of the message to be hashed.
     *
     * @method update
     * @param msg - Part of the message to hash. Can be a number array or a string.
     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.
     * @returns Returns the instance of `SHA512HMAC` for chaining calls.
     *
     * @example
     * myHMAC.update('deadbeef', 'hex');
     */
    update(msg, enc) {
        this.h.update(Uint8Array.from(toArray(msg, enc)));
        return this;
    }
    /**
     * Finalizes the HMAC computation and returns the resultant hash.
     *
     * @method digest
     * @returns Returns the digest of the hashed data as a number array.
     *
     * @example
     * let hashedMessage = myHMAC.digest();
     */
    digest() {
        return Array.from(this.h.digest());
    }
    /**
     * Finalizes the HMAC computation and returns the resultant hash as a hex string.
     *
     * @method digest
     * @returns Returns the digest of the hashed data as a hex string
     *
     * @example
     * let hashedMessage = myHMAC.digestHex();
     */
    digestHex() {
        return bytesToHex(this.h.digest());
    }
}
exports.SHA512HMAC = SHA512HMAC;
/**
 * Computes RIPEMD160 hash of a given message.
 * @function ripemd160
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed RIPEMD160 hash of the message.
 *
 * @example
 * const digest = ripemd160('Hello, world!');
 */
const ripemd160 = (msg, enc) => {
    return new RIPEMD160().update(msg, enc).digest();
};
exports.ripemd160 = ripemd160;
/**
 * Computes SHA1 hash of a given message.
 * @function sha1
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed SHA1 hash of the message.
 *
 * @example
 * const digest = sha1('Hello, world!');
 */
const sha1 = (msg, enc) => {
    return new SHA1().update(msg, enc).digest();
};
exports.sha1 = sha1;
/**
 * Computes SHA256 hash of a given message.
 * @function sha256
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed SHA256 hash of the message.
 *
 * @example
 * const digest = sha256('Hello, world!');
 */
const sha256 = (msg, enc) => {
    return new SHA256().update(msg, enc).digest();
};
exports.sha256 = sha256;
/**
 * Computes SHA512 hash of a given message.
 * @function sha512
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed SHA512 hash of the message.
 *
 * @example
 * const digest = sha512('Hello, world!');
 */
const sha512 = (msg, enc) => {
    return new SHA512().update(msg, enc).digest();
};
exports.sha512 = sha512;
/**
 * Performs a 'double hash' using SHA256. This means the data is hashed twice
 * with SHA256. First, the SHA256 hash of the message is computed, then the
 * SHA256 hash of the resulting hash is computed.
 * @function hash256
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the double hashed SHA256 output.
 *
 * @example
 * const doubleHash = hash256('Hello, world!');
 */
const hash256 = (msg, enc) => {
    const first = new SHA256().update(msg, enc).digest();
    return new SHA256().update(first).digest();
};
exports.hash256 = hash256;
/**
 * Computes SHA256 hash of a given message and then computes a RIPEMD160 hash of the result.
 *
 * @function hash160
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the RIPEMD160 hash of the SHA256 hash of the input message.
 *
 * @example
 * const hash = hash160('Hello, world!');
 */
const hash160 = (msg, enc) => {
    const first = new SHA256().update(msg, enc).digest();
    return new RIPEMD160().update(first).digest();
};
exports.hash160 = hash160;
/**
 * Computes SHA256 HMAC of a given message with a given key.
 * @function sha256hmac
 * @param key - The key used to compute the HMAC
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed HMAC of the message.
 *
 * @example
 * const digest = sha256hmac('deadbeef', 'ffff001d');
 */
const sha256hmac = (key, msg, enc) => {
    return new SHA256HMAC(key).update(msg, enc).digest();
};
exports.sha256hmac = sha256hmac;
/**
 * Computes SHA512 HMAC of a given message with a given key.
 * @function sha512hmac
 * @param key - The key used to compute the HMAC
 * @param msg - The message to compute the hash for.
 * @param enc - The encoding of msg if string. Default is 'utf8'.
 *
 * @returns the computed HMAC of the message.
 *
 * @example
 * const digest = sha512hmac('deadbeef', 'ffff001d');
 */
const sha512hmac = (key, msg, enc) => {
    return new SHA512HMAC(key).update(msg, enc).digest();
};
exports.sha512hmac = sha512hmac;
// BEGIN fast-pbkdf2 helpers
// Utils
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) {
        throw new Error(`positive integer expected, got ${n}`);
    }
}
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) {
        const lens = lengths.join(',');
        throw new Error(`Uint8Array expected of length ${lens}, got length=${b.length}`);
    }
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') {
        throw new Error('Hash should be wrapped by utils.createHasher');
    }
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
    if (instance.destroyed === true)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished === true) {
        throw new Error('Hash#digest() has already been called');
    }
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++)
        arrays[i].fill(0);
}
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
class Hash {
}
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
// u64 helpers
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    const Ah = new Uint32Array(len);
    const Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        Ah[i] = h;
        Al[i] = l;
    }
    return [Ah, Al];
}
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// _md helpers
class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        aexists(this);
        data = toBytes(data);
        abytes(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 0b10000000;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4 !== 0)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen !== 0)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// sha256 fast constants
const SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
const K256 = Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
const SHA256_W = new Uint32Array(64);
class FastSHA256 extends HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA256_W[i] = view.getUint32(offset);
        }
        for (let i = 16; i < 64; i++) {
            const w15 = SHA256_W[i - 15];
            const w2 = SHA256_W[i - 2];
            const s0 = G0_256(w15);
            const s1 = G1_256(w2);
            SHA256_W[i] = sum32(sum32(s0, SHA256_W[i - 7]), sum32(s1, SHA256_W[i - 16]));
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const T1 = SUM32_5(H, S1_256(E), ch32(E, F, G), K256[i], SHA256_W[i]);
            const T2 = sum32(S0_256(A), maj32(A, B, C));
            H = G;
            G = F;
            F = E;
            E = sum32(D, T1);
            D = C;
            C = B;
            B = A;
            A = sum32(T1, T2);
        }
        this.A = sum32(this.A, A);
        this.B = sum32(this.B, B);
        this.C = sum32(this.C, C);
        this.D = sum32(this.D, D);
        this.E = sum32(this.E, E);
        this.F = sum32(this.F, F);
        this.G = sum32(this.G, G);
        this.H = sum32(this.H, H);
    }
    roundClean() {
        clean(SHA256_W);
    }
    destroy() {
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
    }
}
const sha256Fast = createHasher(() => new FastSHA256());
// sha512
const SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179
]);
const K512 = (() => split([
    '0x428a2f98d728ae22',
    '0x7137449123ef65cd',
    '0xb5c0fbcfec4d3b2f',
    '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538',
    '0x59f111f1b605d019',
    '0x923f82a4af194f9b',
    '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242',
    '0x12835b0145706fbe',
    '0x243185be4ee4b28c',
    '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f',
    '0x80deb1fe3b1696b1',
    '0x9bdc06a725c71235',
    '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2',
    '0xefbe4786384f25e3',
    '0x0fc19dc68b8cd5b5',
    '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275',
    '0x4a7484aa6ea6e483',
    '0x5cb0a9dcbd41fbd4',
    '0x76f988da831153b5',
    '0x983e5152ee66dfab',
    '0xa831c66d2db43210',
    '0xb00327c898fb213f',
    '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2',
    '0xd5a79147930aa725',
    '0x06ca6351e003826f',
    '0x142929670a0e6e70',
    '0x27b70a8546d22ffc',
    '0x2e1b21385c26c926',
    '0x4d2c6dfc5ac42aed',
    '0x53380d139d95b3df',
    '0x650a73548baf63de',
    '0x766a0abb3c77b2a8',
    '0x81c2c92e47edaee6',
    '0x92722c851482353b',
    '0xa2bfe8a14cf10364',
    '0xa81a664bbc423001',
    '0xc24b8b70d0f89791',
    '0xc76c51a30654be30',
    '0xd192e819d6ef5218',
    '0xd69906245565a910',
    '0xf40e35855771202a',
    '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8',
    '0x1e376c085141ab53',
    '0x2748774cdf8eeb99',
    '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63',
    '0x4ed8aa4ae3418acb',
    '0x5b9cca4f7763e373',
    '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc',
    '0x78a5636f43172f60',
    '0x84c87814a1f0ab72',
    '0x8cc702081a6439ec',
    '0x90befffa23631e28',
    '0xa4506cebde82bde9',
    '0xbef9a3f7b2c67915',
    '0xc67178f2e372532b',
    '0xca273eceea26619c',
    '0xd186b8c721c0c207',
    '0xeada7dd6cde0eb1e',
    '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba',
    '0x0a637dc5a2c898a6',
    '0x113f9804bef90dae',
    '0x1b710b35131c471b',
    '0x28db77f523047d84',
    '0x32caab7b40c72493',
    '0x3c9ebe0a15c9bebc',
    '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6',
    '0x597f299cfc657e2a',
    '0x5fcb6fab3ad6faec',
    '0x6c44198c4a475817'
].map((n) => BigInt(n))))();
const SHA512_Kh = (() => K512[0])();
const SHA512_Kl = (() => K512[1])();
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class FastSHA512 extends HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = SHA512_IV[0] | 0;
        this.Al = SHA512_IV[1] | 0;
        this.Bh = SHA512_IV[2] | 0;
        this.Bl = SHA512_IV[3] | 0;
        this.Ch = SHA512_IV[4] | 0;
        this.Cl = SHA512_IV[5] | 0;
        this.Dh = SHA512_IV[6] | 0;
        this.Dl = SHA512_IV[7] | 0;
        this.Eh = SHA512_IV[8] | 0;
        this.El = SHA512_IV[9] | 0;
        this.Fh = SHA512_IV[10] | 0;
        this.Fl = SHA512_IV[11] | 0;
        this.Gh = SHA512_IV[12] | 0;
        this.Gl = SHA512_IV[13] | 0;
        this.Hh = SHA512_IV[14] | 0;
        this.Hl = SHA512_IV[15] | 0;
    }
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
            const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
            const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
            const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
            const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
            const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
            const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const T2l = add3L(sigma0l, MAJl, T1l);
            Ah = add3H(T2l, sigma0h, MAJh, T1h);
            Al = T2l | 0;
        }
        ;
        ({ h: Ah, l: Al } = add(Ah, Al, this.Ah, this.Al));
        ({ h: Bh, l: Bl } = add(Bh, Bl, this.Bh, this.Bl));
        ({ h: Ch, l: Cl } = add(Ch, Cl, this.Ch, this.Cl));
        ({ h: Dh, l: Dl } = add(Dh, Dl, this.Dh, this.Dl));
        ({ h: Eh, l: El } = add(Eh, El, this.Eh, this.El));
        ({ h: Fh, l: Fl } = add(Fh, Fl, this.Fh, this.Fl));
        ({ h: Gh, l: Gl } = add(Gh, Gl, this.Gh, this.Gl));
        ({ h: Hh, l: Hl } = add(Hh, Hl, this.Hh, this.Hl));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
const sha512Fast = createHasher(() => new FastSHA512());
class HMAC extends Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash);
        const key = toBytes(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') {
            throw new Error('Expected instance of class which extends utils.Hash');
        }
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        clean(pad);
    }
    update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash ?? undefined);
        to.iHash = iHash._cloneInto(to.iHash ?? undefined);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
function pbkdf2Core(hash, password, salt, opts) {
    ahash(hash);
    const { c, dkLen } = Object.assign({ dkLen: 32 }, opts);
    anumber(c);
    anumber(dkLen);
    if (c < 1)
        throw new Error('iterations (c) should be >= 1');
    const pwd = kdfInputToBytes(password);
    const slt = kdfInputToBytes(salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash, pwd);
    const PRFSalt = PRF._cloneInto().update(slt);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW != null)
        prfW.destroy();
    clean(u);
    return DK;
}
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);
function pbkdf2Fast(password, salt, iterations, keylen) {
    return pbkdf2Core(sha512Fast, password, salt, { c: iterations, dkLen: keylen });
}
// END fast-pbkdf2 helpers
/**
 * Limited SHA-512-only PBKDF2 function for use in deprecated BIP39 code.
 * @function pbkdf2
 * @param password - The PBKDF2 password
 * @param salt - The PBKDF2 salt
 * @param iterations - The number of of iterations to run
 * @param keylen - The length of the key
 * @param digest - The digest (must be sha512 for this implementation)
 *
 * @returns The computed key
 */
function pbkdf2(password, salt, iterations, keylen, digest = 'sha512') {
    if (digest !== 'sha512') {
        throw new Error('Only sha512 is supported in this PBKDF2 implementation');
    }
    // Attempt to use the native Node.js implementation if available as it is
    // considerably faster than the pure TypeScript fallback below. If the crypto
    // module isn't present (for example in a browser build) we'll silently fall
    // back to the original implementation.
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const nodeCrypto = require('crypto');
        if (typeof nodeCrypto.pbkdf2Sync === 'function') {
            const p = Buffer.from(password);
            const s = Buffer.from(salt);
            return [...nodeCrypto.pbkdf2Sync(p, s, iterations, keylen, digest)];
        }
    }
    catch {
        // ignore
    }
    const p = Uint8Array.from(password);
    const s = Uint8Array.from(salt);
    const out = pbkdf2Fast(p, s, iterations, keylen);
    return Array.from(out);
}
exports.pbkdf2 = pbkdf2;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"crypto":206}],47:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BasePoint_js_1 = __importDefault(require("./BasePoint.js"));
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Point_js_1 = __importDefault(require("./Point.js"));
/**
 * The `JacobianPoint` class extends the `BasePoint` class for handling Jacobian coordinates on an Elliptic Curve.
 * This class defines the properties and the methods needed to work with points in Jacobian coordinates.
 *
 * The Jacobian coordinates represent a point (x, y, z) on an Elliptic Curve such that the usual (x, y) coordinates are given by (x/z^2, y/z^3).
 *
 * @property x - The `x` coordinate of the point in the Jacobian form.
 * @property y - The `y` coordinate of the point in the Jacobian form.
 * @property z - The `z` coordinate of the point in the Jacobian form.
 * @property zOne - Flag that indicates if the `z` coordinate is one.
 *
 * @example
 * const pointJ = new JacobianPoint('3', '4', '1');
 */
class JacobianPoint extends BasePoint_js_1.default {
    /**
     * Constructs a new `JacobianPoint` instance.
     *
     * @param x - If `null`, the x-coordinate will default to the curve's defined 'one' constant.
     * If `x` is not a BigNumber, `x` will be converted to a `BigNumber` assuming it is a hex string.
     *
     * @param y - If `null`, the y-coordinate will default to the curve's defined 'one' constant.
     * If `y` is not a BigNumber, `y` will be converted to a `BigNumber` assuming it is a hex string.
     *
     * @param z - If `null`, the z-coordinate will default to 0.
     * If `z` is not a BigNumber, `z` will be converted to a `BigNumber` assuming it is a hex string.
     *
     * @example
     * const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity
     * const pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)
     */
    constructor(x, y, z) {
        super('jacobian');
        if (x === null && y === null && z === null) {
            this.x = this.curve.one;
            this.y = this.curve.one;
            this.z = new BigNumber_js_1.default(0);
        }
        else {
            if (!BigNumber_js_1.default.isBN(x)) {
                x = new BigNumber_js_1.default(x, 16);
            }
            this.x = x;
            if (!BigNumber_js_1.default.isBN(y)) {
                y = new BigNumber_js_1.default(y, 16);
            }
            this.y = y;
            if (!BigNumber_js_1.default.isBN(z)) {
                z = new BigNumber_js_1.default(z, 16);
            }
            this.z = z;
        }
        if (this.x.red == null) {
            this.x = this.x.toRed(this.curve.red);
        }
        if (this.y.red == null) {
            this.y = this.y.toRed(this.curve.red);
        }
        if (this.z.red == null) {
            this.z = this.z.toRed(this.curve.red);
        }
        this.zOne = this.z === this.curve.one;
    }
    /**
     * Converts the `JacobianPoint` object instance to standard affine `Point` format and returns `Point` type.
     *
     * @returns The `Point`(affine) object representing the same point as the original `JacobianPoint`.
     *
     * If the initial `JacobianPoint` represents point at infinity, an instance of `Point` at infinity is returned.
     *
     * @example
     * const pointJ = new JacobianPoint('3', '4', '1');
     * const pointP = pointJ.toP();  // The point in affine coordinates.
     */
    toP() {
        if (this.isInfinity()) {
            return new Point_js_1.default(null, null);
        }
        const zinv = this.z.redInvm();
        const zinv2 = zinv.redSqr();
        const ax = this.x.redMul(zinv2);
        const ay = this.y.redMul(zinv2).redMul(zinv);
        return new Point_js_1.default(ax, ay);
    }
    /**
     * Negation operation. It returns the additive inverse of the Jacobian point.
     *
     * @method neg
     * @returns Returns a new Jacobian point as the result of the negation.
     *
     * @example
     * const jp = new JacobianPoint(x, y, z)
     * const result = jp.neg()
     */
    neg() {
        return new JacobianPoint(this.x, this.y.redNeg(), this.z);
    }
    /**
     * Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument
     * and returns a new Jacobian point as a result of the addition. In the special cases,
     * when either one of the points is the point at infinity, it will return the other point.
     *
     * @method add
     * @param p - The Jacobian point to be added.
     * @returns Returns a new Jacobian point as the result of the addition.
     *
     * @example
     * const p1 = new JacobianPoint(x1, y1, z1)
     * const p2 = new JacobianPoint(x2, y2, z2)
     * const result = p1.add(p2)
     */
    add(p) {
        // O + P = P
        if (this.isInfinity()) {
            return p;
        }
        // P + O = P
        if (p.isInfinity()) {
            return this;
        }
        // 12M + 4S + 7A
        const pz2 = p.z.redSqr();
        const z2 = this.z.redSqr();
        const u1 = this.x.redMul(pz2);
        const u2 = p.x.redMul(z2);
        const s1 = this.y.redMul(pz2.redMul(p.z));
        const s2 = p.y.redMul(z2.redMul(this.z));
        const h = u1.redSub(u2);
        const r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) {
                return new JacobianPoint(null, null, null);
            }
            else {
                return this.dbl();
            }
        }
        const h2 = h.redSqr();
        const h3 = h2.redMul(h);
        const v = u1.redMul(h2);
        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        const nz = this.z.redMul(p.z).redMul(h);
        return new JacobianPoint(nx, ny, nz);
    }
    /**
     * Mixed addition operation. This function combines the standard point addition with
     * the transformation from the affine to Jacobian coordinates. It first converts
     * the affine point to Jacobian, and then preforms the addition.
     *
     * @method mixedAdd
     * @param p - The affine point to be added.
     * @returns Returns the result of the mixed addition as a new Jacobian point.
     *
     * @example
     * const jp = new JacobianPoint(x1, y1, z1)
     * const ap = new Point(x2, y2)
     * const result = jp.mixedAdd(ap)
     */
    mixedAdd(p) {
        // O + P = P
        if (this.isInfinity()) {
            return p.toJ();
        }
        // P + O = P
        if (p.isInfinity()) {
            return this;
        }
        // Ensure x and y are not null
        if (p.x === null || p.y === null) {
            throw new Error('Point coordinates cannot be null');
        }
        // 8M + 3S + 7A
        const z2 = this.z.redSqr();
        const u1 = this.x;
        const u2 = p.x.redMul(z2);
        const s1 = this.y;
        const s2 = p.y.redMul(z2).redMul(this.z);
        const h = u1.redSub(u2);
        const r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) {
                return new JacobianPoint(null, null, null);
            }
            else {
                return this.dbl();
            }
        }
        const h2 = h.redSqr();
        const h3 = h2.redMul(h);
        const v = u1.redMul(h2);
        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        const nz = this.z.redMul(h);
        return new JacobianPoint(nx, ny, nz);
    }
    /**
     * Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.
     *
     * @method dblp
     * @param pow - The number of times the point should be doubled.
     * @returns Returns a new Jacobian point as the result of multiple doublings.
     *
     * @example
     * const jp = new JacobianPoint(x, y, z)
     * const result = jp.dblp(3)
     */
    dblp(pow) {
        if (pow === 0) {
            return this;
        }
        if (this.isInfinity()) {
            return this;
        }
        if (typeof pow === 'undefined') {
            return this.dbl();
        }
        /* eslint-disable @typescript-eslint/no-this-alias */
        let r = this;
        for (let i = 0; i < pow; i++) {
            r = r.dbl();
        }
        return r;
    }
    /**
     * Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.
     *
     * @method dbl
     * @returns Returns a new Jacobian point as the result of the doubling.
     *
     * @example
     * const jp = new JacobianPoint(x, y, z)
     * const result = jp.dbl()
     */
    dbl() {
        if (this.isInfinity()) {
            return this;
        }
        let nx;
        let ny;
        let nz;
        // Z = 1
        if (this.zOne) {
            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
            //     #doubling-mdbl-2007-bl
            // 1M + 5S + 14A
            // XX = X1^2
            const xx = this.x.redSqr();
            // YY = Y1^2
            const yy = this.y.redSqr();
            // YYYY = YY^2
            const yyyy = yy.redSqr();
            // S = 2 * ((X1 + YY)^2 - XX - YYYY)
            let s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            // M = 3 * XX + a; a = 0
            const m = xx.redAdd(xx).redIAdd(xx);
            // T = M ^ 2 - 2*S
            const t = m.redSqr().redISub(s).redISub(s);
            // 8 * YYYY
            let yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            // X3 = T
            nx = t;
            // Y3 = M * (S - T) - 8 * YYYY
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            // Z3 = 2*Y1
            nz = this.y.redAdd(this.y);
        }
        else {
            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
            //     #doubling-dbl-2009-l
            // 2M + 5S + 13A
            // A = X1^2
            const a = this.x.redSqr();
            // B = Y1^2
            const b = this.y.redSqr();
            // C = B^2
            const c = b.redSqr();
            // D = 2 * ((X1 + B)^2 - A - C)
            let d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
            d = d.redIAdd(d);
            // E = 3 * A
            const e = a.redAdd(a).redIAdd(a);
            // F = E^2
            const f = e.redSqr();
            // 8 * C
            let c8 = c.redIAdd(c);
            c8 = c8.redIAdd(c8);
            c8 = c8.redIAdd(c8);
            // X3 = F - 2 * D
            nx = f.redISub(d).redISub(d);
            // Y3 = E * (D - X3) - 8 * C
            ny = e.redMul(d.redISub(nx)).redISub(c8);
            // Z3 = 2 * Y1 * Z1
            nz = this.y.redMul(this.z);
            nz = nz.redIAdd(nz);
        }
        return new JacobianPoint(nx, ny, nz);
    }
    /**
     * Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.
     *
     * @method eq
     * @param p - The affine or Jacobian point to compare with.
     * @returns Returns true if the points are equal, otherwise returns false.
     *
     * @example
     * const jp1 = new JacobianPoint(x1, y1, z1)
     * const jp2 = new JacobianPoint(x2, y2, z2)
     * const areEqual = jp1.eq(jp2)
     */
    eq(p) {
        if (p.type === 'affine') {
            return this.eq(p.toJ());
        }
        if (this === p) {
            return true;
        }
        // x1 * z2^2 == x2 * z1^2
        const z2 = this.z.redSqr();
        p = p;
        const pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) {
            return false;
        }
        // y1 * z2^3 == y2 * z1^3
        const z3 = z2.redMul(this.z);
        const pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    }
    /**
     * Equality check operation in relation to an x coordinate of a point in projective coordinates.
     * It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate
     * of a point in projective coordinates.
     *
     * @method eqXToP
     * @param x - The x coordinate of a point in projective coordinates.
     * @returns Returns true if the x coordinates are equal, otherwise returns false.
     *
     * @example
     * const jp = new JacobianPoint(x1, y1, z1)
     * const isXEqual = jp.eqXToP(x2)
     */
    eqXToP(x) {
        const zs = this.z.redSqr();
        const rx = x.toRed(this.curve?.red).redMul(zs);
        if (this.x.cmp(rx) === 0) {
            return true;
        }
        const xc = x.clone();
        if (this.curve === null || (this.curve.redN == null)) {
            throw new Error('Curve or redN is not initialized.');
        }
        const t = this.curve.redN.redMul(zs);
        while (xc.cmp(this.curve.p) < 0) {
            xc.iadd(this.curve.n);
            if (xc.cmp(this.curve.p) >= 0) {
                return false;
            }
            rx.redIAdd(t);
            if (this.x.cmp(rx) === 0) {
                return true;
            }
        }
        // ✅ Ensure function always returns a boolean
        return false;
    }
    /**
     * Returns the string representation of the JacobianPoint instance.
     * @method inspect
     * @returns Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is '<EC JPoint Infinity>'. For a normal point, it returns the string description format as '<EC JPoint x: x-coordinate y: y-coordinate z: z-coordinate>'.
     *
     * @example
     * const point = new JacobianPoint('5', '6', '1');
     * console.log(point.inspect()); // Output: '<EC JPoint x: 5 y: 6 z: 1>'
     */
    inspect() {
        if (this.isInfinity()) {
            return '<EC JPoint Infinity>';
        }
        return ('<EC JPoint x: ' +
            this.x.toString(16, 2) +
            ' y: ' +
            this.y.toString(16, 2) +
            ' z: ' +
            this.z.toString(16, 2) +
            '>');
    }
    /**
     * Checks whether the JacobianPoint instance represents a point at infinity.
     * @method isInfinity
     * @returns Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.
     *
     * @example
     * const point = new JacobianPoint('5', '6', '0');
     * console.log(point.isInfinity()); // Output: true
     */
    isInfinity() {
        return this.z.cmpn(0) === 0;
    }
}
exports.default = JacobianPoint;

},{"./BasePoint.js":41,"./BigNumber.js":42,"./Point.js":51}],48:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mersenne_js_1 = __importDefault(require("./Mersenne.js"));
/**
 * A class representing K-256, a prime number with optimizations, specifically used in the secp256k1 curve.
 * It extends the functionalities of the Mersenne class.
 * K-256 prime is represented as 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
 *
 * @class K256
 * @extends {Mersenne}
 *
 * @example
 * const k256 = new K256();
 */
class K256 extends Mersenne_js_1.default {
    /**
     * Constructor for the K256 class.
     * Creates an instance of K256 using the super constructor from Mersenne.
     *
     * @constructor
     *
     * @example
     * const k256 = new K256();
     */
    constructor() {
        super('k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    /**
     * Splits a BigNumber into a new BigNumber based on specific computation
     * rules. This method modifies the input and output big numbers.
     *
     * @method split
     * @param input - The BigNumber to be split.
     * @param output - The BigNumber that results from the split.
     *
     * @example
     * const input = new BigNumber(3456);
     * const output = new BigNumber(0);
     * k256.split(input, output);
     */
    split(input, output) {
        const mask = 0x3fffff; // 22 bits
        const inputWords = input.words; // Access via getter
        const inputNominalLength = input.length; // Access via getter, respects _nominalWordLength
        const outLen = Math.min(inputNominalLength, 9);
        const tempOutputWords = new Array(outLen + (inputNominalLength > 9 ? 1 : 0)).fill(0);
        for (let i = 0; i < outLen; i++) {
            tempOutputWords[i] = inputWords[i];
        }
        let currentOutputWordCount = outLen;
        if (inputNominalLength <= 9) {
            const finalOutputWords = new Array(currentOutputWordCount);
            for (let i = 0; i < currentOutputWordCount; ++i)
                finalOutputWords[i] = tempOutputWords[i];
            output.words = finalOutputWords; // Use setter
            input.words = [0]; // Use setter to set to 0
            return;
        }
        // Shift by 9 limbs
        let prev = inputWords[9];
        tempOutputWords[currentOutputWordCount++] = prev & mask;
        const finalOutputWords = new Array(currentOutputWordCount);
        for (let i = 0; i < currentOutputWordCount; ++i)
            finalOutputWords[i] = tempOutputWords[i];
        output.words = finalOutputWords; // Use setter for output
        // For input modification
        const tempInputNewWords = new Array(Math.max(1, inputNominalLength - 9)).fill(0);
        let currentInputNewWordCount = 0;
        for (let i = 10; i < inputNominalLength; i++) {
            const next = inputWords[i] | 0;
            if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check
                tempInputNewWords[currentInputNewWordCount++] = ((next & mask) << 4) | (prev >>> 22);
            }
            prev = next;
        }
        prev >>>= 22;
        if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check
            tempInputNewWords[currentInputNewWordCount++] = prev;
        }
        else if (prev !== 0 && tempInputNewWords.length > 0) { // If prev is non-zero but no space, this is an issue.
            // This case implies original logic might have relied on array auto-expansion or specific length handling
            // For safety, if there's still a carry and no space, the array should have been bigger.
            // However, the original logic `input.length -= 9` suggests truncation.
        }
        const finalInputNewWords = new Array(currentInputNewWordCount);
        for (let i = 0; i < currentInputNewWordCount; ++i)
            finalInputNewWords[i] = tempInputNewWords[i];
        input.words = finalInputNewWords; // Use setter, which will strip and set magnitude
    }
    /**
     * Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result.
     * 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].
     *
     * @method imulK
     * @param num - The BigNumber to multiply with K.
     * @returns Returns the mutated BigNumber after multiplication.
     *
     * @example
     * const number = new BigNumber(12345);
     * const result = k256.imulK(number);
     */
    imulK(num) {
        const currentWords = num.words; // Get current words based on _magnitude and _nominalWordLength
        const originalNominalLength = num.length; // Getter
        const newNominalLength = originalNominalLength + 2;
        const tempWords = new Array(newNominalLength).fill(0);
        for (let i = 0; i < originalNominalLength; i++) {
            tempWords[i] = currentWords[i];
        }
        // tempWords is now effectively num.words expanded with zeroes
        let lo = 0;
        for (let i = 0; i < newNominalLength; i++) { // Iterate up to new expanded length
            const w = tempWords[i] | 0;
            lo += w * 0x3d1; // 0x3d1 = 977
            tempWords[i] = lo & 0x3ffffff; // 26-bit mask
            lo = w * 0x40 + ((lo / 0x4000000) | 0); // 0x40 = 64. 0x4000000 = 2^26
        }
        num.words = tempWords; // Use setter to re-initialize from tempWords
        // The setter will handle _magnitude, _sign, _nominalWordLength, and strip.
        return num;
    }
}
exports.default = K256;

},{"./Mersenne.js":49}],49:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
/**
 * A representation of a pseudo-Mersenne prime.
 * A pseudo-Mersenne prime has the general form 2^n - k, where n and k are integers.
 *
 * @class Mersenne
 *
 * @property name - The identifier for the Mersenne instance.
 * @property p - BigNumber equivalent to 2^n - k.
 * @property k - The constant subtracted from 2^n to derive a pseudo-Mersenne prime.
 * @property n - The exponent which determines the magnitude of the prime.
 */
class Mersenne {
    /**
     * @constructor
     * @param name - An identifier for the Mersenne instance.
     * @param p - A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.
     *
     * @example
     * const mersenne = new Mersenne('M31', '7FFFFFFF');
     */
    constructor(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BigNumber_js_1.default(p, 16);
        this.n = this.p.bitLength();
        this.k = new BigNumber_js_1.default(BigInt(1)).iushln(this.n).isub(this.p); // Use 1n for BigInt compatibility
        this.tmp = this._tmp();
    }
    /**
     * Creates a temporary BigNumber structure for computations,
     * ensuring the appropriate number of words are initially allocated.
     *
     * @method _tmp
     * @returns A BigNumber with scaled size depending on prime magnitude.
     */
    _tmp() {
        const tmp = new BigNumber_js_1.default(BigInt(0)); // Initialize with BigInt 0
        const requiredWords = Math.ceil(this.n / BigNumber_js_1.default.wordSize);
        tmp.expand(Math.max(1, requiredWords)); // Expand sets _nominalWordLength
        return tmp;
    }
    /**
     * Reduces an input BigNumber in place, under the assumption that
     * it is less than the square of the pseudo-Mersenne prime.
     *
     * @method ireduce
     * @param num - The BigNumber to be reduced.
     * @returns The reduced BigNumber.
     *
     * @example
     * const reduced = mersenne.ireduce(new BigNumber('2345', 16));
     */
    ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        const r = num; // num is directly modified
        let rlen;
        do {
            this.split(r, this.tmp); // r is modified (becomes HI), this.tmp becomes LO
            this.imulK(r); // r becomes HI * K
            r.iadd(this.tmp); // r becomes HI * K + LO
            rlen = r.bitLength();
        } while (rlen > this.n);
        const cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words = [0]; // Set to zero using the words setter
        }
        else if (cmp > 0) {
            r.isub(this.p);
        }
        // No explicit strip needed here if operations maintain correctness and setter handles it.
        // However, ensuring it's stripped to minimal form after reduction is good.
        r.strip();
        return r;
    }
    /**
     * Shifts bits of the input BigNumber to the right, in place,
     * to meet the magnitude of the pseudo-Mersenne prime.
     *
     * @method split
     * @param input - The BigNumber to be shifted (will contain HI part).
     * @param out - The BigNumber to hold the shifted result (LO part).
     *
     * @example
     * mersenne.split(new BigNumber('2345', 16), new BigNumber());
     */
    split(input, out) {
        // out gets the LO bits (shifted out part)
        // input gets modified to be the HI bits (remaining part after shift)
        input.iushrn(this.n, 0, out);
    }
    /**
     * Performs an in-place multiplication of the parameter by constant k.
     *
     * @method imulK
     * @param num - The BigNumber to multiply with k.
     * @returns The result of the multiplication, in BigNumber format.
     *
     * @example
     * const multiplied = mersenne.imulK(new BigNumber('2345', 16));
     */
    imulK(num) {
        return num.imul(this.k);
    }
}
exports.default = Mersenne;

},{"./BigNumber.js":42}],50:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ReductionContext_js_1 = __importDefault(require("./ReductionContext.js"));
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
/**
 * Represents a Montgomery reduction context, which is a mathematical method
 * for performing modular multiplication without division.
 *
 * Montgomery reduction is an algorithm used mainly in cryptography which can
 * help to speed up calculations in contexts where there are many repeated
 * computations.
 *
 * This class extends the `ReductionContext` class.
 *
 * @class MontgomoryMethod
 * @extends {ReductionContext}
 *
 * @property shift - The number of bits in the modulus.
 * @property r - The 2^shift, shifted left by the bit length of modulus `m`.
 * @property r2 - The square of `r` modulo `m`.
 * @property rinv - The modular multiplicative inverse of `r` mod `m`.
 * @property minv - The modular multiplicative inverse of `m` mod `r`.
 */
class MontgomoryMethod extends ReductionContext_js_1.default {
    /**
     * @constructor
     * @param m - The modulus to be used for the Montgomery method reductions.
     */
    constructor(m) {
        super(m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
            this.shift += 26 - (this.shift % 26);
        }
        this.r = new BigNumber_js_1.default(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    /**
     * Converts a number into the Montgomery domain.
     *
     * @method convertTo
     * @param num - The number to be converted into the Montgomery domain.
     * @returns The result of the conversion into the Montgomery domain.
     *
     * @example
     * const montMethod = new MontgomoryMethod(m);
     * const convertedNum = montMethod.convertTo(num);
     */
    convertTo(num) {
        return this.imod(num.ushln(this.shift));
    }
    /**
     * Converts a number from the Montgomery domain back to the original domain.
     *
     * @method convertFrom
     * @param num - The number to be converted from the Montgomery domain.
     * @returns The result of the conversion from the Montgomery domain.
     *
     * @example
     * const montMethod = new MontgomoryMethod(m);
     * const convertedNum = montMethod.convertFrom(num);
     */
    convertFrom(num) {
        const r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    }
    /**
     * Performs an in-place multiplication of two numbers in the Montgomery domain.
     *
     * @method imul
     * @param a - The first number to multiply.
     * @param b - The second number to multiply.
     * @returns The result of the in-place multiplication.
     *
     * @example
     * const montMethod = new MontgomoryMethod(m);
     * const product = montMethod.imul(a, b);
     */
    imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        const t = a.imul(b);
        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        const u = t.isub(c).iushrn(this.shift);
        let res = u;
        if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
        }
        else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
        }
        return res.forceRed(this);
    }
    /**
     * Performs the multiplication of two numbers in the Montgomery domain.
     *
     * @method mul
     * @param a - The first number to multiply.
     * @param b - The second number to multiply.
     * @returns The result of the multiplication.
     *
     * @example
     * const montMethod = new MontgomoryMethod(m);
     * const product = montMethod.mul(a, b);
     */
    mul(a, b) {
        if (a.isZero() || b.isZero())
            return new BigNumber_js_1.default(0).forceRed(this);
        const t = a.mul(b);
        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        const u = t.isub(c).iushrn(this.shift);
        let res = u;
        if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
        }
        else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
        }
        return res.forceRed(this);
    }
    /**
     * Calculates the modular multiplicative inverse of a number in the Montgomery domain.
     *
     * @method invm
     * @param a - The number to compute the modular multiplicative inverse of.
     * @returns The modular multiplicative inverse of 'a'.
     *
     * @example
     * const montMethod = new MontgomoryMethod(m);
     * const inverse = montMethod.invm(a);
     */
    invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        const res = this.imod(a._invmp(this.m).mul(this.r2));
        return res.forceRed(this);
    }
}
exports.default = MontgomoryMethod;

},{"./BigNumber.js":42,"./ReductionContext.js":56}],51:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modInvN = exports.modMulN = exports.modN = exports.scalarMultiplyWNAF = exports.jpNeg = exports.jpAdd = exports.jpDouble = exports.GY_BIGINT = exports.GX_BIGINT = exports.biModSqrt = exports.P_PLUS1_DIV4 = exports.biModPow = exports.biModSqr = exports.biModInv = exports.biModAdd = exports.biModMul = exports.biModSub = exports.biMod = exports.red = exports.MASK_256 = exports.N_BIGINT = exports.P_BIGINT = exports.BI_EIGHT = exports.BI_FOUR = exports.BI_THREE = exports.BI_TWO = exports.BI_ONE = exports.BI_ZERO = void 0;
const BasePoint_js_1 = __importDefault(require("./BasePoint.js"));
const JacobianPoint_js_1 = __importDefault(require("./JacobianPoint.js"));
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const utils_js_1 = require("./utils.js");
// -----------------------------------------------------------------------------
// BigInt helpers & constants (secp256k1) – hoisted so we don't recreate them on
// every Point.mul() call.
// -----------------------------------------------------------------------------
exports.BI_ZERO = 0n;
exports.BI_ONE = 1n;
exports.BI_TWO = 2n;
exports.BI_THREE = 3n;
exports.BI_FOUR = 4n;
exports.BI_EIGHT = 8n;
exports.P_BIGINT = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
exports.N_BIGINT = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
exports.MASK_256 = (1n << 256n) - 1n; // 0xffff…ffff (256 sones)
function red(x) {
    // first fold
    let hi = x >> 256n;
    x = (x & exports.MASK_256) + (hi << 32n) + hi * 977n;
    // second fold  (hi ≤ 2³² + 977 here, so one more pass is enough)
    hi = x >> 256n;
    x = (x & exports.MASK_256) + (hi << 32n) + hi * 977n;
    // final conditional subtraction
    if (x >= exports.P_BIGINT)
        x -= exports.P_BIGINT;
    return x;
}
exports.red = red;
const biMod = (a) => red((a % exports.P_BIGINT + exports.P_BIGINT) % exports.P_BIGINT);
exports.biMod = biMod;
const biModSub = (a, b) => (a >= b ? a - b : exports.P_BIGINT - (b - a));
exports.biModSub = biModSub;
const biModMul = (a, b) => red(a * b);
exports.biModMul = biModMul;
const biModAdd = (a, b) => red(a + b);
exports.biModAdd = biModAdd;
const biModInv = (a) => {
    let lm = exports.BI_ONE;
    let hm = exports.BI_ZERO;
    let low = (0, exports.biMod)(a);
    let high = exports.P_BIGINT;
    while (low > exports.BI_ONE) {
        const r = high / low;
        [lm, hm] = [hm - lm * r, lm];
        [low, high] = [high - low * r, low];
    }
    return (0, exports.biMod)(lm);
};
exports.biModInv = biModInv;
const biModSqr = (a) => (0, exports.biModMul)(a, a);
exports.biModSqr = biModSqr;
const biModPow = (base, exp) => {
    let result = exports.BI_ONE;
    base = (0, exports.biMod)(base);
    let e = exp;
    while (e > exports.BI_ZERO) {
        if ((e & exports.BI_ONE) === exports.BI_ONE)
            result = (0, exports.biModMul)(result, base);
        base = (0, exports.biModMul)(base, base);
        e >>= exports.BI_ONE;
    }
    return result;
};
exports.biModPow = biModPow;
exports.P_PLUS1_DIV4 = (exports.P_BIGINT + 1n) >> 2n;
const biModSqrt = (a) => {
    const r = (0, exports.biModPow)(a, exports.P_PLUS1_DIV4);
    return (0, exports.biModMul)(r, r) === (0, exports.biMod)(a) ? r : null;
};
exports.biModSqrt = biModSqrt;
const toBigInt = (x) => {
    if (BigNumber_js_1.default.isBN(x))
        return BigInt('0x' + x.toString(16));
    if (typeof x === 'string')
        return BigInt('0x' + x);
    if (Array.isArray(x))
        return BigInt('0x' + (0, utils_js_1.toHex)(x));
    return BigInt(x);
};
// Generator point coordinates as bigint constants
exports.GX_BIGINT = BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');
exports.GY_BIGINT = BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8');
// Cache for precomputed windowed tables keyed by 'window:x:y'
const WNAF_TABLE_CACHE = new Map();
const jpDouble = (P) => {
    const { X: X1, Y: Y1, Z: Z1 } = P;
    if (Y1 === exports.BI_ZERO)
        return { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO };
    const Y1sq = (0, exports.biModMul)(Y1, Y1);
    const S = (0, exports.biModMul)(exports.BI_FOUR, (0, exports.biModMul)(X1, Y1sq));
    const M = (0, exports.biModMul)(exports.BI_THREE, (0, exports.biModMul)(X1, X1));
    const X3 = (0, exports.biModSub)((0, exports.biModMul)(M, M), (0, exports.biModMul)(exports.BI_TWO, S));
    const Y3 = (0, exports.biModSub)((0, exports.biModMul)(M, (0, exports.biModSub)(S, X3)), (0, exports.biModMul)(exports.BI_EIGHT, (0, exports.biModMul)(Y1sq, Y1sq)));
    const Z3 = (0, exports.biModMul)(exports.BI_TWO, (0, exports.biModMul)(Y1, Z1));
    return { X: X3, Y: Y3, Z: Z3 };
};
exports.jpDouble = jpDouble;
const jpAdd = (P, Q) => {
    if (P.Z === exports.BI_ZERO)
        return Q;
    if (Q.Z === exports.BI_ZERO)
        return P;
    const Z1Z1 = (0, exports.biModMul)(P.Z, P.Z);
    const Z2Z2 = (0, exports.biModMul)(Q.Z, Q.Z);
    const U1 = (0, exports.biModMul)(P.X, Z2Z2);
    const U2 = (0, exports.biModMul)(Q.X, Z1Z1);
    const S1 = (0, exports.biModMul)(P.Y, (0, exports.biModMul)(Z2Z2, Q.Z));
    const S2 = (0, exports.biModMul)(Q.Y, (0, exports.biModMul)(Z1Z1, P.Z));
    const H = (0, exports.biModSub)(U2, U1);
    const r = (0, exports.biModSub)(S2, S1);
    if (H === exports.BI_ZERO) {
        if (r === exports.BI_ZERO)
            return (0, exports.jpDouble)(P);
        return { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO }; // Infinity
    }
    const HH = (0, exports.biModMul)(H, H);
    const HHH = (0, exports.biModMul)(H, HH);
    const V = (0, exports.biModMul)(U1, HH);
    const X3 = (0, exports.biModSub)((0, exports.biModSub)((0, exports.biModMul)(r, r), HHH), (0, exports.biModMul)(exports.BI_TWO, V));
    const Y3 = (0, exports.biModSub)((0, exports.biModMul)(r, (0, exports.biModSub)(V, X3)), (0, exports.biModMul)(S1, HHH));
    const Z3 = (0, exports.biModMul)(H, (0, exports.biModMul)(P.Z, Q.Z));
    return { X: X3, Y: Y3, Z: Z3 };
};
exports.jpAdd = jpAdd;
const jpNeg = (P) => {
    if (P.Z === exports.BI_ZERO)
        return P;
    return { X: P.X, Y: exports.P_BIGINT - P.Y, Z: P.Z };
};
exports.jpNeg = jpNeg;
// Fast windowed-NAF scalar multiplication (default window = 5) in Jacobian
// coordinates.  Returns Q = k * P0 as a JacobianPoint.
const scalarMultiplyWNAF = (k, P0, window = 5) => {
    const key = `${window}:${P0.x.toString(16)}:${P0.y.toString(16)}`;
    let tbl = WNAF_TABLE_CACHE.get(key);
    let P;
    if (tbl === undefined) {
        // Convert affine to Jacobian and pre-compute odd multiples
        const tblSize = 1 << (window - 1); // e.g. w=5 → 16 entries
        tbl = new Array(tblSize);
        P = { X: P0.x, Y: P0.y, Z: exports.BI_ONE };
        tbl[0] = P;
        const twoP = (0, exports.jpDouble)(P);
        for (let i = 1; i < tblSize; i++) {
            tbl[i] = (0, exports.jpAdd)(tbl[i - 1], twoP);
        }
        WNAF_TABLE_CACHE.set(key, tbl);
    }
    else {
        P = tbl[0];
    }
    // Build wNAF representation of k
    const wnaf = [];
    const wBig = 1n << BigInt(window);
    const wHalf = wBig >> 1n;
    let kTmp = k;
    while (kTmp > 0n) {
        if ((kTmp & exports.BI_ONE) === exports.BI_ZERO) {
            wnaf.push(0);
            kTmp >>= exports.BI_ONE;
        }
        else {
            let z = kTmp & (wBig - 1n); // kTmp mod 2^w
            if (z > wHalf)
                z -= wBig; // make it odd & within (-2^{w-1}, 2^{w-1})
            wnaf.push(Number(z));
            kTmp -= z;
            kTmp >>= exports.BI_ONE;
        }
    }
    // Accumulate from MSB to LSB
    let Q = { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO }; // infinity
    for (let i = wnaf.length - 1; i >= 0; i--) {
        Q = (0, exports.jpDouble)(Q);
        const di = wnaf[i];
        if (di !== 0) {
            const idx = Math.abs(di) >> 1; // (|di|-1)/2  because di is odd
            const addend = di > 0 ? tbl[idx] : (0, exports.jpNeg)(tbl[idx]);
            Q = (0, exports.jpAdd)(Q, addend);
        }
    }
    return Q;
};
exports.scalarMultiplyWNAF = scalarMultiplyWNAF;
const modN = (a) => {
    let r = a % exports.N_BIGINT;
    if (r < 0n)
        r += exports.N_BIGINT;
    return r;
};
exports.modN = modN;
const modMulN = (a, b) => (0, exports.modN)(a * b);
exports.modMulN = modMulN;
/** modular inverse modulo n with plain extended‑gcd (not constant‑time) */
const modInvN = (a) => {
    let lm = 1n;
    let hm = 0n;
    let low = (0, exports.modN)(a);
    let high = exports.N_BIGINT;
    while (low > 1n) {
        const q = high / low;
        [lm, hm] = [hm - lm * q, lm];
        [low, high] = [high - low * q, low];
    }
    return (0, exports.modN)(lm);
};
exports.modInvN = modInvN;
/**
 * `Point` class is a representation of an elliptic curve point with affine coordinates.
 * It extends the functionality of BasePoint and carries x, y coordinates of point on the curve.
 * It also introduces new methods for handling Point operations in elliptic curve.
 *
 * @class Point
 * @extends {BasePoint}
 *
 * @property x - The x-coordinate of the point.
 * @property y - The y-coordinate of the point.
 * @property inf - Flag to record if the point is at infinity in the Elliptic Curve.
 */
class Point extends BasePoint_js_1.default {
    /**
     * Creates a point object from a given Array. These numbers can represent coordinates in hex format, or points
     * in multiple established formats.
     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.
     *
     * @method fromDER
     * @static
     * @param bytes - The point representation number array.
     * @returns Returns a new point representing the given string.
     * @throws `Error` If the point number[] value has a wrong length.
     * @throws `Error` If the point format is unknown.
     *
     * @example
     * const derPoint = [ 2, 18, 123, 108, 125, 83, 1, 251, 164, 214, 16, 119, 200, 216, 210, 193, 251, 193, 129, 67, 97, 146, 210, 216, 77, 254, 18, 6, 150, 190, 99, 198, 128 ];
     * const point = Point.fromDER(derPoint);
     */
    static fromDER(bytes) {
        const len = 32;
        // uncompressed, hybrid-odd, hybrid-even
        if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
            bytes.length - 1 === 2 * len) {
            if (bytes[0] === 0x06) {
                if (bytes[bytes.length - 1] % 2 !== 0) {
                    throw new Error('Point string value is wrong length');
                }
            }
            else if (bytes[0] === 0x07) {
                if (bytes[bytes.length - 1] % 2 !== 1) {
                    throw new Error('Point string value is wrong length');
                }
            }
            const res = new Point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
            return res;
        }
        else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
            bytes.length - 1 === len) {
            return Point.fromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
        }
        throw new Error('Unknown point format');
    }
    /**
     * Creates a point object from a given string. This string can represent coordinates in hex format, or points
     * in multiple established formats.
     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.
     *
     * @method fromString
     * @static
     *
     * @param str The point representation string.
     * @returns Returns a new point representing the given string.
     * @throws `Error` If the point string value has a wrong length.
     * @throws `Error` If the point format is unknown.
     *
     * @example
     * const pointStr = 'abcdef';
     * const point = Point.fromString(pointStr);
     */
    static fromString(str) {
        const bytes = (0, utils_js_1.toArray)(str, 'hex');
        return Point.fromDER(bytes);
    }
    /**
     * Generates a point from an x coordinate and a boolean indicating whether the corresponding
     * y coordinate is odd.
     *
     * @method fromX
     * @static
     * @param x - The x coordinate of the point.
     * @param odd - Boolean indicating whether the corresponding y coordinate is odd or not.
     * @returns Returns the new point.
     * @throws `Error` If the point is invalid.
     *
     * @example
     * const xCoordinate = new BigNumber('10');
     * const point = Point.fromX(xCoordinate, true);
     */
    static fromX(x, odd) {
        let xBigInt = toBigInt(x);
        xBigInt = (0, exports.biMod)(xBigInt);
        const y2 = (0, exports.biModAdd)((0, exports.biModMul)((0, exports.biModSqr)(xBigInt), xBigInt), 7n);
        const y = (0, exports.biModSqrt)(y2);
        if (y === null)
            throw new Error('Invalid point');
        let yBig = y;
        if ((yBig & exports.BI_ONE) !== (odd ? exports.BI_ONE : exports.BI_ZERO)) {
            yBig = (0, exports.biModSub)(exports.P_BIGINT, yBig);
        }
        const xBN = new BigNumber_js_1.default(xBigInt.toString(16), 16);
        const yBN = new BigNumber_js_1.default(yBig.toString(16), 16);
        return new Point(xBN, yBN);
    }
    /**
     * Generates a point from a serialized JSON object. The function accounts for different options in the JSON object,
     * including precomputed values for optimization of EC operations, and calls another helper function to turn nested
     * JSON points into proper Point objects.
     *
     * @method fromJSON
     * @static
     * @param obj - An object or array that holds the data for the point.
     * @param isRed - A boolean to direct how the Point is constructed from the JSON object.
     * @returns Returns a new point based on the deserialized JSON object.
     *
     * @example
     * const serializedPoint = '{"x":52,"y":15}';
     * const point = Point.fromJSON(serializedPoint, true);
     */
    static fromJSON(obj, isRed) {
        if (typeof obj === 'string') {
            obj = JSON.parse(obj);
        }
        const res = new Point(obj[0], obj[1], isRed);
        if (typeof obj[2] !== 'object') {
            return res;
        }
        const obj2point = (obj) => {
            return new Point(obj[0], obj[1], isRed);
        };
        const pre = obj[2];
        res.precomputed = {
            beta: null,
            doubles: typeof pre.doubles === 'object' && pre.doubles !== null
                ? {
                    step: pre.doubles.step,
                    points: [res].concat(pre.doubles.points.map(obj2point))
                }
                : undefined,
            naf: typeof pre.naf === 'object' && pre.naf !== null
                ? {
                    wnd: pre.naf.wnd,
                    points: [res].concat(pre.naf.points.map(obj2point))
                }
                : undefined
        };
        return res;
    }
    /**
     * @constructor
     * @param x - The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an "Infinity" point is constructed.
     * @param y - The y-coordinate of the point, similar to x.
     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.
     *
     * @example
     * new Point('abc123', 'def456');
     * new Point(null, null); // Generates Infinity point.
     */
    constructor(x, y, isRed = true) {
        super('affine');
        this.precomputed = null;
        if (x === null && y === null) {
            this.x = null;
            this.y = null;
            this.inf = true;
        }
        else {
            if (!BigNumber_js_1.default.isBN(x)) {
                x = new BigNumber_js_1.default(x, 16);
            }
            this.x = x;
            if (!BigNumber_js_1.default.isBN(y)) {
                y = new BigNumber_js_1.default(y, 16);
            }
            this.y = y;
            // Force redgomery representation when loading from JSON
            if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
            }
            if (this.x.red === null) {
                this.x = this.x.toRed(this.curve.red);
            }
            if (this.y.red === null) {
                this.y = this.y.toRed(this.curve.red);
            }
            this.inf = false;
        }
    }
    /**
     * Validates if a point belongs to the curve. Follows the short Weierstrass
     * equation for elliptic curves: y^2 = x^3 + ax + b.
     *
     * @method validate
     * @returns {boolean} true if the point is on the curve, false otherwise.
     *
     * @example
     * const aPoint = new Point(x, y);
     * const isValid = aPoint.validate();
     */
    validate() {
        return this.curve.validate(this);
    }
    /**
     * Encodes the coordinates of a point into an array or a hexadecimal string.
     * The details of encoding are determined by the optional compact and enc parameters.
     *
     * @method encode
     * @param compact - If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.
     * @param enc - Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.
     * @throws Will throw an error if the specified encoding method is not recognized. Expects 'hex'.
     * @returns If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.
     *
     * @example
     * const aPoint = new Point(x, y);
     * const encodedPointArray = aPoint.encode();
     * const encodedPointHex = aPoint.encode(true, 'hex');
     */
    encode(compact = true, enc) {
        const len = this.curve.p.byteLength();
        const x = this.getX().toArray('be', len);
        let res;
        if (compact) {
            res = [this.getY().isEven() ? 0x02 : 0x03].concat(x);
        }
        else {
            res = [0x04].concat(x, this.getY().toArray('be', len));
        }
        if (enc !== 'hex') {
            return res;
        }
        else {
            return (0, utils_js_1.toHex)(res);
        }
    }
    /**
     * Converts the point coordinates to a hexadecimal string. A wrapper method
     * for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.
     *
     * @method toString
     * @returns {string} A hexadecimal string representation of the point coordinates.
     *
     * @example
     * const aPoint = new Point(x, y);
     * const stringPoint = aPoint.toString();
     */
    toString() {
        return this.encode(true, 'hex');
    }
    /**
     * Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.
     *
     * @method toJSON
     * @returns An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.
     *
     * @example
     * const aPoint = new Point(x, y);
     * const jsonPoint = aPoint.toJSON();
     */
    toJSON() {
        if (this.precomputed == null) {
            return [this.x, this.y];
        }
        return [
            this.x,
            this.y,
            typeof this.precomputed === 'object' && this.precomputed !== null
                ? {
                    doubles: this.precomputed.doubles != null
                        ? {
                            step: this.precomputed.doubles.step,
                            points: this.precomputed.doubles.points.slice(1)
                        }
                        : undefined,
                    naf: this.precomputed.naf != null
                        ? {
                            wnd: this.precomputed.naf.wnd,
                            points: this.precomputed.naf.points.slice(1)
                        }
                        : undefined
                }
                : undefined
        ];
    }
    /**
     * Provides the point coordinates in a human-readable string format for debugging purposes.
     *
     * @method inspect
     * @returns String of the format '<EC Point x: x-coordinate y: y-coordinate>', or '<EC Point Infinity>' if the point is at infinity.
     *
     * @example
     * const aPoint = new Point(x, y);
     * console.log(aPoint.inspect());
     */
    inspect() {
        if (this.isInfinity()) {
            return '<EC Point Infinity>';
        }
        return ('<EC Point x: ' +
            (this.x?.fromRed()?.toString(16, 2) ?? 'undefined') +
            ' y: ' +
            (this.y?.fromRed()?.toString(16, 2) ?? 'undefined') +
            '>');
    }
    /**
     * Checks if the point is at infinity.
     * @method isInfinity
     * @returns Returns whether or not the point is at infinity.
     *
     * @example
     * const p = new Point(null, null);
     * console.log(p.isInfinity()); // outputs: true
     */
    isInfinity() {
        return this.inf;
    }
    /**
     * Adds another Point to this Point, returning a new Point.
     *
     * @method add
     * @param p - The Point to add to this one.
     * @returns A new Point that results from the addition.
     *
     * @example
     * const p1 = new Point(1, 2);
     * const p2 = new Point(2, 3);
     * const result = p1.add(p2);
     */
    add(p) {
        // O + P = P
        if (this.inf) {
            return p;
        }
        // P + O = P
        if (p.inf) {
            return this;
        }
        // P + P = 2P
        if (this.eq(p)) {
            return this.dbl();
        }
        // P + (-P) = O
        if (this.neg().eq(p)) {
            return new Point(null, null);
        }
        // P + Q = O
        if (this.x?.cmp(p.x ?? new BigNumber_js_1.default(0)) === 0) {
            return new Point(null, null);
        }
        const P1 = {
            X: BigInt('0x' + this.x.fromRed().toString(16)),
            Y: BigInt('0x' + this.y.fromRed().toString(16)),
            Z: exports.BI_ONE
        };
        const Q1 = {
            X: BigInt('0x' + p.x.fromRed().toString(16)),
            Y: BigInt('0x' + p.y.fromRed().toString(16)),
            Z: exports.BI_ONE
        };
        const R = (0, exports.jpAdd)(P1, Q1);
        if (R.Z === exports.BI_ZERO)
            return new Point(null, null);
        const zInv = (0, exports.biModInv)(R.Z);
        const zInv2 = (0, exports.biModMul)(zInv, zInv);
        const xRes = (0, exports.biModMul)(R.X, zInv2);
        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));
        return new Point(xRes.toString(16), yRes.toString(16));
    }
    /**
     * Doubles the current point.
     *
     * @method dbl
     *
     * @example
     * const P = new Point('123', '456');
     * const result = P.dbl();
     * */
    dbl() {
        if (this.inf)
            return this;
        if (this.x === null || this.y === null) {
            throw new Error('Point coordinates cannot be null');
        }
        const X = BigInt('0x' + this.x.fromRed().toString(16));
        const Y = BigInt('0x' + this.y.fromRed().toString(16));
        if (Y === exports.BI_ZERO)
            return new Point(null, null);
        const R = (0, exports.jpDouble)({ X, Y, Z: exports.BI_ONE });
        const zInv = (0, exports.biModInv)(R.Z);
        const zInv2 = (0, exports.biModMul)(zInv, zInv);
        const xRes = (0, exports.biModMul)(R.X, zInv2);
        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));
        return new Point(xRes.toString(16), yRes.toString(16));
    }
    /**
     * Returns X coordinate of point
     *
     * @example
     * const P = new Point('123', '456');
     * const x = P.getX();
     */
    getX() {
        return (this.x ?? new BigNumber_js_1.default(0)).fromRed();
    }
    /**
     * Returns X coordinate of point
     *
     * @example
     * const P = new Point('123', '456');
     * const x = P.getX();
     */
    getY() {
        return (this.y ?? new BigNumber_js_1.default(0)).fromRed();
    }
    /**
     * Multiplies this Point by a scalar value, returning a new Point.
     *
     * @method mul
     * @param k - The scalar value to multiply this Point by.
     * @returns  A new Point that results from the multiplication.
     *
     * @example
     * const p = new Point(1, 2);
     * const result = p.mul(2); // this doubles the Point
     */
    mul(k) {
        if (!BigNumber_js_1.default.isBN(k)) {
            k = new BigNumber_js_1.default(k, 16);
        }
        k = k;
        if (this.inf) {
            return this;
        }
        let kBig = BigInt('0x' + k.toString(16));
        const isNeg = kBig < exports.BI_ZERO;
        if (isNeg)
            kBig = -kBig;
        kBig = (0, exports.biMod)(kBig);
        if (kBig === exports.BI_ZERO) {
            return new Point(null, null);
        }
        if (this.x === null || this.y === null) {
            throw new Error('Point coordinates cannot be null');
        }
        let Px;
        let Py;
        if (this === this.curve.g) {
            Px = exports.GX_BIGINT;
            Py = exports.GY_BIGINT;
        }
        else {
            Px = BigInt('0x' + this.x.fromRed().toString(16));
            Py = BigInt('0x' + this.y.fromRed().toString(16));
        }
        const R = (0, exports.scalarMultiplyWNAF)(kBig, { x: Px, y: Py });
        if (R.Z === exports.BI_ZERO) {
            return new Point(null, null);
        }
        const zInv = (0, exports.biModInv)(R.Z);
        const zInv2 = (0, exports.biModMul)(zInv, zInv);
        const xRes = (0, exports.biModMul)(R.X, zInv2);
        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));
        const xBN = new BigNumber_js_1.default(xRes.toString(16), 16);
        const yBN = new BigNumber_js_1.default(yRes.toString(16), 16);
        const result = new Point(xBN, yBN);
        if (isNeg) {
            return result.neg();
        }
        return result;
    }
    /**
     * Performs a multiplication and addition operation in a single step.
     * Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.
     *
     * @method mulAdd
     * @param k1 - The scalar value to multiply this Point by.
     * @param p2 - The other Point to be involved in the operation.
     * @param k2 - The scalar value to multiply the Point p2 by.
     * @returns A Point that results from the combined multiplication and addition operations.
     *
     * @example
     * const p1 = new Point(1, 2);
     * const p2 = new Point(2, 3);
     * const result = p1.mulAdd(2, p2, 3);
     */
    mulAdd(k1, p2, k2) {
        const points = [this, p2];
        const coeffs = [k1, k2];
        return this._endoWnafMulAdd(points, coeffs);
    }
    /**
     * Performs the Jacobian multiplication and addition operation in a single
     * step. Instead of returning a regular Point, the result is a JacobianPoint.
     *
     * @method jmulAdd
     * @param k1 - The scalar value to multiply this Point by.
     * @param p2 - The other Point to be involved in the operation
     * @param k2 - The scalar value to multiply the Point p2 by.
     * @returns A JacobianPoint that results from the combined multiplication and addition operation.
     *
     * @example
     * const p1 = new Point(1, 2);
     * const p2 = new Point(2, 3);
     * const result = p1.jmulAdd(2, p2, 3);
     */
    jmulAdd(k1, p2, k2) {
        const points = [this, p2];
        const coeffs = [k1, k2];
        return this._endoWnafMulAdd(points, coeffs, true);
    }
    /**
     * Checks if the Point instance is equal to another given Point.
     *
     * @method eq
     * @param p - The Point to be checked if equal to the current instance.
     *
     * @returns Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.
     *
     * @example
     * const p1 = new Point(5, 20);
     * const p2 = new Point(5, 20);
     * const areEqual = p1.eq(p2); // returns true
     */
    eq(p) {
        return (this === p ||
            (this.inf === p.inf &&
                (this.inf || ((this.x ?? new BigNumber_js_1.default(0)).cmp(p.x ?? new BigNumber_js_1.default(0)) === 0 && (this.y ?? new BigNumber_js_1.default(0)).cmp(p.y ?? new BigNumber_js_1.default(0)) === 0))));
    }
    /**
     * Negate a point. The negation of a point P is the mirror of P about x-axis.
     *
     * @method neg
     *
     * @example
     * const P = new Point('123', '456');
     * const result = P.neg();
     */
    neg(_precompute) {
        if (this.inf) {
            return this;
        }
        const res = new Point(this.x, (this.y ?? new BigNumber_js_1.default(0)).redNeg());
        if (_precompute === true && this.precomputed != null) {
            const pre = this.precomputed;
            const negate = (p) => p.neg();
            res.precomputed = {
                naf: pre.naf != null
                    ? {
                        wnd: pre.naf.wnd,
                        points: pre.naf.points.map(negate)
                    }
                    : undefined,
                doubles: pre.doubles != null
                    ? {
                        step: pre.doubles.step,
                        points: pre.doubles.points.map((p) => p.neg())
                    }
                    : undefined,
                beta: undefined
            };
        }
        return res;
    }
    /**
     * Performs the "doubling" operation on the Point a given number of times.
     * This is used in elliptic curve operations to perform multiplication by 2, multiple times.
     * If the point is at infinity, it simply returns the point because doubling
     * a point at infinity is still infinity.
     *
     * @method dblp
     * @param k - The number of times the "doubling" operation is to be performed on the Point.
     * @returns The Point after 'k' "doubling" operations have been performed.
     *
     * @example
     * const p = new Point(5, 20);
     * const doubledPoint = p.dblp(10); // returns the point after "doubled" 10 times
     */
    dblp(k) {
        /* eslint-disable @typescript-eslint/no-this-alias */
        let r = this;
        for (let i = 0; i < k; i++) {
            r = r.dbl();
        }
        return r;
    }
    /**
     * Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point
     * will also be at infinity.
     *
     * @method toJ
     * @returns Returns a new Jacobian point based on the current point.
     *
     * @example
     * const point = new Point(xCoordinate, yCoordinate);
     * const jacobianPoint = point.toJ();
     */
    toJ() {
        if (this.inf) {
            return new JacobianPoint_js_1.default(null, null, null);
        }
        const res = new JacobianPoint_js_1.default(this.x, this.y, this.curve.one);
        return res;
    }
    _getBeta() {
        if (typeof this.curve.endo !== 'object') {
            return;
        }
        const pre = this.precomputed;
        if (typeof pre === 'object' &&
            pre !== null &&
            typeof pre.beta === 'object' &&
            pre.beta !== null) {
            return pre.beta;
        }
        const beta = new Point((this.x ?? new BigNumber_js_1.default(0)).redMul(this.curve.endo.beta), this.y);
        if (pre != null) {
            const curve = this.curve;
            const endoMul = (p) => {
                if (p.x === null) {
                    throw new Error('p.x is null');
                }
                if (curve.endo === undefined || curve.endo === null) {
                    throw new Error('curve.endo is undefined');
                }
                return new Point(p.x.redMul(curve.endo.beta), p.y);
            };
            pre.beta = beta;
            beta.precomputed = {
                beta: null,
                naf: pre.naf != null
                    ? {
                        wnd: pre.naf.wnd,
                        points: pre.naf.points.map(endoMul)
                    }
                    : undefined,
                doubles: pre.doubles != null
                    ? {
                        step: pre.doubles.step,
                        points: pre.doubles.points.map(endoMul)
                    }
                    : undefined
            };
        }
        return beta;
    }
    _fixedNafMul(k) {
        if (typeof this.precomputed !== 'object' || this.precomputed === null) {
            throw new Error('_fixedNafMul requires precomputed values for the point');
        }
        const doubles = this._getDoubles();
        const naf = this.curve.getNAF(k, 1, this.curve._bitLength);
        let I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        // Translate into more windowed form
        const repr = [];
        for (let j = 0; j < naf.length; j += doubles.step) {
            let nafW = 0;
            for (let k = j + doubles.step - 1; k >= j; k--) {
                nafW = (nafW << 1) + naf[k];
            }
            repr.push(nafW);
        }
        let a = new JacobianPoint_js_1.default(null, null, null);
        let b = new JacobianPoint_js_1.default(null, null, null);
        for (let i = I; i > 0; i--) {
            for (let j = 0; j < repr.length; j++) {
                const nafW = repr[j];
                if (nafW === i) {
                    b = b.mixedAdd(doubles.points[j]);
                }
                else if (nafW === -i) {
                    b = b.mixedAdd(doubles.points[j].neg());
                }
            }
            a = a.add(b);
        }
        return a.toP();
    }
    _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        const wndWidth = this.curve._wnafT1.map(num => num.toNumber()); // Convert BigNumber to number
        const wnd = this.curve._wnafT2.map(() => []); // Initialize as empty Point[][] array
        const naf = this.curve._wnafT3.map(() => []); // Initialize as empty number[][] array
        // Fill all arrays
        let max = 0;
        for (let i = 0; i < len; i++) {
            const p = points[i];
            const nafPoints = p._getNAFPoints(defW);
            wndWidth[i] = nafPoints.wnd; // Ensure correct type
            wnd[i] = nafPoints.points; // Ensure correct type
        }
        // Comb small window NAFs
        for (let i = len - 1; i >= 1; i -= 2) {
            const a = i - 1;
            const b = i;
            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = this.curve.getNAF(coeffs[a], wndWidth[a], this.curve._bitLength);
                naf[b] = this.curve.getNAF(coeffs[b], wndWidth[b], this.curve._bitLength);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
            }
            const comb = [
                points[a] /* 1 */,
                null /* 3 */,
                null /* 5 */,
                points[b] /* 7 */
            ];
            // Try to avoid Projective points, if possible
            if ((points[a].y ?? new BigNumber_js_1.default(0)).cmp(points[b].y ?? new BigNumber_js_1.default(0)) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }
            else if ((points[a].y ?? new BigNumber_js_1.default(0)).cmp((points[b].y ?? new BigNumber_js_1.default(0)).redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
            }
            else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }
            const index = [
                -3 /* -1 -1 */, -1 /* -1 0 */, -5 /* -1 1 */, -7 /* 0 -1 */,
                0 /* 0 0 */, 7 /* 0 1 */, 5 /* 1 -1 */, 1 /* 1 0 */, 3 /* 1 1 */
            ];
            const jsf = this.curve.getJSF(coeffs[a], coeffs[b]);
            max = Math.max(jsf[0].length, max);
            naf[a] = new Array(max);
            naf[b] = new Array(max);
            for (let j = 0; j < max; j++) {
                const ja = jsf[0][j] | 0;
                const jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
            }
        }
        let acc = new JacobianPoint_js_1.default(null, null, null);
        const tmp = this.curve._wnafT4;
        for (let i = max; i >= 0; i--) {
            let k = 0;
            while (i >= 0) {
                let zero = true;
                for (let j = 0; j < len; j++) {
                    tmp[j] = new BigNumber_js_1.default(typeof naf[j][i] === 'number' ? naf[j][i] : 0); // Ensure type consistency
                    if (!tmp[j].isZero()) { // Use BigNumber's built-in comparison
                        zero = false;
                    }
                }
                if (!zero) {
                    break;
                }
                k++;
                i--;
            }
            if (i >= 0) {
                k++;
            }
            acc = acc.dblp(k);
            if (i < 0) {
                break;
            }
            const one = new BigNumber_js_1.default(1);
            const two = new BigNumber_js_1.default(2);
            for (let j = 0; j < len; j++) {
                const z = tmp[j];
                let p;
                if (z.cmpn(0) === 0) { // Check if z is 0
                    continue;
                }
                else if (!z.isNeg()) { // If z is positive
                    p = wnd[j][z.sub(one).div(two).toNumber()];
                }
                else { // If z is negative
                    p = wnd[j][z.neg().sub(one).div(two).toNumber()].neg();
                }
                if (p.type === 'affine') {
                    acc = acc.mixedAdd(p);
                }
                else {
                    acc = acc.add(p);
                }
            }
        }
        // Zeroify references
        for (let i = 0; i < len; i++) {
            wnd[i] = [];
        }
        if (jacobianResult === true) {
            return acc;
        }
        else {
            return acc.toP();
        }
    }
    _endoWnafMulAdd(points, coeffs, // Explicitly type coeffs
    jacobianResult) {
        const npoints = new Array(points.length * 2);
        const ncoeffs = new Array(points.length * 2);
        let i;
        for (i = 0; i < points.length; i++) {
            const split = this.curve._endoSplit(coeffs[i]);
            let p = points[i];
            let beta = p._getBeta() ?? new Point(null, null);
            if (split.k1.negative !== 0) {
                split.k1.ineg();
                p = p.neg(true);
            }
            if (split.k2.negative !== 0) {
                split.k2.ineg();
                beta = beta.neg(true);
            }
            npoints[i * 2] = p;
            npoints[i * 2 + 1] = beta;
            ncoeffs[i * 2] = split.k1;
            ncoeffs[i * 2 + 1] = split.k2;
        }
        const res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        // Clean-up references to points and coefficients
        for (let j = 0; j < i * 2; j++) {
            npoints[j] = null;
            ncoeffs[j] = null;
        }
        return res;
    }
    _hasDoubles(k) {
        if (this.precomputed == null) {
            return false;
        }
        const doubles = this.precomputed.doubles;
        if (typeof doubles !== 'object') {
            return false;
        }
        return (doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step));
    }
    _getDoubles(step, power) {
        if (typeof this.precomputed === 'object' &&
            this.precomputed !== null &&
            typeof this.precomputed.doubles === 'object' &&
            this.precomputed.doubles !== null) {
            return this.precomputed.doubles;
        }
        const doubles = [this];
        /* eslint-disable @typescript-eslint/no-this-alias */
        let acc = this;
        for (let i = 0; i < (power ?? 0); i += (step ?? 1)) {
            for (let j = 0; j < (step ?? 1); j++) {
                acc = acc.dbl();
            }
            doubles.push(acc);
        }
        return {
            step: step ?? 1,
            points: doubles
        };
    }
    _getNAFPoints(wnd) {
        if (typeof this.precomputed === 'object' &&
            this.precomputed !== null &&
            typeof this.precomputed.naf === 'object' &&
            this.precomputed.naf !== null) {
            return this.precomputed.naf;
        }
        const res = [this];
        const max = (1 << wnd) - 1;
        const dbl = max === 1 ? null : this.dbl();
        for (let i = 1; i < max; i++) {
            if (dbl !== null) {
                res[i] = res[i - 1].add(dbl);
            }
        }
        return {
            wnd,
            points: res
        };
    }
}
exports.default = Point;

},{"./BasePoint.js":41,"./BigNumber.js":42,"./JacobianPoint.js":47,"./utils.js":62}],52:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointInFiniteField = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const Random_js_1 = __importDefault(require("./Random.js"));
const utils_js_1 = require("./utils.js");
class PointInFiniteField {
    constructor(x, y) {
        const P = new Curve_js_1.default().p; // arithmetic is mod P
        this.x = x.umod(P);
        this.y = y.umod(P);
    }
    toString() {
        return (0, utils_js_1.toBase58)(this.x.toArray()) + '.' + (0, utils_js_1.toBase58)(this.y.toArray());
    }
    static fromString(str) {
        const [x, y] = str.split('.');
        return new PointInFiniteField(new BigNumber_js_1.default((0, utils_js_1.fromBase58)(x)), new BigNumber_js_1.default((0, utils_js_1.fromBase58)(y)));
    }
}
exports.PointInFiniteField = PointInFiniteField;
/**
 * Polynomial class
 *
 * This class is used to create a polynomial with a given threshold and a private key.
 * The polynomial is used to create shares of the private key.
 *
 * @param key - The private key to split
 * @param threshold - The number of shares required to recombine the private key
 *
 * @example
 * const key = new PrivateKey()
 * const threshold = 2
 * const polynomial = new Polynomial(key, threshold)
 *
 */
class Polynomial {
    constructor(points, threshold) {
        this.points = points;
        this.threshold = threshold ?? points.length; // ✅ Handles undefined safely
    }
    static fromPrivateKey(key, threshold) {
        const P = new Curve_js_1.default().p; // arithmetic is mod P
        // The key is the y-intercept of the polynomial where x=0.
        const points = [
            new PointInFiniteField(new BigNumber_js_1.default(0), new BigNumber_js_1.default(key.toArray()))
        ];
        // The other values are random
        for (let i = 1; i < threshold; i++) {
            const randomX = new BigNumber_js_1.default((0, Random_js_1.default)(32)).umod(P);
            const randomY = new BigNumber_js_1.default((0, Random_js_1.default)(32)).umod(P);
            points.push(new PointInFiniteField(randomX, randomY));
        }
        return new Polynomial(points);
    }
    // Evaluate the polynomial at x by using Lagrange interpolation
    valueAt(x) {
        const P = new Curve_js_1.default().p; // arithmetic is mod P
        let y = new BigNumber_js_1.default(0);
        for (let i = 0; i < this.threshold; i++) {
            let term = this.points[i].y;
            for (let j = 0; j < this.threshold; j++) {
                if (i !== j) {
                    const xj = this.points[j].x;
                    const xi = this.points[i].x;
                    const numerator = x.sub(xj).umod(P);
                    const denominator = xi.sub(xj).umod(P);
                    const denominatorInverse = denominator.invm(P);
                    const fraction = numerator.mul(denominatorInverse).umod(P);
                    term = term.mul(fraction).umod(P);
                }
            }
            y = y.add(term).umod(P);
        }
        return y;
    }
}
exports.default = Polynomial;

},{"./BigNumber.js":42,"./Curve.js":43,"./Random.js":55,"./utils.js":62}],53:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyShares = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const PublicKey_js_1 = __importDefault(require("./PublicKey.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const ECDSA_js_1 = require("./ECDSA.js");
const Hash_js_1 = require("./Hash.js");
const Random_js_1 = __importDefault(require("./Random.js"));
const utils_js_1 = require("./utils.js");
const Polynomial_js_1 = __importStar(require("./Polynomial.js"));
/**
 * @class KeyShares
 *
 * This class is used to store the shares of a private key.
 *
 * @param shares - An array of shares
 * @param threshold - The number of shares required to recombine the private key
 *
 * @returns KeyShares
 *
 * @example
 * const key = PrivateKey.fromShares(shares)
 *
 */
class KeyShares {
    constructor(points, threshold, integrity) {
        this.points = points;
        this.threshold = threshold;
        this.integrity = integrity;
    }
    static fromBackupFormat(shares) {
        let threshold = 0;
        let integrity = '';
        const points = shares.map((share, idx) => {
            const shareParts = share.split('.');
            if (shareParts.length !== 4) {
                throw new Error('Invalid share format in share ' +
                    idx.toString() +
                    '. Expected format: "x.y.t.i" - received ' +
                    share);
            }
            const [x, y, t, i] = shareParts;
            if (t === undefined)
                throw new Error('Threshold not found in share ' + idx.toString());
            if (i === undefined)
                throw new Error('Integrity not found in share ' + idx.toString());
            const tInt = parseInt(t);
            if (idx !== 0 && threshold !== tInt) {
                throw new Error('Threshold mismatch in share ' + idx.toString());
            }
            if (idx !== 0 && integrity !== i) {
                throw new Error('Integrity mismatch in share ' + idx.toString());
            }
            threshold = tInt;
            integrity = i;
            return Polynomial_js_1.PointInFiniteField.fromString([x, y].join('.'));
        });
        return new KeyShares(points, threshold, integrity);
    }
    toBackupFormat() {
        return this.points.map((share) => share.toString() + '.' + this.threshold.toString() + '.' + this.integrity);
    }
}
exports.KeyShares = KeyShares;
/**
 * Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.
 *
 * The `PrivateKey` class extends from the `BigNumber` class. It offers methods to create signatures, verify them,
 * create a corresponding public key and derive a shared secret from a public key.
 *
 * @extends {BigNumber}
 * @see {@link BigNumber} for more information on BigNumber.
 */
class PrivateKey extends BigNumber_js_1.default {
    /**
     * Generates a private key randomly.
     *
     * @method fromRandom
     * @static
     * @returns The newly generated Private Key.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     */
    static fromRandom() {
        return new PrivateKey((0, Random_js_1.default)(32));
    }
    /**
     * Generates a private key from a string.
     *
     * @method fromString
     * @static
     * @param str - The string to generate the private key from.
     * @param base - The base of the string.
     * @returns The generated Private Key.
     * @throws Will throw an error if the string is not valid.
     **/
    static fromString(str, base = 'hex') {
        return new PrivateKey(super.fromString(str, base).toArray());
    }
    /**
     * Generates a private key from a hexadecimal string.
     *
     * @method fromHex
     * @static
     * @param {string} str - The hexadecimal string representing the private key. The string must represent a valid private key in big-endian format.
     * @returns {PrivateKey} The generated Private Key instance.
     * @throws {Error} If the string is not a valid hexadecimal or represents an invalid private key.
     **/
    static fromHex(str) {
        return new PrivateKey(super.fromHex(str, 'big'));
    }
    /**
     * Generates a private key from a WIF (Wallet Import Format) string.
     *
     * @method fromWif
     * @static
     * @param wif - The WIF string to generate the private key from.
     * @param base - The base of the string.
     * @returns The generated Private Key.
     * @throws Will throw an error if the string is not a valid WIF.
     **/
    static fromWif(wif, prefixLength = 1) {
        const decoded = (0, utils_js_1.fromBase58Check)(wif, undefined, prefixLength);
        if (decoded.data.length !== 33) {
            throw new Error('Invalid WIF length');
        }
        if (decoded.data[32] !== 1) {
            throw new Error('Invalid WIF padding');
        }
        return new PrivateKey(decoded.data.slice(0, 32));
    }
    /**
     * @constructor
     *
     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.
     *
     * @param base - The base of number provided. By default is 10. Ignored if number is BigNumber.
     *
     * @param endian - The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.
     *
     * @param modN - Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw new Error('Input is out of field'). If 'nocheck', assumes input is in field.
     *
     * @example
     * import PrivateKey from './PrivateKey';
     * import BigNumber from './BigNumber';
     * const privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));
     */
    constructor(number = 0, base = 10, endian = 'be', modN = 'apply') {
        if (number instanceof BigNumber_js_1.default) {
            super();
            number.copy(this);
        }
        else {
            super(number, base, endian);
        }
        if (modN !== 'nocheck') {
            const check = this.checkInField();
            if (!check.inField) {
                if (modN === 'error') {
                    throw new Error('Input is out of field');
                }
                // Force the PrivateKey BigNumber value to lie in the field limited by curve.n
                BigNumber_js_1.default.move(this, check.modN);
            }
        }
    }
    /**
     * A utility function to check that the value of this PrivateKey lies in the field limited by curve.n
     * @returns { inField, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.
     */
    checkInField() {
        const curve = new Curve_js_1.default();
        const modN = this.mod(curve.n);
        const inField = this.cmp(modN) === 0;
        return { inField, modN };
    }
    /**
     * @returns true if the PrivateKey's current BigNumber value lies in the field limited by curve.n
     */
    isValid() {
        return this.checkInField().inField;
    }
    /**
     * Signs a message using the private key.
     *
     * @method sign
     * @param msg - The message (array of numbers or string) to be signed.
     * @param enc - If 'hex' the string will be treated as hex, utf8 otherwise.
     * @param forceLowS - If true (the default), the signature will be forced to have a low S value.
     * @param customK — If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.
     * @returns A digital signature generated from the hash of the message and the private key.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const signature = privateKey.sign('Hello, World!');
     */
    sign(msg, enc, forceLowS = true, customK) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.sign)(msgHash, this, forceLowS, customK);
    }
    /**
     * Verifies a message's signature using the public key associated with this private key.
     *
     * @method verify
     * @param msg - The original message which has been signed.
     * @param sig - The signature to be verified.
     * @param enc - The data encoding method.
     * @returns Whether or not the signature is valid.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const signature = privateKey.sign('Hello, World!');
     * const isSignatureValid = privateKey.verify('Hello, World!', signature);
     */
    verify(msg, sig, enc) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.verify)(msgHash, sig, this.toPublicKey());
    }
    /**
     * Converts the private key to its corresponding public key.
     *
     * The public key is generated by multiplying the base point G of the curve and the private key.
     *
     * @method toPublicKey
     * @returns The generated PublicKey.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const publicKey = privateKey.toPublicKey();
     */
    toPublicKey() {
        const c = new Curve_js_1.default();
        const p = c.g.mul(this);
        return new PublicKey_js_1.default(p.x, p.y);
    }
    /**
     * Converts the private key to a Wallet Import Format (WIF) string.
     *
     * Base58Check encoding is used for encoding the private key.
     * The prefix
     *
     * @method toWif
     * @returns The WIF string.
     *
     * @param prefix defaults to [0x80] for mainnet, set it to [0xef] for testnet.
     *
     * @throws Error('Value is out of field') if current BigNumber value is out of field limited by curve.n
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const wif = privateKey.toWif();
     * const testnetWif = privateKey.toWif([0xef]);
     */
    toWif(prefix = [0x80]) {
        if (!this.isValid()) {
            throw new Error('Value is out of field');
        }
        return (0, utils_js_1.toBase58Check)([...this.toArray('be', 32), 1], prefix);
    }
    /**
     * Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type.
     * Defaults to P2PKH for mainnet, otherwise known as a "Bitcoin Address".
     *
     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'
     *
     * @returns Returns the address encoding associated with the hash of the public key associated with this private key.
     *
     * @example
     * const address = privkey.toAddress()
     * const address = privkey.toAddress('mainnet')
     * const testnetAddress = privkey.toAddress([0x6f])
     * const testnetAddress = privkey.toAddress('testnet')
     */
    toAddress(prefix = [0x00]) {
        return this.toPublicKey().toAddress(prefix);
    }
    /**
     * Converts this PrivateKey to a hexadecimal string.
     *
     * @method toHex
     * @param length - The minimum length of the hex string
     * @returns Returns a string representing the hexadecimal value of this BigNumber.
     *
     * @example
     * const bigNumber = new BigNumber(255);
     * const hex = bigNumber.toHex();
     */
    toHex() {
        return super.toHex(32);
    }
    /**
     * Converts this PrivateKey to a string representation.
     *
     * @method toString
     * @param {number | 'hex'} [base='hex'] - The base for representing the number. Default is hexadecimal ('hex').
     * @param {number} [padding=64] - The minimum number of digits for the output string. Default is 64, ensuring a 256-bit representation in hexadecimal.
     * @returns {string} A string representation of the PrivateKey in the specified base, padded to the specified length.
     *
     **/
    toString(base = 'hex', padding = 64) {
        return super.toString(base, padding);
    }
    /**
     * Derives a shared secret from the public key.
     *
     * @method deriveSharedSecret
     * @param key - The public key to derive the shared secret from.
     * @returns The derived shared secret (a point on the curve).
     * @throws Will throw an error if the public key is not valid.
     *
     * @example
     * const privateKey = PrivateKey.fromRandom();
     * const publicKey = privateKey.toPublicKey();
     * const sharedSecret = privateKey.deriveSharedSecret(publicKey);
     */
    deriveSharedSecret(key) {
        if (!key.validate()) {
            throw new Error('Public key not valid for ECDH secret derivation');
        }
        return key.mul(this);
    }
    /**
     * Derives a child key with BRC-42.
     * @param publicKey The public key of the other party
     * @param invoiceNumber The invoice number used to derive the child key
     * @param cacheSharedSecret Optional function to cache shared secrets
     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache
     * @returns The derived child key.
     */
    deriveChild(publicKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {
        let sharedSecret;
        if (typeof retrieveCachedSharedSecret === 'function') {
            const retrieved = retrieveCachedSharedSecret(this, publicKey);
            if (typeof retrieved !== 'undefined') {
                sharedSecret = retrieved;
            }
            else {
                sharedSecret = this.deriveSharedSecret(publicKey);
                if (typeof cacheSharedSecret === 'function') {
                    cacheSharedSecret(this, publicKey, sharedSecret);
                }
            }
        }
        else {
            sharedSecret = this.deriveSharedSecret(publicKey);
        }
        const invoiceNumberBin = (0, utils_js_1.toArray)(invoiceNumber, 'utf8');
        const hmac = (0, Hash_js_1.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);
        const curve = new Curve_js_1.default();
        return new PrivateKey(this.add(new BigNumber_js_1.default(hmac)).mod(curve.n).toArray());
    }
    /**
     * Splits the private key into shares using Shamir's Secret Sharing Scheme.
     *
     * @param threshold The minimum number of shares required to reconstruct the private key.
     * @param totalShares The total number of shares to generate.
     * @param prime The prime number to be used in Shamir's Secret Sharing Scheme.
     * @returns An array of shares.
     *
     * @example
     * const key = PrivateKey.fromRandom()
     * const shares = key.toKeyShares(2, 5)
     */
    toKeyShares(threshold, totalShares) {
        if (typeof threshold !== 'number' || typeof totalShares !== 'number') {
            throw new Error('threshold and totalShares must be numbers');
        }
        if (threshold < 2)
            throw new Error('threshold must be at least 2');
        if (totalShares < 2)
            throw new Error('totalShares must be at least 2');
        if (threshold > totalShares) {
            throw new Error('threshold should be less than or equal to totalShares');
        }
        const poly = Polynomial_js_1.default.fromPrivateKey(this, threshold);
        const points = [];
        const usedXCoordinates = new Set();
        const curve = new Curve_js_1.default();
        /**
         * Cryptographically secure x-coordinate generation for Shamir's Secret Sharing (toKeyShares)
         *
         * - Each x-coordinate is derived using a master seed (Random(64)) as the HMAC key and a per-attempt counter array as the message.
         * - The counter array includes the share index, the attempt number (to handle rare collisions), and 32 bytes of fresh randomness for each attempt.
         * - This ensures:
         *   1. **Non-determinism**: Each split is unique, even for the same key and parameters, due to the per-attempt randomness.
         *   2. **Uniqueness**: x-coordinates are checked for zero and duplication; retry logic ensures no repeats or invalid values.
         *   3. **Cryptographic strength**: HMAC-SHA-512 is robust, and combining deterministic and random values protects against RNG compromise or bias.
         *   4. **Defensive programming**: Attempts are capped (5 per share) to prevent infinite loops in pathological cases.
         *
         * This approach is robust against all practical attacks and is suitable for high-security environments where deterministic splits are not desired.
         */
        const seed = (0, Random_js_1.default)(64);
        for (let i = 0; i < totalShares; i++) {
            let x;
            let attempts = 0;
            do {
                // To ensure no two points are ever the same, even if the system RNG is compromised,
                // we'll use a different counter value for each point and use SHA-512 HMAC.
                const counter = [i, attempts, ...(0, Random_js_1.default)(32)];
                const h = (0, Hash_js_1.sha512hmac)(seed, counter);
                x = new BigNumber_js_1.default(h).umod(curve.p);
                // repeat generation if x is zero or has already been used (insanely unlikely)
                attempts++;
                if (attempts > 5) {
                    throw new Error('Failed to generate unique x coordinate after 5 attempts');
                }
            } while (x.isZero() || usedXCoordinates.has(x.toString()));
            usedXCoordinates.add(x.toString());
            const y = poly.valueAt(x);
            points.push(new Polynomial_js_1.PointInFiniteField(x, y));
        }
        const integrity = this.toPublicKey().toHash('hex').slice(0, 8);
        return new KeyShares(points, threshold, integrity);
    }
    /**
     * @method toBackupShares
     *
     * Creates a backup of the private key by splitting it into shares.
     *
     *
     * @param threshold The number of shares which will be required to reconstruct the private key.
     * @param totalShares The number of shares to generate for distribution.
     * @returns
     */
    toBackupShares(threshold, totalShares) {
        return this.toKeyShares(threshold, totalShares).toBackupFormat();
    }
    /**
     *
     * @method fromBackupShares
     *
     * Creates a private key from backup shares.
     *
     * @param shares
     * @returns PrivateKey
     *
     * @example
     *
     * const share1 = '3znuzt7DZp8HzZTfTh5MF9YQKNX3oSxTbSYmSRGrH2ev.2Nm17qoocmoAhBTCs8TEBxNXCskV9N41rB2PckcgYeqV.2.35449bb9'
     * const share2 = 'Cm5fuUc39X5xgdedao8Pr1kvCSm8Gk7Cfenc7xUKcfLX.2juyK9BxCWn2DiY5JUAgj9NsQ77cc9bWksFyW45haXZm.2.35449bb9'
     *
     * const recoveredKey = PrivateKey.fromBackupShares([share1, share2])
     */
    static fromBackupShares(shares) {
        return PrivateKey.fromKeyShares(KeyShares.fromBackupFormat(shares));
    }
    /**
     * Combines shares to reconstruct the private key.
     *
     * @param shares An array of points (shares) to be used to reconstruct the private key.
     * @param threshold The minimum number of shares required to reconstruct the private key.
     *
     * @returns The reconstructed private key.
     *
     **/
    static fromKeyShares(keyShares) {
        const { points, threshold, integrity } = keyShares;
        if (threshold < 2)
            throw new Error('threshold must be at least 2');
        if (points.length < threshold) {
            throw new Error(`At least ${threshold} shares are required to reconstruct the private key`);
        }
        // check to see if two points have the same x value
        for (let i = 0; i < threshold; i++) {
            for (let j = i + 1; j < threshold; j++) {
                if (points[i].x.eq(points[j].x)) {
                    throw new Error('Duplicate share detected, each must be unique.');
                }
            }
        }
        const poly = new Polynomial_js_1.default(points, threshold);
        const privateKey = new PrivateKey(poly.valueAt(new BigNumber_js_1.default(0)).toArray());
        const integrityHash = privateKey.toPublicKey().toHash('hex').slice(0, 8);
        if (integrityHash !== integrity) {
            throw new Error('Integrity hash mismatch');
        }
        return privateKey;
    }
}
exports.default = PrivateKey;

},{"./BigNumber.js":42,"./Curve.js":43,"./ECDSA.js":45,"./Hash.js":46,"./Polynomial.js":52,"./PublicKey.js":54,"./Random.js":55,"./utils.js":62}],54:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Point_js_1 = __importDefault(require("./Point.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const ECDSA_js_1 = require("./ECDSA.js");
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Hash_js_1 = require("./Hash.js");
const Signature_js_1 = __importDefault(require("./Signature.js"));
const utils_js_1 = require("./utils.js");
/**
 * The PublicKey class extends the Point class. It is used in public-key cryptography to derive shared secret, verify message signatures, and encode the public key in the DER format.
 * The class comes with static methods to generate PublicKey instances from private keys or from strings.
 *
 * @extends {Point}
 * @see {@link Point} for more information on Point.
 */
class PublicKey extends Point_js_1.default {
    /**
     * Static factory method to derive a public key from a private key.
     * It multiplies the generator point 'g' on the elliptic curve by the private key.
     *
     * @static
     * @method fromPrivateKey
     *
     * @param key - The private key from which to derive the public key.
     *
     * @returns Returns the PublicKey derived from the given PrivateKey.
     *
     * @example
     * const myPrivKey = new PrivateKey(...)
     * const myPubKey = PublicKey.fromPrivateKey(myPrivKey)
     */
    static fromPrivateKey(key) {
        const c = new Curve_js_1.default();
        const p = c.g.mul(key);
        return new PublicKey(p.x, p.y);
    }
    /**
     * Static factory method to create a PublicKey instance from a string.
     *
     * @param str - A string representing a public key.
     *
     * @returns Returns the PublicKey created from the string.
     *
     * @example
     * const myPubKey = PublicKey.fromString("03....")
     */
    static fromString(str) {
        const p = Point_js_1.default.fromString(str);
        return new PublicKey(p.x, p.y);
    }
    /**
     * Static factory method to create a PublicKey instance from a number array.
     *
     * @param bytes - A number array representing a public key.
     *
     * @returns Returns the PublicKey created from the number array.
     *
     * @example
     * const myPubKey = PublicKey.fromString("03....")
     */
    static fromDER(bytes) {
        const p = Point_js_1.default.fromDER(bytes);
        return new PublicKey(p.x, p.y);
    }
    /**
     * @constructor
     * @param x - A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an "Infinity" point is constructed.
     * @param y - If x is not a point, the y-coordinate of the point, similar to x.
     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.
     *
     * @example
     * new PublicKey(point1);
     * new PublicKey('abc123', 'def456');
     */
    constructor(x, y = null, isRed = true) {
        if (x instanceof Point_js_1.default) {
            super(x.getX(), x.getY());
        }
        else {
            // Common gotcha: constructing PublicKey with a DER value when you should use .fromString()
            if (y === null && isRed && typeof x === 'string') {
                if (x.length === 66 || x.length === 130) {
                    throw new Error('You are using the "new PublicKey()" constructor with a DER hex string. You need to use "PublicKey.fromString()" instead.');
                }
            }
            super(x, y, isRed);
        }
    }
    /**
     * Derive a shared secret from a public key and a private key for use in symmetric encryption.
     * This method multiplies the public key (an instance of Point) with a private key.
     *
     * @param priv - The private key to use in deriving the shared secret.
     *
     * @returns Returns the Point representing the shared secret.
     *
     * @throws Will throw an error if the public key is not valid for ECDH secret derivation.
     *
     * @example
     * const myPrivKey = new PrivateKey(...)
     * const sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)
     */
    deriveSharedSecret(priv) {
        if (!this.validate()) {
            throw new Error('Public key not valid for ECDH secret derivation');
        }
        return this.mul(priv);
    }
    /**
     * Verify a signature of a message using this public key.
     *
     * @param msg - The message to verify. It can be a string or an array of numbers.
     * @param sig - The Signature of the message that needs verification.
     * @param enc - The encoding of the message. It defaults to 'utf8'.
     *
     * @returns Returns true if the signature is verified successfully, otherwise false.
     *
     * @example
     * const myMessage = "Hello, world!"
     * const mySignature = new Signature(...)
     * const isVerified = myPubKey.verify(myMessage, mySignature)
     */
    verify(msg, sig, enc) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.verify)(msgHash, sig, this);
    }
    /**
     * Encode the public key to DER (Distinguished Encoding Rules) format.
     *
     * @returns Returns the DER-encoded public key in number array or string.
     *
     * @param enc - The encoding of the DER string. undefined = number array, 'hex' = hex string.
     *
     * @example
     * const derPublicKey = myPubKey.toDER()
     */
    toDER(enc) {
        if (enc === 'hex')
            return this.encode(true, enc);
        return this.encode(true);
    }
    /**
     * Hash sha256 and ripemd160 of the public key.
     *
     * @returns Returns the hash of the public key.
     *
     * @example
     * const publicKeyHash = pubkey.toHash()
     */
    toHash(enc) {
        const pkh = (0, Hash_js_1.hash160)(this.encode(true));
        if (enc === 'hex') {
            return (0, utils_js_1.toHex)(pkh);
        }
        return pkh;
    }
    /**
     * Base58Check encodes the hash of the public key with a prefix to indicate locking script type.
     * Defaults to P2PKH for mainnet, otherwise known as a "Bitcoin Address".
     *
     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'
     *
     * @returns Returns the address encoding associated with the hash of the public key.
     *
     * @example
     * const address = pubkey.toAddress()
     * const address = pubkey.toAddress('mainnet')
     * const testnetAddress = pubkey.toAddress([0x6f])
     * const testnetAddress = pubkey.toAddress('testnet')
     */
    toAddress(prefix = [0x00]) {
        if (typeof prefix === 'string') {
            if (prefix === 'testnet' || prefix === 'test') {
                prefix = [0x6f];
            }
            else if (prefix === 'mainnet' || prefix === 'main') {
                prefix = [0x00];
            }
            else {
                throw new Error(`Invalid prefix ${prefix}`);
            }
        }
        return (0, utils_js_1.toBase58Check)(this.toHash(), prefix);
    }
    /**
     * Derives a child key with BRC-42.
     * @param privateKey The private key of the other party
     * @param invoiceNumber The invoice number used to derive the child key
     * @param cacheSharedSecret Optional function to cache shared secrets
     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache
     * @returns The derived child key.
     */
    deriveChild(privateKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {
        let sharedSecret;
        if (typeof retrieveCachedSharedSecret === 'function') {
            const retrieved = retrieveCachedSharedSecret(privateKey, this);
            if (typeof retrieved !== 'undefined') {
                sharedSecret = retrieved;
            }
            else {
                sharedSecret = this.deriveSharedSecret(privateKey);
                if (typeof cacheSharedSecret === 'function') {
                    cacheSharedSecret(privateKey, this, sharedSecret);
                }
            }
        }
        else {
            sharedSecret = this.deriveSharedSecret(privateKey);
        }
        const invoiceNumberBin = (0, utils_js_1.toArray)(invoiceNumber, 'utf8');
        const hmac = (0, Hash_js_1.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);
        const curve = new Curve_js_1.default();
        const point = curve.g.mul(new BigNumber_js_1.default(hmac));
        const finalPoint = this.add(point);
        return new PublicKey(finalPoint.x, finalPoint.y);
    }
    /**
     * Takes an array of numbers or a string and returns a new PublicKey instance.
     * This method will throw an error if the Compact encoding is invalid.
     * If a string is provided, it is assumed to represent a hexadecimal sequence.
     * compactByte value 27-30 means uncompressed public key.
     * 31-34 means compressed public key.
     * The range represents the recovery param which can be 0,1,2,3.
     *
     * @static
     * @method fromMsgHashAndCompactSignature
     * @param msgHash - The message hash which was signed.
     * @param signature - The signature in compact format.
     * @param enc - The encoding of the signature string.
     * @returns A PublicKey instance derived from the message hash and compact signature.
     * @example
     * const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');
     */
    static fromMsgHashAndCompactSignature(msgHash, signature, enc) {
        const data = (0, utils_js_1.toArray)(signature, enc);
        if (data.length !== 65) {
            throw new Error('Invalid Compact Signature');
        }
        const compactByte = data[0];
        if (compactByte < 27 || compactByte >= 35) {
            throw new Error('Invalid Compact Byte');
        }
        let r = data[0] - 27;
        // NOTE: We don't use uncompressed pubkeys in this library,
        // but whether the key is compressed is captured in the recovery param.
        // Code below is commented out for reference of how you could capture this.
        // let compressed = false
        if (r > 3) {
            // compressed = true
            r -= 4;
        }
        const s = new Signature_js_1.default(new BigNumber_js_1.default(data.slice(1, 33)), new BigNumber_js_1.default(data.slice(33, 65)));
        return s.RecoverPublicKey(r, msgHash);
    }
}
exports.default = PublicKey;

},{"./BigNumber.js":42,"./Curve.js":43,"./ECDSA.js":45,"./Hash.js":46,"./Point.js":51,"./Signature.js":58,"./utils.js":62}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Rand {
    constructor() {
        const noRand = () => {
            throw new Error('No secure random number generator is available in this environment.');
        };
        this._rand = noRand; // Assign the function
        if (typeof self === 'object') {
            /* eslint-disable-next-line */
            if (self.crypto?.getRandomValues) {
                this._rand = (n) => {
                    const arr = new Uint8Array(n);
                    /* eslint-disable-next-line */
                    self.crypto.getRandomValues(arr);
                    return [...arr];
                };
            } /* if (typeof window === 'object') */
            else {
                this._rand = noRand;
            }
        }
        else {
            try {
                /* eslint-disable-next-line */
                const crypto = require("crypto");
                if (typeof crypto.randomBytes === 'function') {
                    this._rand = (n) => [...crypto.randomBytes(n)];
                }
            }
            catch {
                this._rand = noRand;
            }
        }
    }
    generate(len) {
        return this._rand(len);
    }
}
let ayn = null;
/**
 * Generates a sequence of pseudo-random bytes with the given length.
 *
 * @param len - The number of bytes to generate
 *
 * @returns The generated bytes
 *
 * @example
 * import Random from '@bsv/sdk/primitives/Random'
 * const bytes = Random(32) // Produces 32 random bytes
 */
exports.default = (len) => {
    if (ayn == null) {
        ayn = new Rand();
    }
    return ayn.generate(len);
};

},{"crypto":206}],56:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const K256_js_1 = __importDefault(require("./K256.js"));
/**
 * A base reduction engine that provides several arithmetic operations over
 * big numbers under a modulus context. It's particularly suitable for
 * calculations required in cryptography algorithms and encoding schemas.
 *
 * @class ReductionContext
 *
 * @property prime - The prime number utilised in the reduction context, typically an instance of Mersenne class.
 * @property m - The modulus used for reduction operations.
 */
class ReductionContext {
    /**
     * Constructs a new ReductionContext.
     *
     * @constructor
     * @param m - A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.
     *
     * @example
     * new ReductionContext(new BigNumber(11));
     * new ReductionContext('k256');
     */
    constructor(m) {
        if (m === 'k256') {
            const prime = new K256_js_1.default();
            this.m = prime.p;
            this.prime = prime;
        }
        else {
            this.assert(m.gtn(1), 'modulus must be greater than 1');
            this.m = m;
            this.prime = null;
        }
    }
    /**
     * Asserts that given value is truthy. Throws an Error with a provided message
     * if the value is falsy.
     *
     * @private
     * @param val - The value to be checked.
     * @param msg - The error message to be thrown if the value is falsy.
     *
     * @example
     * this.assert(1 < 2, '1 is not less than 2');
     * this.assert(2 < 1, '2 is less than 1'); // throws an Error with message '2 is less than 1'
     */
    assert(val, msg = 'Assertion failed') {
        if (!val)
            throw new Error(msg);
    }
    /**
     * Verifies that a BigNumber is positive and red. Throws an error if these
     * conditions are not met.
     *
     * @param a - The BigNumber to be verified.
     *
     * @example
     * this.verify1(new BigNumber(10).toRed());
     * this.verify1(new BigNumber(-10).toRed()); //throws an Error
     * this.verify1(new BigNumber(10)); //throws an Error
     */
    verify1(a) {
        this.assert(a.negative === 0, 'red works only with positives');
        this.assert(a.red, 'red works only with red numbers');
    }
    /**
     * Verifies that two BigNumbers are both positive and red. Also checks
     * that they have the same reduction context. Throws an error if these
     * conditions are not met.
     *
     * @param a - The first BigNumber to be verified.
     * @param b - The second BigNumber to be verified.
     *
     * @example
     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));
     * this.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error
     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error
     */
    verify2(a, b) {
        this.assert((a.negative | b.negative) === 0, 'red works only with positives');
        this.assert(a.red != null && a.red === b.red, 'red works only with red numbers');
    }
    /**
     * Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.
     *
     * @method imod
     *
     * @param a - BigNumber to be reduced.
     *
     * @returns Returns the reduced result.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.imod(new BigNumber(19)); // Returns 5
     */
    imod(a) {
        if (this.prime != null)
            return this.prime.ireduce(a).forceRed(this);
        BigNumber_js_1.default.move(a, a.umod(this.m).forceRed(this));
        return a;
    }
    /**
     * Negates a BigNumber in the context of the modulus.
     *
     * @method neg
     *
     * @param a - BigNumber to negate.
     *
     * @returns Returns the negation of 'a' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.neg(new BigNumber(3)); // Returns 4
     */
    neg(a) {
        if (a.isZero()) {
            return a.clone();
        }
        return this.m.sub(a).forceRed(this);
    }
    /**
     * Performs the addition operation on two BigNumbers in the reduction context.
     *
     * @method add
     *
     * @param a - First BigNumber to add.
     * @param b - Second BigNumber to add.
     *
     * @returns Returns the result of 'a + b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(5));
     * context.add(new BigNumber(2), new BigNumber(4)); // Returns 1
     */
    add(a, b) {
        this.verify2(a, b);
        const res = a.add(b);
        if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
        }
        return res.forceRed(this);
    }
    /**
     * Performs an in-place addition operation on two BigNumbers in the reduction context
     * in order to avoid creating a new BigNumber, it modifies the first one with the result.
     *
     * @method iadd
     *
     * @param a - First BigNumber to add.
     * @param b - Second BigNumber to add.
     *
     * @returns Returns the modified 'a' after addition with 'b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(5));
     * const a = new BigNumber(2);
     * context.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1
     */
    iadd(a, b) {
        this.verify2(a, b);
        const res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
        }
        return res;
    }
    /**
     * Subtracts one BigNumber from another BigNumber in the reduction context.
     *
     * @method sub
     *
     * @param a - BigNumber to be subtracted from.
     * @param b - BigNumber to subtract.
     *
     * @returns Returns the result of 'a - b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.sub(new BigNumber(3), new BigNumber(2)); // Returns 1
     */
    sub(a, b) {
        this.verify2(a, b);
        const res = a.sub(b);
        if (res.cmpn(0) < 0) {
            res.iadd(this.m);
        }
        return res.forceRed(this);
    }
    /**
     * Performs in-place subtraction of one BigNumber from another in the reduction context,
     * it modifies the first BigNumber with the result.
     *
     * @method isub
     *
     * @param a - BigNumber to be subtracted from.
     * @param b - BigNumber to subtract.
     *
     * @returns Returns the modified 'a' after subtraction of 'b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(5));
     * const a = new BigNumber(4);
     * context.isub(a, new BigNumber(2)); // Modifies 'a' to be 2
     */
    isub(a, b) {
        this.verify2(a, b);
        const res = a.isub(b);
        if (res.cmpn(0) < 0) {
            res.iadd(this.m);
        }
        return res;
    }
    /**
     * Performs bitwise shift left operation on a BigNumber in the reduction context.
     *
     * @method shl
     *
     * @param a - BigNumber to perform shift on.
     * @param num - The number of positions to shift.
     *
     * @returns Returns the result of shifting 'a' left by 'num' positions in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(32));
     * context.shl(new BigNumber(4), 2); // Returns 16
     */
    shl(a, num) {
        this.verify1(a);
        return this.imod(a.ushln(num));
    }
    /**
     * Performs in-place multiplication of two BigNumbers in the reduction context,
     * modifying the first BigNumber with the result.
     *
     * @method imul
     *
     * @param a - First BigNumber to multiply.
     * @param b - Second BigNumber to multiply.
     *
     * @returns Returns the modified 'a' after multiplication with 'b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * const a = new BigNumber(3);
     * context.imul(a, new BigNumber(2)); // Modifies 'a' to be 6
     */
    imul(a, b) {
        this.verify2(a, b);
        return this.imod(a.imul(b));
    }
    /**
     * Multiplies two BigNumbers in the reduction context.
     *
     * @method mul
     *
     * @param a - First BigNumber to multiply.
     * @param b - Second BigNumber to multiply.
     *
     * @returns Returns the result of 'a * b' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.mul(new BigNumber(3), new BigNumber(2)); // Returns 6
     */
    mul(a, b) {
        this.verify2(a, b);
        return this.imod(a.mul(b));
    }
    /**
     * Calculates the square of a BigNumber in the reduction context,
     * modifying the original BigNumber with the result.
     *
     * @method isqr
     *
     * @param a - BigNumber to be squared.
     *
     * @returns Returns the squared 'a' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * const a = new BigNumber(3);
     * context.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)
     */
    isqr(a) {
        return this.imul(a, a.clone());
    }
    /**
     * Calculates the square of a BigNumber in the reduction context.
     *
     * @method sqr
     *
     * @param a - BigNumber to be squared.
     *
     * @returns Returns the result of 'a^2' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)
     */
    sqr(a) {
        return this.mul(a, a);
    }
    /**
     * Calculates the square root of a BigNumber in the reduction context.
     *
     * @method sqrt
     *
     * @param a - The BigNumber to calculate the square root of.
     *
     * @returns Returns the square root of 'a' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(9));
     * context.sqrt(new BigNumber(4)); // Returns 2
     */
    sqrt(a) {
        if (a.isZero())
            return a.clone();
        const mod3 = this.m.andln(3);
        this.assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            const pow = this.m.add(new BigNumber_js_1.default(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        const q = this.m.subn(1);
        let s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
        }
        this.assert(!q.isZero());
        const one = new BigNumber_js_1.default(1).toRed(this);
        const nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        const lpow = this.m.subn(1).iushrn(1);
        const zl = this.m.bitLength();
        const z = new BigNumber_js_1.default(2 * zl * zl).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
        }
        let c = this.pow(z, q);
        let r = this.pow(a, q.addn(1).iushrn(1));
        let t = this.pow(a, q);
        let m = s;
        while (t.cmp(one) !== 0) {
            let tmp = t;
            let i = 0;
            for (; tmp.cmp(one) !== 0; i++) {
                tmp = tmp.redSqr();
            }
            this.assert(i < m);
            const b = this.pow(c, new BigNumber_js_1.default(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    }
    /**
     * Calculates the multiplicative inverse of a BigNumber in the reduction context.
     *
     * @method invm
     *
     * @param a - The BigNumber to find the multiplicative inverse of.
     *
     * @returns Returns the multiplicative inverse of 'a' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(11));
     * context.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)
     */
    invm(a) {
        const inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        }
        else {
            return this.imod(inv);
        }
    }
    /**
     * Raises a BigNumber to a power in the reduction context.
     *
     * @method pow
     *
     * @param a - The BigNumber to be raised to a power.
     * @param num - The power to raise the BigNumber to.
     *
     * @returns Returns the result of 'a' raised to the power of 'num' in the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)
     */
    pow(a, num) {
        if (num.isZero())
            return new BigNumber_js_1.default(1).toRed(this);
        if (num.cmpn(1) === 0)
            return a.clone();
        const windowSize = 4;
        const wnd = new Array(1 << windowSize);
        wnd[0] = new BigNumber_js_1.default(1).toRed(this);
        wnd[1] = a;
        let i = 2;
        for (; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
        }
        let res = wnd[0];
        let current = 0;
        let currentLen = 0;
        let start = num.bitLength() % 26;
        if (start === 0) {
            start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
            const word = num.words[i];
            for (let j = start - 1; j >= 0; j--) {
                const bit = (word >> j) & 1;
                if (res !== wnd[0]) {
                    res = this.sqr(res);
                }
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0))
                    continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    }
    /**
     * Converts a BigNumber to its equivalent in the reduction context.
     *
     * @method convertTo
     *
     * @param num - The BigNumber to convert to the reduction context.
     *
     * @returns Returns the converted BigNumber compatible with the reduction context.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * context.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)
     */
    convertTo(num) {
        const r = num.umod(this.m);
        return r === num ? r.clone() : r;
    }
    /**
     * Converts a BigNumber from reduction context to its regular form.
     *
     * @method convertFrom
     *
     * @param num - The BigNumber to convert from the reduction context.
     *
     * @returns Returns the converted BigNumber in its regular form.
     *
     * @example
     * const context = new ReductionContext(new BigNumber(7));
     * const a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context
     * context.convertFrom(a); // Returns 1
     */
    convertFrom(num) {
        const res = num.clone();
        res.red = null;
        return res;
    }
}
exports.default = ReductionContext;

},{"./BigNumber.js":42,"./K256.js":48}],57:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
const Hash_js_1 = require("./Hash.js");
const index_js_1 = require("./index.js");
/**
 * Class representing the Schnorr Zero-Knowledge Proof (ZKP) protocol.
 *
 * This class provides methods to generate and verify proofs that demonstrate knowledge of a secret without revealing it.
 * Specifically, it allows one party to prove to another that they know the private key corresponding to a public key
 * and have correctly computed a shared secret, without disclosing the private key itself.
 *
 * The protocol involves two main methods:
 * - `generateProof`: Generates a proof linking a public key `A` and a shared secret `S`, proving knowledge of the corresponding private key `a`.
 * - `verifyProof`: Verifies the provided proof, ensuring its validity without revealing any secret information.
 *
 * The class utilizes elliptic curve cryptography (ECC) and the SHA-256 hash function to compute challenges within the proof.
 *
 * @example
 * ```typescript
 * const schnorr = new Schnorr();
 * const a = PrivateKey.fromRandom(); // Prover's private key
 * const A = a.toPublicKey();         // Prover's public key
 * const b = PrivateKey.fromRandom(); // Other party's private key
 * const B = b.toPublicKey();         // Other party's public key
 * const S = B.mul(a);                // Shared secret
 *
 * // Prover generates the proof
 * const proof = schnorr.generateProof(a, A, B, S);
 *
 * // Verifier verifies the proof
 * const isValid = schnorr.verifyProof(A.point, B.point, S.point, proof);
 * console.log(`Proof is valid: ${isValid}`);
 * ```
 */
class Schnorr {
    constructor() {
        this.curve = new Curve_js_1.default();
    }
    /**
     * Generates a proof that demonstrates the link between public key A and shared secret S
     * @param a Private key corresponding to public key A
     * @param A Public key
     * @param B Other party's public key
     * @param S Shared secret
     * @returns Proof (R, S', z)
     */
    generateProof(aArg, AArg, BArg, S) {
        const r = index_js_1.PrivateKey.fromRandom();
        const R = r.toPublicKey();
        const SPrime = BArg.mul(r);
        const e = this.computeChallenge(AArg, BArg, S, SPrime, R);
        const z = r.add(e.mul(aArg)).umod(this.curve.n);
        return { R, SPrime, z };
    }
    /**
     * Verifies the proof of the link between public key A and shared secret S
     * @param A Public key
     * @param B Other party's public key
     * @param S Shared secret
     * @param proof Proof (R, S', z)
     * @returns True if the proof is valid, false otherwise
     */
    verifyProof(A, B, S, proof) {
        const { R, SPrime, z } = proof;
        const e = this.computeChallenge(A, B, S, SPrime, R);
        // Check zG = R + eA
        const zG = this.curve.g.mul(z);
        const RpluseA = R.add(A.mul(e));
        if (!zG.eq(RpluseA)) {
            return false;
        }
        // Check zB = S' + eS
        const zB = B.mul(z);
        const SprimeeS = SPrime.add(S.mul(e));
        if (!zB.eq(SprimeeS)) {
            return false;
        }
        return true;
    }
    computeChallenge(A, B, S, SPrime, R) {
        const message = [
            ...A.encode(true),
            ...B.encode(true),
            ...S.encode(true),
            ...SPrime.encode(true),
            ...R.encode(true)
        ];
        const hash = (0, Hash_js_1.sha256)(message);
        return new BigNumber_js_1.default(hash).umod(this.curve.n);
    }
}
exports.default = Schnorr;

},{"./BigNumber.js":42,"./Curve.js":43,"./Hash.js":46,"./index.js":61}],58:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const PublicKey_js_1 = __importDefault(require("./PublicKey.js"));
const ECDSA_js_1 = require("./ECDSA.js");
const Hash_js_1 = require("./Hash.js");
const utils_js_1 = require("./utils.js");
const Point_js_1 = __importDefault(require("./Point.js"));
const Curve_js_1 = __importDefault(require("./Curve.js"));
/**
 * Represents a digital signature.
 *
 * A digital signature is a mathematical scheme for verifying the authenticity of
 * digital messages or documents. In many scenarios, it is equivalent to a handwritten signature or stamped seal.
 * The signature pair (R, S) corresponds to the raw ECDSA ([Elliptic Curve Digital Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) signature.
 * Signatures are often serialized into a format known as '[DER encoding](https://en.wikipedia.org/wiki/X.690#DER_encoding)' for transmission.
 *
 * @class Signature
 */
class Signature {
    /**
     * Takes an array of numbers or a string and returns a new Signature instance.
     * This method will throw an error if the DER encoding is invalid.
     * If a string is provided, it is assumed to represent a hexadecimal sequence.
     *
     * @static
     * @method fromDER
     * @param data - The sequence to decode from DER encoding.
     * @param enc - The encoding of the data string.
     * @returns The decoded data in the form of Signature instance.
     *
     * @example
     * const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');
     */
    static fromDER(data, enc) {
        const getLength = (buf, p) => {
            const initial = buf[p.place++];
            if ((initial & 0x80) === 0) {
                return initial;
            }
            else {
                throw new Error('Invalid DER entity length');
            }
        };
        class Position {
            constructor() {
                this.place = 0;
            }
        }
        data = (0, utils_js_1.toArray)(data, enc);
        const p = new Position();
        if (data[p.place++] !== 0x30) {
            throw new Error('Signature DER must start with 0x30');
        }
        const len = getLength(data, p);
        if (len + p.place !== data.length) {
            throw new Error('Signature DER invalid');
        }
        if (data[p.place++] !== 0x02) {
            throw new Error('Signature DER invalid');
        }
        const rlen = getLength(data, p);
        let r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 0x02) {
            throw new Error('Signature DER invalid');
        }
        const slen = getLength(data, p);
        if (data.length !== slen + p.place) {
            throw new Error('Invalid R-length in signature DER');
        }
        let s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
            if ((r[1] & 0x80) !== 0) {
                r = r.slice(1);
            }
            else {
                throw new Error('Invalid R-value in signature DER');
            }
        }
        if (s[0] === 0) {
            if ((s[1] & 0x80) !== 0) {
                s = s.slice(1);
            }
            else {
                throw new Error('Invalid S-value in signature DER');
            }
        }
        return new Signature(new BigNumber_js_1.default(r), new BigNumber_js_1.default(s));
    }
    /**
     * Takes an array of numbers or a string and returns a new Signature instance.
     * This method will throw an error if the Compact encoding is invalid.
     * If a string is provided, it is assumed to represent a hexadecimal sequence.
     * compactByte value 27-30 means uncompressed public key.
     * 31-34 means compressed public key.
     * The range represents the recovery param which can be 0,1,2,3.
     * We could support recovery functions in future if there's demand.
     *
     * @static
     * @method fromCompact
     * @param data - The sequence to decode from Compact encoding.
     * @param enc - The encoding of the data string.
     * @returns The decoded data in the form of Signature instance.
     *
     * @example
     * const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');
     */
    static fromCompact(data, enc) {
        data = (0, utils_js_1.toArray)(data, enc);
        if (data.length !== 65) {
            throw new Error('Invalid Compact Signature');
        }
        const compactByte = data[0];
        if (compactByte < 27 || compactByte >= 35) {
            throw new Error('Invalid Compact Byte');
        }
        return new Signature(new BigNumber_js_1.default(data.slice(1, 33)), new BigNumber_js_1.default(data.slice(33, 65)));
    }
    /**
     * Creates an instance of the Signature class.
     *
     * @constructor
     * @param r - The R component of the signature.
     * @param s - The S component of the signature.
     *
     * @example
     * const r = new BigNumber('208755674028...');
     * const s = new BigNumber('564745627577...');
     * const signature = new Signature(r, s);
     */
    constructor(r, s) {
        this.r = r;
        this.s = s;
    }
    /**
     * Verifies a digital signature.
     *
     * This method will return true if the signature, key, and message hash match.
     * If the data or key do not match the signature, the function returns false.
     *
     * @method verify
     * @param msg - The message to verify.
     * @param key - The public key used to sign the original message.
     * @param enc - The encoding of the msg string.
     * @returns A boolean representing whether the signature is valid.
     *
     * @example
     * const msg = 'The quick brown fox jumps over the lazy dog';
     * const publicKey = PublicKey.fromString('04188ca1050...');
     * const isVerified = signature.verify(msg, publicKey);
     */
    verify(msg, key, enc) {
        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);
        return (0, ECDSA_js_1.verify)(msgHash, this, key);
    }
    /**
     * Converts an instance of Signature into DER encoding.
     * An alias for the toDER method.
     *
     * If the encoding parameter is set to 'hex', the function will return a hex string.
     * If 'base64', it will return a base64 string.
     * Otherwise, it will return an array of numbers.
     *
     * @method toDER
     * @param enc - The encoding to use for the output.
     * @returns The current instance in DER encoding.
     *
     * @example
     * const der = signature.toString('base64');
     */
    toString(enc) {
        return this.toDER(enc);
    }
    /**
     * Converts an instance of Signature into DER encoding.
     *
     * If the encoding parameter is set to 'hex', the function will return a hex string.
     * If 'base64', it will return a base64 string.
     * Otherwise, it will return an array of numbers.
     *
     * @method toDER
     * @param enc - The encoding to use for the output.
     * @returns The current instance in DER encoding.
     *
     * @example
     * const der = signature.toDER('hex');
     */
    toDER(enc) {
        const constructLength = (arr, len) => {
            if (len < 0x80) {
                arr.push(len);
            }
            else {
                throw new Error('len must be < 0x80');
            }
        };
        const rmPadding = (buf) => {
            let i = 0;
            const len = buf.length - 1;
            while (buf[i] === 0 && (buf[i + 1] & 0x80) === 0 && i < len) {
                i++;
            }
            if (i === 0) {
                return buf;
            }
            return buf.slice(i);
        };
        let r = this.r.toArray();
        let s = this.s.toArray();
        // Pad values
        if ((r[0] & 0x80) !== 0) {
            r = [0].concat(r);
        }
        // Pad values
        if ((s[0] & 0x80) !== 0) {
            s = [0].concat(s);
        }
        r = rmPadding(r);
        s = rmPadding(s);
        while (s[0] === 0 && (s[1] & 0x80) === 0) {
            s = s.slice(1);
        }
        let arr = [0x02];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(0x02);
        constructLength(arr, s.length);
        const backHalf = arr.concat(s);
        let res = [0x30];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        if (enc === 'hex') {
            return (0, utils_js_1.toHex)(res);
        }
        else if (enc === 'base64') {
            return (0, utils_js_1.toBase64)(res);
        }
        else {
            return res;
        }
    }
    /**
     * Converts an instance of Signature into Compact encoding.
     *
     * If the encoding parameter is set to 'hex', the function will return a hex string.
     * If 'base64', it will return a base64 string.
     * Otherwise, it will return an array of numbers.
     *
     * @method toCompact
     * @param enc - The encoding to use for the output.
     * @returns The current instance in DER encoding.
     *
     * @example
     * const compact = signature.toCompact(3, true, 'base64');
     */
    toCompact(recovery, compressed, enc) {
        if (recovery < 0 || recovery > 3)
            throw new Error('Invalid recovery param');
        if (typeof compressed !== 'boolean') {
            throw new Error('Invalid compressed param');
        }
        let compactByte = 27 + recovery;
        if (compressed) {
            compactByte += 4;
        }
        let arr = [compactByte];
        arr = arr.concat(this.r.toArray('be', 32));
        arr = arr.concat(this.s.toArray('be', 32));
        if (enc === 'hex') {
            return (0, utils_js_1.toHex)(arr);
        }
        else if (enc === 'base64') {
            return (0, utils_js_1.toBase64)(arr);
        }
        else {
            return arr;
        }
    }
    /**
     * Recovers the public key from a signature.
     * This method will return the public key if it finds a valid public key.
     * If it does not find a valid public key, it will throw an error.
     * The recovery factor is a number between 0 and 3.
     * @method RecoverPublicKey
     * @param recovery - The recovery factor.
     * @param e - The message hash.
     * @returns The public key associated with the signature.
     *
     * @example
     * const publicKey = signature.RecoverPublicKey(0, msgHash);
     */
    RecoverPublicKey(recovery, e) {
        const r = this.r;
        const s = this.s;
        // A set LSB signifies that the y-coordinate is odd
        const isYOdd = (recovery & 1) !== 0;
        // The more significant bit specifies whether we should use the
        // first or second candidate key.
        const isSecondKey = recovery >> 1;
        const curve = new Curve_js_1.default();
        const n = curve.n;
        const G = curve.g;
        // 1.1 LEt x = r + jn
        const x = isSecondKey !== 0 ? r.add(n) : r;
        const R = Point_js_1.default.fromX(x, isYOdd);
        // 1.4 Check that nR is at infinity
        const nR = R.mul(n);
        if (!nR.isInfinity()) {
            throw new Error('nR is not at infinity');
        }
        // Compute -e from e
        const eNeg = e.neg().umod(n);
        // 1.6.1 Compute Q = r^-1 (sR - eG)
        // Q = r^-1 (sR + -eG)
        const rInv = r.invm(n);
        // const Q = R.multiplyTwo(s, G, eNeg).mul(rInv)
        const srInv = rInv.mul(s).umod(n);
        const eInvrInv = rInv.mul(eNeg).umod(n);
        const Q = G.mul(eInvrInv).add(R.mul(srInv));
        const pubKey = new PublicKey_js_1.default(Q);
        pubKey.validate();
        return pubKey;
    }
    /**
     * Calculates the recovery factor which will work for a particular public key and message hash.
     * This method will return the recovery factor if it finds a valid recovery factor.
     * If it does not find a valid recovery factor, it will throw an error.
     * The recovery factor is a number between 0 and 3.
     *
     * @method CalculateRecoveryFactor
     * @param msgHash - The message hash.
     * @returns the recovery factor: number
     * /
     * @example
     * const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);
     */
    CalculateRecoveryFactor(pubkey, msgHash) {
        for (let recovery = 0; recovery < 4; recovery++) {
            let Qprime;
            try {
                Qprime = this.RecoverPublicKey(recovery, msgHash);
            }
            catch {
                continue;
            }
            if (pubkey.eq(Qprime)) {
                return recovery;
            }
        }
        throw new Error('Unable to find valid recovery factor');
    }
}
exports.default = Signature;

},{"./BigNumber.js":42,"./Curve.js":43,"./ECDSA.js":45,"./Hash.js":46,"./Point.js":51,"./PublicKey.js":54,"./utils.js":62}],59:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const AESGCM_js_1 = require("./AESGCM.js");
const Random_js_1 = __importDefault(require("./Random.js"));
const utils_js_1 = require("./utils.js");
/**
 * `SymmetricKey` is a class that extends the `BigNumber` class and implements symmetric encryption and decryption methods.
 * Symmetric-Key encryption is a form of encryption where the same key is used to encrypt and decrypt the message.
 * It leverages the Advanced Encryption Standard Galois/Counter Mode (AES-GCM) for encryption and decryption of messages.
 *
 * @class SymmetricKey
 * @extends {BigNumber}
 */
class SymmetricKey extends BigNumber_js_1.default {
    /**
     * Generates a symmetric key randomly.
     *
     * @method fromRandom
     * @static
     * @returns The newly generated Symmetric Key.
     *
     * @example
     * const symmetricKey = SymmetricKey.fromRandom();
     */
    static fromRandom() {
        return new SymmetricKey((0, Random_js_1.default)(32));
    }
    /**
     * Encrypts a given message using AES-GCM encryption.
     * The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes.
     * The OpenSSL format of |IV|encryptedContent|authTag| is used.
     *
     * @method encrypt
     * @param msg - The message to be encrypted. It can be a string or an array of numbers.
     * @param enc - optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.
     * @returns Returns the encrypted message as a string or an array of numbers, depending on `enc` argument.
     *
     * @example
     * const key = new SymmetricKey(1234);
     * const encryptedMessage = key.encrypt('plainText', 'utf8');
     */
    encrypt(msg, enc) {
        const iv = (0, Random_js_1.default)(32);
        msg = (0, utils_js_1.toArray)(msg, enc);
        const { result, authenticationTag } = (0, AESGCM_js_1.AESGCM)(msg, [], iv, this.toArray('be', 32));
        return (0, utils_js_1.encode)([...iv, ...result, ...authenticationTag], enc);
    }
    /**
     * Decrypts a given AES-GCM encrypted message using the same key that was used for encryption.
     * The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it.
     * If the decryption fails (e.g., due to message tampering), an error is thrown.
     *
     * @method decrypt
     * @param msg - The encrypted message to be decrypted. It can be a string or an array of numbers.
     * @param enc - optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).
     * @returns Returns the decrypted message as a string or an array of numbers, depending on `enc` argument. If absent, an array of numbers is returned.
     *
     * @example
     * const key = new SymmetricKey(1234);
     * const decryptedMessage = key.decrypt(encryptedMessage, 'utf8');
     *
     * @throws {Error} Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.
     */
    decrypt(msg, enc) {
        msg = (0, utils_js_1.toArray)(msg, enc);
        const iv = msg.slice(0, 32);
        const ciphertextWithTag = msg.slice(32);
        const messageTag = ciphertextWithTag.slice(-16);
        const ciphertext = ciphertextWithTag.slice(0, -16);
        const result = (0, AESGCM_js_1.AESGCMDecrypt)(ciphertext, [], iv, messageTag, this.toArray());
        if (result === null) {
            throw new Error('Decryption failed!');
        }
        return (0, utils_js_1.encode)(result, enc);
    }
}
exports.default = SymmetricKey;

},{"./AESGCM.js":40,"./BigNumber.js":42,"./Random.js":55,"./utils.js":62}],60:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Signature_js_1 = __importDefault(require("./Signature.js"));
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Hash = __importStar(require("./Hash.js"));
const utils_js_1 = require("./utils.js");
class TransactionSignature extends Signature_js_1.default {
    static format(params) {
        const currentInput = {
            sourceTXID: params.sourceTXID,
            sourceOutputIndex: params.sourceOutputIndex,
            sequence: params.inputSequence
        };
        const inputs = [...params.otherInputs];
        inputs.splice(params.inputIndex, 0, currentInput);
        const getPrevoutHash = () => {
            const writer = new utils_js_1.Writer();
            for (const input of inputs) {
                if (typeof input.sourceTXID === 'undefined') {
                    if (input.sourceTransaction == null) {
                        throw new Error('Missing sourceTransaction for input');
                    }
                    writer.write(input.sourceTransaction.hash());
                }
                else {
                    writer.writeReverse((0, utils_js_1.toArray)(input.sourceTXID, 'hex'));
                }
                writer.writeUInt32LE(input.sourceOutputIndex);
            }
            const buf = writer.toArray();
            const ret = Hash.hash256(buf);
            return ret;
        };
        const getSequenceHash = () => {
            const writer = new utils_js_1.Writer();
            for (const input of inputs) {
                const sequence = input.sequence ?? 0xffffffff; // Default to max sequence number
                writer.writeUInt32LE(sequence);
            }
            const buf = writer.toArray();
            const ret = Hash.hash256(buf);
            return ret;
        };
        function getOutputsHash(outputIndex) {
            const writer = new utils_js_1.Writer();
            if (typeof outputIndex === 'undefined') {
                for (const output of params.outputs) {
                    const satoshis = output.satoshis ?? 0; // Default to 0 if undefined
                    writer.writeUInt64LE(satoshis);
                    const script = output.lockingScript?.toBinary() ?? [];
                    writer.writeVarIntNum(script.length);
                    writer.write(script);
                }
            }
            else {
                const output = params.outputs[outputIndex];
                if (output === undefined) { // ✅ Explicitly check for undefined
                    throw new Error(`Output at index ${outputIndex} does not exist`);
                }
                const satoshis = output.satoshis ?? 0; // Default to 0 if undefined
                writer.writeUInt64LE(satoshis);
                const script = output.lockingScript?.toBinary() ?? [];
                writer.writeVarIntNum(script.length);
                writer.write(script);
            }
            const buf = writer.toArray();
            const ret = Hash.hash256(buf);
            return ret;
        }
        let hashPrevouts = new Array(32).fill(0);
        let hashSequence = new Array(32).fill(0);
        let hashOutputs = new Array(32).fill(0);
        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0) {
            hashPrevouts = getPrevoutHash();
        }
        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0 &&
            (params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&
            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {
            hashSequence = getSequenceHash();
        }
        if ((params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&
            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {
            hashOutputs = getOutputsHash();
        }
        else if ((params.scope & 31) === TransactionSignature.SIGHASH_SINGLE &&
            params.inputIndex < params.outputs.length) {
            hashOutputs = getOutputsHash(params.inputIndex);
        }
        const writer = new utils_js_1.Writer();
        // Version
        writer.writeInt32LE(params.transactionVersion);
        // Input prevouts/nSequence (none/all, depending on flags)
        writer.write(hashPrevouts);
        writer.write(hashSequence);
        //  outpoint (32-byte hash + 4-byte little endian)
        writer.writeReverse((0, utils_js_1.toArray)(params.sourceTXID, 'hex'));
        writer.writeUInt32LE(params.sourceOutputIndex);
        // scriptCode of the input (serialized as scripts inside CTxOuts)
        const subscriptBin = params.subscript.toBinary();
        writer.writeVarIntNum(subscriptBin.length);
        writer.write(subscriptBin);
        // value of the output spent by this input (8-byte little endian)
        writer.writeUInt64LE(params.sourceSatoshis);
        // nSequence of the input (4-byte little endian)
        const sequenceNumber = currentInput.sequence;
        writer.writeUInt32LE(sequenceNumber);
        // Outputs (none/one/all, depending on flags)
        writer.write(hashOutputs);
        // Locktime
        writer.writeUInt32LE(params.lockTime);
        // sighashType
        writer.writeUInt32LE(params.scope >>> 0);
        const buf = writer.toArray();
        return buf;
    }
    // The format used in a tx
    static fromChecksigFormat(buf) {
        if (buf.length === 0) {
            // allow setting a "blank" signature
            const r = new BigNumber_js_1.default(1);
            const s = new BigNumber_js_1.default(1);
            const scope = 1;
            return new TransactionSignature(r, s, scope);
        }
        const scope = buf[buf.length - 1];
        const derbuf = buf.slice(0, buf.length - 1);
        const tempSig = Signature_js_1.default.fromDER(derbuf);
        return new TransactionSignature(tempSig.r, tempSig.s, scope);
    }
    constructor(r, s, scope) {
        super(r, s);
        this.scope = scope;
    }
    /**
     * Compares to bitcoind's IsLowDERSignature
     * See also Ecdsa signature algorithm which enforces this.
     * See also Bip 62, "low S values in signatures"
     */
    hasLowS() {
        if (this.s.ltn(1) ||
            this.s.gt(new BigNumber_js_1.default('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {
            return false;
        }
        return true;
    }
    toChecksigFormat() {
        const derbuf = this.toDER();
        return [...derbuf, this.scope];
    }
}
TransactionSignature.SIGHASH_ALL = 0x00000001;
TransactionSignature.SIGHASH_NONE = 0x00000002;
TransactionSignature.SIGHASH_SINGLE = 0x00000003;
TransactionSignature.SIGHASH_FORKID = 0x00000040;
TransactionSignature.SIGHASH_ANYONECANPAY = 0x00000080;
exports.default = TransactionSignature;

},{"./BigNumber.js":42,"./Hash.js":46,"./Signature.js":58,"./utils.js":62}],61:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schnorr = exports.PointInFiniteField = exports.Polynomial = exports.TransactionSignature = exports.Random = exports.Hash = exports.Utils = exports.ECDSA = exports.DRBG = exports.SymmetricKey = exports.KeyShares = exports.PrivateKey = exports.Signature = exports.PublicKey = exports.Point = exports.Curve = exports.BigNumber = void 0;
var BigNumber_js_1 = require("./BigNumber.js");
Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function () { return __importDefault(BigNumber_js_1).default; } });
var Curve_js_1 = require("./Curve.js");
Object.defineProperty(exports, "Curve", { enumerable: true, get: function () { return __importDefault(Curve_js_1).default; } });
var Point_js_1 = require("./Point.js");
Object.defineProperty(exports, "Point", { enumerable: true, get: function () { return __importDefault(Point_js_1).default; } });
var PublicKey_js_1 = require("./PublicKey.js");
Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function () { return __importDefault(PublicKey_js_1).default; } });
var Signature_js_1 = require("./Signature.js");
Object.defineProperty(exports, "Signature", { enumerable: true, get: function () { return __importDefault(Signature_js_1).default; } });
var PrivateKey_js_1 = require("./PrivateKey.js");
Object.defineProperty(exports, "PrivateKey", { enumerable: true, get: function () { return __importDefault(PrivateKey_js_1).default; } });
Object.defineProperty(exports, "KeyShares", { enumerable: true, get: function () { return PrivateKey_js_1.KeyShares; } });
var SymmetricKey_js_1 = require("./SymmetricKey.js");
Object.defineProperty(exports, "SymmetricKey", { enumerable: true, get: function () { return __importDefault(SymmetricKey_js_1).default; } });
var DRBG_js_1 = require("./DRBG.js");
Object.defineProperty(exports, "DRBG", { enumerable: true, get: function () { return __importDefault(DRBG_js_1).default; } });
exports.ECDSA = __importStar(require("./ECDSA.js"));
exports.Utils = __importStar(require("./utils.js"));
exports.Hash = __importStar(require("./Hash.js"));
var Random_js_1 = require("./Random.js");
Object.defineProperty(exports, "Random", { enumerable: true, get: function () { return __importDefault(Random_js_1).default; } });
var TransactionSignature_js_1 = require("./TransactionSignature.js");
Object.defineProperty(exports, "TransactionSignature", { enumerable: true, get: function () { return __importDefault(TransactionSignature_js_1).default; } });
var Polynomial_js_1 = require("./Polynomial.js");
Object.defineProperty(exports, "Polynomial", { enumerable: true, get: function () { return __importDefault(Polynomial_js_1).default; } });
Object.defineProperty(exports, "PointInFiniteField", { enumerable: true, get: function () { return Polynomial_js_1.PointInFiniteField; } });
var Schnorr_js_1 = require("./Schnorr.js");
Object.defineProperty(exports, "Schnorr", { enumerable: true, get: function () { return __importDefault(Schnorr_js_1).default; } });

},{"./BigNumber.js":42,"./Curve.js":43,"./DRBG.js":44,"./ECDSA.js":45,"./Hash.js":46,"./Point.js":51,"./Polynomial.js":52,"./PrivateKey.js":53,"./PublicKey.js":54,"./Random.js":55,"./Schnorr.js":57,"./Signature.js":58,"./SymmetricKey.js":59,"./TransactionSignature.js":60,"./utils.js":62}],62:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.minimallyEncode = exports.Reader = exports.Writer = exports.fromBase58Check = exports.toBase58Check = exports.toBase58 = exports.fromBase58 = exports.toBase64 = exports.encode = exports.toUTF8 = exports.toArray = exports.toHex = exports.zero2 = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const Hash_js_1 = require("./Hash.js");
/**
 * Prepends a '0' to an odd character length word to ensure it has an even number of characters.
 * @param {string} word - The input word.
 * @returns {string} - The word with a leading '0' if it's an odd character length; otherwise, the original word.
 */
const zero2 = (word) => {
    if (word.length % 2 === 1) {
        return '0' + word;
    }
    else {
        return word;
    }
};
exports.zero2 = zero2;
/**
 * Converts an array of numbers to a hexadecimal string representation.
 * @param {number[]} msg - The input array of numbers.
 * @returns {string} - The hexadecimal string representation of the input array.
 */
const toHex = (msg) => {
    let res = '';
    for (const num of msg) {
        res += (0, exports.zero2)(num.toString(16));
    }
    return res;
};
exports.toHex = toHex;
/**
 * Converts various message formats into an array of numbers.
 * Supports arrays, hexadecimal strings, base64 strings, and UTF-8 strings.
 *
 * @param {any} msg - The input message (array or string).
 * @param {('hex' | 'utf8' | 'base64')} enc - Specifies the string encoding, if applicable.
 * @returns {any[]} - Array representation of the input.
 */
const toArray = (msg, enc) => {
    if (Array.isArray(msg))
        return msg.slice();
    if (msg === undefined)
        return [];
    if (typeof msg !== 'string') {
        return Array.from(msg, (item) => item | 0);
    }
    switch (enc) {
        case 'hex':
            return hexToArray(msg);
        case 'base64':
            return base64ToArray(msg);
        default:
            return utf8ToArray(msg);
    }
};
exports.toArray = toArray;
const hexToArray = (msg) => {
    msg = msg.replace(/[^a-z0-9]+/gi, '');
    if (msg.length % 2 !== 0)
        msg = '0' + msg;
    const res = [];
    for (let i = 0; i < msg.length; i += 2) {
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
    return res;
};
const base64ToArray = (msg) => {
    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const result = [];
    let currentBit = 0;
    let currentByte = 0;
    for (const char of msg.replace(/=+$/, '')) {
        currentBit = (currentBit << 6) | base64Chars.indexOf(char);
        currentByte += 6;
        if (currentByte >= 8) {
            currentByte -= 8;
            result.push((currentBit >> currentByte) & 0xff);
            currentBit &= (1 << currentByte) - 1;
        }
    }
    return result;
};
/**
 * Encodes a string into an array of bytes representing its UTF-8 encoding.
 * Any lone surrogates are replaced with the Unicode replacement character (U+FFFD).
 *
 * @param str - The string to encode.
 * @returns An array of numbers, each representing a byte in the UTF-8 encoded string.
 */
function utf8ToArray(str) {
    const result = [];
    for (let i = 0; i < str.length; i++) {
        const cp = str.codePointAt(i);
        if (cp === undefined) {
            // Should never be out of range.
            throw new Error(`Index out of range: ${i}`);
        }
        let codePoint = cp;
        if (codePoint > 0xFFFF) {
            // Valid surrogate pair => skip the next code unit because codePointAt
            // has already combined them into a single code point.
            i++;
        }
        else {
            // Check if codePoint is a lone (unpaired) high surrogate or low surrogate.
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                // Replace with the replacement character (U+FFFD).
                codePoint = 0xFFFD;
            }
        }
        // Encode according to the UTF-8 standard
        if (codePoint <= 0x7F) {
            result.push(codePoint);
        }
        else if (codePoint <= 0x7FF) {
            result.push(0xC0 | (codePoint >> 6), 0x80 | (codePoint & 0x3F));
        }
        else if (codePoint <= 0xFFFF) {
            result.push(0xE0 | (codePoint >> 12), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));
        }
        else {
            result.push(0xF0 | (codePoint >> 18), 0x80 | ((codePoint >> 12) & 0x3F), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));
        }
    }
    return result;
}
/**
 * Converts an array of numbers to a UTF-8 encoded string.
 * @param {number[]} arr - The input array of numbers.
 * @returns {string} - The UTF-8 encoded string.
 */
const toUTF8 = (arr) => {
    let result = '';
    let skip = 0;
    for (let i = 0; i < arr.length; i++) {
        const byte = arr[i];
        // this byte is part of a multi-byte sequence, skip it
        // added to avoid modifying i within the loop which is considered unsafe.
        if (skip > 0) {
            skip--;
            continue;
        }
        // 1-byte sequence (0xxxxxxx)
        if (byte <= 0x7f) {
            result += String.fromCharCode(byte);
        }
        else if (byte >= 0xc0 && byte <= 0xdf) {
            // 2-byte sequence (110xxxxx 10xxxxxx)
            const byte2 = arr[i + 1];
            skip = 1;
            const codePoint = ((byte & 0x1f) << 6) | (byte2 & 0x3f);
            result += String.fromCharCode(codePoint);
        }
        else if (byte >= 0xe0 && byte <= 0xef) {
            // 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)
            const byte2 = arr[i + 1];
            const byte3 = arr[i + 2];
            skip = 2;
            const codePoint = ((byte & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f);
            result += String.fromCharCode(codePoint);
        }
        else if (byte >= 0xf0 && byte <= 0xf7) {
            // 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)
            const byte2 = arr[i + 1];
            const byte3 = arr[i + 2];
            const byte4 = arr[i + 3];
            skip = 3;
            const codePoint = ((byte & 0x07) << 18) |
                ((byte2 & 0x3f) << 12) |
                ((byte3 & 0x3f) << 6) |
                (byte4 & 0x3f);
            // Convert to UTF-16 surrogate pair
            const surrogate1 = 0xd800 + ((codePoint - 0x10000) >> 10);
            const surrogate2 = 0xdc00 + ((codePoint - 0x10000) & 0x3ff);
            result += String.fromCharCode(surrogate1, surrogate2);
        }
    }
    return result;
};
exports.toUTF8 = toUTF8;
/**
 * Encodes an array of numbers into a specified encoding ('hex' or 'utf8'). If no encoding is provided, returns the original array.
 * @param {number[]} arr - The input array of numbers.
 * @param {('hex' | 'utf8')} enc - The desired encoding.
 * @returns {string | number[]} - The encoded message as a string (for 'hex' and 'utf8') or the original array.
 */
const encode = (arr, enc) => {
    switch (enc) {
        case 'hex':
            return (0, exports.toHex)(arr);
        case 'utf8':
            return (0, exports.toUTF8)(arr);
        // If no encoding is provided, return the original array
        default:
            return arr;
    }
};
exports.encode = encode;
/**
 * Converts an array of bytes (each between 0 and 255) into a base64 encoded string.
 *
 * @param {number[]} byteArray - An array of numbers where each number is a byte (0-255).
 * @returns {string} The base64 encoded string.
 *
 * @example
 * const bytes = [72, 101, 108, 108, 111]; // Represents the string "Hello"
 * console.log(toBase64(bytes)); // Outputs: SGVsbG8=
 */
function toBase64(byteArray) {
    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';
    let i;
    for (i = 0; i < byteArray.length; i += 3) {
        const byte1 = byteArray[i];
        const byte2 = i + 1 < byteArray.length ? byteArray[i + 1] : 0;
        const byte3 = i + 2 < byteArray.length ? byteArray[i + 2] : 0;
        const encoded1 = byte1 >> 2;
        const encoded2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
        const encoded3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
        const encoded4 = byte3 & 0x3f;
        result += base64Chars.charAt(encoded1) + base64Chars.charAt(encoded2);
        result += i + 1 < byteArray.length ? base64Chars.charAt(encoded3) : '=';
        result += i + 2 < byteArray.length ? base64Chars.charAt(encoded4) : '=';
    }
    return result;
}
exports.toBase64 = toBase64;
const base58chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
/**
 * Converts a string from base58 to a binary array
 * @param str - The string representation
 * @returns The binary representation
 */
const fromBase58 = (str) => {
    if (str === '' || typeof str !== 'string') {
        throw new Error(`Expected base58 string but got “${str}”`);
    }
    const match = str.match(/[IOl0]/gmu);
    if (match !== null) {
        throw new Error(`Invalid base58 character “${match.join('')}”`);
    }
    const lz = str.match(/^1+/gmu);
    const psz = (lz !== null) ? lz[0].length : 0;
    const size = ((str.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;
    const uint8 = new Uint8Array([
        ...new Uint8Array(psz),
        ...(str.match(/./gmu) ?? [] // ✅ Safe Fix: If null, use []
        )
            .map((i) => base58chars.indexOf(i))
            .reduce((acc, i) => {
            acc = acc.map((j) => {
                const x = j * 58 + i;
                i = x >> 8;
                return x;
            });
            return acc;
        }, new Uint8Array(size))
            .reverse()
            .filter(((lastValue) => (value) => 
        // @ts-expect-error
        (lastValue = lastValue || value))(false))
    ]);
    return [...uint8];
};
exports.fromBase58 = fromBase58;
/**
 * Converts a binary array into a base58 string
 * @param bin - The binary array to convert to base58
 * @returns The base58 string representation
 */
const toBase58 = (bin) => {
    const base58Map = Array(256).fill(-1);
    for (let i = 0; i < base58chars.length; ++i) {
        base58Map[base58chars.charCodeAt(i)] = i;
    }
    const result = [];
    for (const byte of bin) {
        let carry = byte;
        for (let j = 0; j < result.length; ++j) {
            const x = (base58Map[result[j]] << 8) + carry;
            result[j] = base58chars.charCodeAt(x % 58);
            carry = (x / 58) | 0;
        }
        while (carry !== 0) {
            result.push(base58chars.charCodeAt(carry % 58));
            carry = (carry / 58) | 0;
        }
    }
    for (const byte of bin) {
        if (byte !== 0)
            break;
        else
            result.push('1'.charCodeAt(0));
    }
    result.reverse();
    return String.fromCharCode(...result);
};
exports.toBase58 = toBase58;
/**
 * Converts a binary array into a base58check string with a checksum
 * @param bin - The binary array to convert to base58check
 * @returns The base58check string representation
 */
const toBase58Check = (bin, prefix = [0]) => {
    let hash = (0, Hash_js_1.hash256)([...prefix, ...bin]);
    hash = [...prefix, ...bin, ...hash.slice(0, 4)];
    return (0, exports.toBase58)(hash);
};
exports.toBase58Check = toBase58Check;
/**
 * Converts a base58check string into a binary array after validating the checksum
 * @param str - The base58check string to convert to binary
 * @param enc - If hex, the return values will be hex strings, arrays of numbers otherwise
 * @param prefixLength - The length of the prefix. Optional, defaults to 1.
 * @returns The binary array representation
 */
const fromBase58Check = (str, enc, prefixLength = 1) => {
    const bin = (0, exports.fromBase58)(str);
    let prefix = bin.slice(0, prefixLength);
    let data = bin.slice(prefixLength, -4);
    let hash = [...prefix, ...data];
    hash = (0, Hash_js_1.hash256)(hash);
    bin.slice(-4).forEach((check, index) => {
        if (check !== hash[index]) {
            throw new Error('Invalid checksum');
        }
    });
    if (enc === 'hex') {
        prefix = (0, exports.toHex)(prefix);
        data = (0, exports.toHex)(data);
    }
    return { prefix, data };
};
exports.fromBase58Check = fromBase58Check;
class Writer {
    constructor(bufs) {
        this.bufs = bufs !== undefined ? bufs : [];
        this.length = 0;
        for (const b of this.bufs)
            this.length += b.length;
    }
    getLength() {
        return this.length;
    }
    toArray() {
        const totalLength = this.length;
        const ret = new Array(totalLength);
        let offset = 0;
        for (const buf of this.bufs) {
            for (const value of buf) {
                ret[offset++] = value;
            }
        }
        return ret;
    }
    write(buf) {
        this.bufs.push(buf);
        this.length += buf.length;
        return this;
    }
    writeReverse(buf) {
        const buf2 = new Array(buf.length);
        for (let i = 0; i < buf2.length; i++) {
            buf2[i] = buf[buf.length - 1 - i];
        }
        this.bufs.push(buf2);
        this.length += buf2.length;
        return this;
    }
    writeUInt8(n) {
        const buf = new Array(1);
        buf[0] = n;
        this.write(buf);
        return this;
    }
    writeInt8(n) {
        const buf = new Array(1);
        buf[0] = n & 0xff;
        this.write(buf);
        return this;
    }
    writeUInt16BE(n) {
        const buf = [
            (n >> 8) & 0xff,
            n & 0xff // low byte is just the last 8 bits
        ];
        this.bufs.push(buf);
        this.length += 2;
        return this;
    }
    writeInt16BE(n) {
        return this.writeUInt16BE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits
    }
    writeUInt16LE(n) {
        const buf = [
            n & 0xff,
            (n >> 8) & 0xff // shift right 8 bits to get the high byte
        ];
        this.bufs.push(buf);
        this.length += 2;
        return this;
    }
    writeInt16LE(n) {
        return this.writeUInt16LE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits
    }
    writeUInt32BE(n) {
        const buf = [
            (n >> 24) & 0xff,
            (n >> 16) & 0xff,
            (n >> 8) & 0xff,
            n & 0xff // lowest byte
        ];
        this.bufs.push(buf);
        this.length += 4;
        return this;
    }
    writeInt32BE(n) {
        return this.writeUInt32BE(n >>> 0); // Using unsigned right shift to handle negative numbers
    }
    writeUInt32LE(n) {
        const buf = [
            n & 0xff,
            (n >> 8) & 0xff,
            (n >> 16) & 0xff,
            (n >> 24) & 0xff // highest byte
        ];
        this.bufs.push(buf);
        this.length += 4;
        return this;
    }
    writeInt32LE(n) {
        return this.writeUInt32LE(n >>> 0); // Using unsigned right shift to handle negative numbers
    }
    writeUInt64BEBn(bn) {
        const buf = bn.toArray('be', 8);
        this.write(buf);
        return this;
    }
    writeUInt64LEBn(bn) {
        const buf = bn.toArray('be', 8);
        this.writeReverse(buf);
        return this;
    }
    writeUInt64LE(n) {
        const buf = new BigNumber_js_1.default(n).toArray('be', 8);
        this.writeReverse(buf);
        return this;
    }
    writeVarIntNum(n) {
        const buf = Writer.varIntNum(n);
        this.write(buf);
        return this;
    }
    writeVarIntBn(bn) {
        const buf = Writer.varIntBn(bn);
        this.write(buf);
        return this;
    }
    static varIntNum(n) {
        let buf;
        if (n < 0) {
            return this.varIntBn(new BigNumber_js_1.default(n));
        }
        if (n < 253) {
            buf = [n]; // 1 byte
        }
        else if (n < 0x10000) {
            // 253 followed by the number in little-endian format
            buf = [
                253,
                n & 0xff,
                (n >> 8) & 0xff // high byte
            ];
        }
        else if (n < 0x100000000) {
            // 254 followed by the number in little-endian format
            buf = [
                254,
                n & 0xff,
                (n >> 8) & 0xff,
                (n >> 16) & 0xff,
                (n >> 24) & 0xff
            ];
        }
        else {
            // 255 followed by the number in little-endian format
            // Since JavaScript bitwise operations work on 32 bits, we need to handle 64-bit numbers in two parts
            const low = n & 0xffffffff;
            const high = Math.floor(n / 0x100000000) & 0xffffffff;
            buf = [
                255,
                low & 0xff,
                (low >> 8) & 0xff,
                (low >> 16) & 0xff,
                (low >> 24) & 0xff,
                high & 0xff,
                (high >> 8) & 0xff,
                (high >> 16) & 0xff,
                (high >> 24) & 0xff
            ];
        }
        return buf;
    }
    static varIntBn(bn) {
        let buf;
        if (bn.isNeg()) {
            bn = bn.add(OverflowUint64); // Adjust for negative numbers
        }
        if (bn.ltn(253)) {
            const n = bn.toNumber();
            // No need for bitwise operation as the value is within a byte's range
            buf = [n];
        }
        else if (bn.ltn(0x10000)) {
            const n = bn.toNumber();
            // Value fits in a uint16
            buf = [253, n & 0xff, (n >> 8) & 0xff];
        }
        else if (bn.lt(new BigNumber_js_1.default(0x100000000))) {
            const n = bn.toNumber();
            // Value fits in a uint32
            buf = [
                254,
                n & 0xff,
                (n >> 8) & 0xff,
                (n >> 16) & 0xff,
                (n >> 24) & 0xff
            ];
        }
        else {
            const bw = new Writer();
            bw.writeUInt8(255);
            bw.writeUInt64LEBn(bn);
            buf = bw.toArray();
        }
        return buf;
    }
}
exports.Writer = Writer;
class Reader {
    constructor(bin = [], pos = 0) {
        this.bin = bin;
        this.pos = pos;
        this.length = bin.length;
    }
    eof() {
        return this.pos >= this.length;
    }
    read(len = this.length) {
        const start = this.pos;
        const end = this.pos + len;
        this.pos = end;
        return this.bin.slice(start, end);
    }
    readReverse(len = this.length) {
        const buf2 = new Array(len);
        for (let i = 0; i < len; i++) {
            buf2[i] = this.bin[this.pos + len - 1 - i];
        }
        this.pos += len;
        return buf2;
    }
    readUInt8() {
        const val = this.bin[this.pos];
        this.pos += 1;
        return val;
    }
    readInt8() {
        const val = this.bin[this.pos];
        this.pos += 1;
        // If the sign bit is set, convert to negative value
        return (val & 0x80) !== 0 ? val - 0x100 : val;
    }
    readUInt16BE() {
        const val = (this.bin[this.pos] << 8) | this.bin[this.pos + 1];
        this.pos += 2;
        return val;
    }
    readInt16BE() {
        const val = this.readUInt16BE();
        // If the sign bit is set, convert to negative value
        return (val & 0x8000) !== 0 ? val - 0x10000 : val;
    }
    readUInt16LE() {
        const val = this.bin[this.pos] | (this.bin[this.pos + 1] << 8);
        this.pos += 2;
        return val;
    }
    readInt16LE() {
        const val = this.readUInt16LE();
        // If the sign bit is set, convert to negative value
        const x = (val & 0x8000) !== 0 ? val - 0x10000 : val;
        return x;
    }
    readUInt32BE() {
        const val = this.bin[this.pos] * 0x1000000 + // Shift the first byte by 24 bits
            ((this.bin[this.pos + 1] << 16) | // Shift the second byte by 16 bits
                (this.bin[this.pos + 2] << 8) | // Shift the third byte by 8 bits
                this.bin[this.pos + 3]); // The fourth byte
        this.pos += 4;
        return val;
    }
    readInt32BE() {
        const val = this.readUInt32BE();
        // If the sign bit is set, convert to negative value
        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;
    }
    readUInt32LE() {
        const val = (this.bin[this.pos] |
            (this.bin[this.pos + 1] << 8) |
            (this.bin[this.pos + 2] << 16) |
            (this.bin[this.pos + 3] << 24)) >>>
            0;
        this.pos += 4;
        return val;
    }
    readInt32LE() {
        const val = this.readUInt32LE();
        // Explicitly check if the sign bit is set and then convert to a negative value
        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;
    }
    readUInt64BEBn() {
        const bin = this.bin.slice(this.pos, this.pos + 8);
        const bn = new BigNumber_js_1.default(bin);
        this.pos = this.pos + 8;
        return bn;
    }
    readUInt64LEBn() {
        const bin = this.readReverse(8);
        const bn = new BigNumber_js_1.default(bin);
        return bn;
    }
    readInt64LEBn() {
        const bin = this.readReverse(8);
        let bn = new BigNumber_js_1.default(bin);
        if (bn.gte(OverflowInt64)) {
            bn = bn.sub(OverflowUint64); // Adjust for negative numbers
        }
        return bn;
    }
    readVarIntNum(signed = true) {
        const first = this.readUInt8();
        let bn;
        switch (first) {
            case 0xfd:
                return this.readUInt16LE();
            case 0xfe:
                return this.readUInt32LE();
            case 0xff:
                bn = signed ? this.readInt64LEBn() : this.readUInt64LEBn();
                if (bn.lte(new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(53)))) {
                    return bn.toNumber();
                }
                else {
                    throw new Error('number too large to retain precision - use readVarIntBn');
                }
            default:
                return first;
        }
    }
    readVarInt() {
        const first = this.bin[this.pos];
        switch (first) {
            case 0xfd:
                return this.read(1 + 2);
            case 0xfe:
                return this.read(1 + 4);
            case 0xff:
                return this.read(1 + 8);
            default:
                return this.read(1);
        }
    }
    readVarIntBn() {
        const first = this.readUInt8();
        switch (first) {
            case 0xfd:
                return new BigNumber_js_1.default(this.readUInt16LE());
            case 0xfe:
                return new BigNumber_js_1.default(this.readUInt32LE());
            case 0xff:
                return this.readUInt64LEBn();
            default:
                return new BigNumber_js_1.default(first);
        }
    }
}
exports.Reader = Reader;
const minimallyEncode = (buf) => {
    if (buf.length === 0) {
        return buf;
    }
    // If the last byte is not 0x00 or 0x80, we are minimally encoded.
    const last = buf[buf.length - 1];
    if ((last & 0x7f) !== 0) {
        return buf;
    }
    // If the script is one byte long, then we have a zero, which encodes as an
    // empty array.
    if (buf.length === 1) {
        return [];
    }
    // If the next byte has it sign bit set, then we are minimaly encoded.
    if ((buf[buf.length - 2] & 0x80) !== 0) {
        return buf;
    }
    // We are not minimally encoded, we need to figure out how much to trim.
    for (let i = buf.length - 1; i > 0; i--) {
        // We found a non zero byte, time to encode.
        if (buf[i - 1] !== 0) {
            if ((buf[i - 1] & 0x80) !== 0) {
                // We found a byte with it sign bit set so we need one more
                // byte.
                buf[i] = last;
                return buf.slice(0, i + 1);
            }
            else {
                // the sign bit is clear, we can use it.
                buf[i - 1] |= last;
                return buf.slice(0, i);
            }
        }
    }
    // If we found the whole thing is zeros, then we have a zero.
    return [];
};
exports.minimallyEncode = minimallyEncode;
const OverflowInt64 = new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(63));
const OverflowUint64 = new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(64));

},{"./BigNumber.js":42,"./Hash.js":46}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeWalletProtocol = exports.RegistryClient = void 0;
const index_js_1 = require("../wallet/index.js");
const index_js_2 = require("../primitives/index.js");
const index_js_3 = require("../transaction/index.js");
const index_js_4 = require("../overlay-tools/index.js");
const index_js_5 = require("../script/index.js");
const REGISTRANT_TOKEN_AMOUNT = 1;
/**
 * RegistryClient manages on-chain registry definitions for three types:
 * - basket (basket-based items)
 * - protocol (protocol-based items)
 * - certificate (certificate-based items)
 *
 * It provides methods to:
 * - Register new definitions using pushdrop-based UTXOs.
 * - Resolve existing definitions using a lookup service.
 * - List registry entries associated with the operator's wallet.
 * - Revoke an existing registry entry by spending its UTXO.
 *
 * Registry operators use this client to establish and manage
 * canonical references for baskets, protocols, and certificate types.
 */
class RegistryClient {
    constructor(wallet = new index_js_1.WalletClient()) {
        this.wallet = wallet;
    }
    /**
     * Publishes a new on-chain definition for baskets, protocols, or certificates.
     * The definition data is encoded in a pushdrop-based UTXO.
     *
     * Registry operators (i.e., identity key owners) can create these definitions
     * to establish canonical references for basket IDs, protocol specs, or certificate schemas.
     *
     * @param data - Structured information about a 'basket', 'protocol', or 'certificate'.
     * @returns A promise with the broadcast result or failure.
     */
    async registerDefinition(data) {
        const registryOperator = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;
        const pushdrop = new index_js_5.PushDrop(this.wallet);
        // Convert definition data into PushDrop fields
        const fields = this.buildPushDropFields(data, registryOperator);
        // Convert the user-friendly definitionType to the actual wallet protocol
        const protocol = this.mapDefinitionTypeToWalletProtocol(data.definitionType);
        // Lock the fields into a pushdrop-based UTXO
        const lockingScript = await pushdrop.lock(fields, protocol, '1', 'anyone', true);
        // Create a transaction
        const { tx } = await this.wallet.createAction({
            description: `Register a new ${data.definitionType} item`,
            outputs: [
                {
                    satoshis: REGISTRANT_TOKEN_AMOUNT,
                    lockingScript: lockingScript.toHex(),
                    outputDescription: `New ${data.definitionType} registration token`,
                    basket: this.mapDefinitionTypeToBasketName(data.definitionType)
                }
            ],
            options: {
                randomizeOutputs: false
            }
        });
        if (tx === undefined) {
            throw new Error(`Failed to create ${data.definitionType} registration transaction!`);
        }
        // Broadcast to the relevant topic
        const broadcaster = new index_js_4.TopicBroadcaster([this.mapDefinitionTypeToTopic(data.definitionType)], {
            networkPreset: this.network ?? (this.network = (await this.wallet.getNetwork({})).network)
        });
        return await broadcaster.broadcast(index_js_3.Transaction.fromAtomicBEEF(tx));
    }
    /**
     * Resolves registrant tokens of a particular type using a lookup service.
     *
     * The query object shape depends on the registry type:
     * - For "basket", the query is of type BasketMapQuery:
     *   { basketID?: string; name?: string; registryOperators?: string[]; }
     * - For "protocol", the query is of type ProtoMapQuery:
     *   { name?: string; registryOperators?: string[]; protocolID?: WalletProtocol; }
     * - For "certificate", the query is of type CertMapQuery:
     *   { type?: string; name?: string; registryOperators?: string[]; }
     *
     * @param definitionType - The registry type, which can be 'basket', 'protocol', or 'certificate'.
     * @param query - The query object used to filter registry records, whose shape is determined by the registry type.
     * @returns A promise that resolves to an array of matching registry records.
     */
    async resolve(definitionType, query) {
        const resolver = new index_js_4.LookupResolver();
        const serviceName = this.mapDefinitionTypeToServiceName(definitionType);
        // Make the lookup query
        const result = await resolver.query({ service: serviceName, query });
        if (result.type !== 'output-list') {
            return [];
        }
        const parsedRegistryRecords = [];
        for (const output of result.outputs) {
            try {
                const parsedTx = index_js_3.Transaction.fromBEEF(output.beef);
                const lockingScript = parsedTx.outputs[output.outputIndex].lockingScript;
                const record = await this.parseLockingScript(definitionType, lockingScript);
                parsedRegistryRecords.push(record);
            }
            catch {
                // Skip invalid or non-pushdrop outputs
            }
        }
        return parsedRegistryRecords;
    }
    /**
     * Lists the registry operator's published definitions for the given type.
     *
     * Returns parsed registry records including transaction details such as txid, outputIndex, satoshis, and the locking script.
     *
     * @param definitionType - The type of registry definition to list ('basket', 'protocol', or 'certificate').
     * @returns A promise that resolves to an array of RegistryRecord objects.
     */
    async listOwnRegistryEntries(definitionType) {
        const relevantBasketName = this.mapDefinitionTypeToBasketName(definitionType);
        const { outputs, BEEF } = await this.wallet.listOutputs({
            basket: relevantBasketName,
            include: 'entire transactions'
        });
        const results = [];
        for (const output of outputs) {
            if (!output.spendable) {
                continue;
            }
            try {
                const [txid, outputIndex] = output.outpoint.split('.');
                const tx = index_js_3.Transaction.fromBEEF(BEEF);
                const lockingScript = tx.outputs[outputIndex].lockingScript;
                const record = await this.parseLockingScript(definitionType, lockingScript);
                results.push({
                    ...record,
                    txid,
                    outputIndex: Number(outputIndex),
                    satoshis: output.satoshis,
                    lockingScript: lockingScript.toHex(),
                    beef: BEEF
                });
            }
            catch {
                // Ignore parse errors
            }
        }
        return results;
    }
    /**
     * Revokes a registry record by spending its associated UTXO.
     *
     * @param registryRecord - Must have valid txid, outputIndex, and lockingScript.
     * @returns Broadcast success/failure.
     */
    async revokeOwnRegistryEntry(registryRecord) {
        if (registryRecord.txid === undefined || typeof registryRecord.outputIndex === 'undefined' || registryRecord.lockingScript === undefined) {
            throw new Error('Invalid registry record. Missing txid, outputIndex, or lockingScript.');
        }
        // Check if the registry record belongs to the current user
        const currentIdentityKey = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;
        if (registryRecord.registryOperator !== currentIdentityKey) {
            throw new Error('This registry token does not belong to the current wallet.');
        }
        // Create a descriptive label for the item we’re revoking
        const itemIdentifier = registryRecord.definitionType === 'basket'
            ? registryRecord.basketID
            : registryRecord.definitionType === 'protocol'
                ? registryRecord.name
                : registryRecord.definitionType === 'certificate'
                    ? (registryRecord.name !== undefined ? registryRecord.name : registryRecord.type)
                    : 'unknown';
        const outpoint = `${registryRecord.txid}.${registryRecord.outputIndex}`;
        const { signableTransaction } = await this.wallet.createAction({
            description: `Revoke ${registryRecord.definitionType} item: ${itemIdentifier}`,
            inputBEEF: registryRecord.beef,
            inputs: [
                {
                    outpoint,
                    unlockingScriptLength: 73,
                    inputDescription: `Revoking ${registryRecord.definitionType} token`
                }
            ]
        });
        if (signableTransaction === undefined) {
            throw new Error('Failed to create signable transaction.');
        }
        const partialTx = index_js_3.Transaction.fromBEEF(signableTransaction.tx);
        // Prepare the unlocker
        const pushdrop = new index_js_5.PushDrop(this.wallet);
        const unlocker = await pushdrop.unlock(this.mapDefinitionTypeToWalletProtocol(registryRecord.definitionType), '1', 'anyone', 'all', false, registryRecord.satoshis, index_js_5.LockingScript.fromHex(registryRecord.lockingScript));
        // Convert to Transaction, apply signature
        const finalUnlockScript = await unlocker.sign(partialTx, registryRecord.outputIndex);
        // Complete signing with the final unlock script
        const { tx: signedTx } = await this.wallet.signAction({
            reference: signableTransaction.reference,
            spends: {
                [registryRecord.outputIndex]: {
                    unlockingScript: finalUnlockScript.toHex()
                }
            },
            options: {
                acceptDelayedBroadcast: false
            }
        });
        if (signedTx === undefined) {
            throw new Error('Failed to finalize the transaction signature.');
        }
        // Broadcast
        const broadcaster = new index_js_4.TopicBroadcaster([this.mapDefinitionTypeToTopic(registryRecord.definitionType)], {
            networkPreset: this.network ?? (this.network = (await this.wallet.getNetwork({})).network)
        });
        return await broadcaster.broadcast(index_js_3.Transaction.fromAtomicBEEF(signedTx));
    }
    // --------------------------------------------------------------------------
    // INTERNAL UTILITY METHODS
    // --------------------------------------------------------------------------
    /**
     * Convert definition data into an array of pushdrop fields (strings).
     * Each definition type has a slightly different shape.
     */
    buildPushDropFields(data, registryOperator) {
        let fields;
        switch (data.definitionType) {
            case 'basket':
                fields = [
                    data.basketID,
                    data.name,
                    data.iconURL,
                    data.description,
                    data.documentationURL
                ];
                break;
            case 'protocol':
                fields = [
                    JSON.stringify(data.protocolID),
                    data.name,
                    data.iconURL,
                    data.description,
                    data.documentationURL
                ];
                break;
            case 'certificate':
                fields = [
                    data.type,
                    data.name,
                    data.iconURL,
                    data.description,
                    data.documentationURL,
                    JSON.stringify(data.fields)
                ];
                break;
            default:
                throw new Error('Unsupported definition type');
        }
        // Append the operator's public identity key last
        fields.push(registryOperator);
        return fields.map(field => index_js_2.Utils.toArray(field));
    }
    /**
     * Decodes a pushdrop locking script for a given definition type,
     * returning a typed record with the appropriate fields.
     */
    async parseLockingScript(definitionType, lockingScript) {
        const decoded = index_js_5.PushDrop.decode(lockingScript);
        if (decoded.fields.length === 0) {
            throw new Error('Not a valid registry pushdrop script.');
        }
        let registryOperator;
        let parsedData;
        switch (definitionType) {
            case 'basket': {
                if (decoded.fields.length !== 7) {
                    throw new Error('Unexpected field count for basket type.');
                }
                const [basketID, name, iconURL, description, docURL, operator] = decoded.fields;
                registryOperator = index_js_2.Utils.toUTF8(operator);
                parsedData = {
                    definitionType: 'basket',
                    basketID: index_js_2.Utils.toUTF8(basketID),
                    name: index_js_2.Utils.toUTF8(name),
                    iconURL: index_js_2.Utils.toUTF8(iconURL),
                    description: index_js_2.Utils.toUTF8(description),
                    documentationURL: index_js_2.Utils.toUTF8(docURL)
                };
                break;
            }
            case 'protocol': {
                if (decoded.fields.length !== 7) {
                    throw new Error('Unexpected field count for protocol type.');
                }
                const [protocolID, name, iconURL, description, docURL, operator] = decoded.fields;
                registryOperator = index_js_2.Utils.toUTF8(operator);
                parsedData = {
                    definitionType: 'protocol',
                    protocolID: deserializeWalletProtocol(index_js_2.Utils.toUTF8(protocolID)),
                    name: index_js_2.Utils.toUTF8(name),
                    iconURL: index_js_2.Utils.toUTF8(iconURL),
                    description: index_js_2.Utils.toUTF8(description),
                    documentationURL: index_js_2.Utils.toUTF8(docURL)
                };
                break;
            }
            case 'certificate': {
                if (decoded.fields.length !== 8) {
                    throw new Error('Unexpected field count for certificate type.');
                }
                const [certType, name, iconURL, description, docURL, fieldsJSON, operator] = decoded.fields;
                registryOperator = index_js_2.Utils.toUTF8(operator);
                let parsedFields = {};
                try {
                    parsedFields = JSON.parse(index_js_2.Utils.toUTF8(fieldsJSON));
                }
                catch {
                    // If there's a JSON parse error, assume empty
                }
                parsedData = {
                    definitionType: 'certificate',
                    type: index_js_2.Utils.toUTF8(certType),
                    name: index_js_2.Utils.toUTF8(name),
                    iconURL: index_js_2.Utils.toUTF8(iconURL),
                    description: index_js_2.Utils.toUTF8(description),
                    documentationURL: index_js_2.Utils.toUTF8(docURL),
                    fields: parsedFields
                };
                break;
            }
            default:
                throw new Error(`Unsupported definition type: ${definitionType}`);
        }
        // Return the typed data plus the operator key
        return { ...parsedData, registryOperator };
    }
    /**
     * Convert our definitionType to the wallet protocol format ([protocolID, keyID]).
     */
    mapDefinitionTypeToWalletProtocol(definitionType) {
        switch (definitionType) {
            case 'basket':
                return [1, 'basketmap'];
            case 'protocol':
                return [1, 'protomap'];
            case 'certificate':
                return [1, 'certmap'];
            default:
                throw new Error(`Unknown definition type: ${definitionType}`);
        }
    }
    /**
     * Convert 'basket'|'protocol'|'certificate' to the basket name used by the wallet.
     */
    mapDefinitionTypeToBasketName(definitionType) {
        switch (definitionType) {
            case 'basket':
                return 'basketmap';
            case 'protocol':
                return 'protomap';
            case 'certificate':
                return 'certmap';
            default:
                throw new Error(`Unknown definition type: ${definitionType}`);
        }
    }
    /**
     * Convert 'basket'|'protocol'|'certificate' to the broadcast topic name.
     */
    mapDefinitionTypeToTopic(definitionType) {
        switch (definitionType) {
            case 'basket':
                return 'tm_basketmap';
            case 'protocol':
                return 'tm_protomap';
            case 'certificate':
                return 'tm_certmap';
            default:
                throw new Error(`Unknown definition type: ${definitionType}`);
        }
    }
    /**
     * Convert 'basket'|'protocol'|'certificate' to the lookup service name.
     */
    mapDefinitionTypeToServiceName(definitionType) {
        switch (definitionType) {
            case 'basket':
                return 'ls_basketmap';
            case 'protocol':
                return 'ls_protomap';
            case 'certificate':
                return 'ls_certmap';
            default:
                throw new Error(`Unknown definition type: ${definitionType}`);
        }
    }
}
exports.RegistryClient = RegistryClient;
function deserializeWalletProtocol(str) {
    // Parse the JSON string back into a JavaScript value.
    const parsed = JSON.parse(str);
    // Validate that the parsed value is an array with exactly two elements.
    if (!Array.isArray(parsed) || parsed.length !== 2) {
        throw new Error('Invalid wallet protocol format.');
    }
    const [security, protocolString] = parsed;
    // Validate that the security level is one of the allowed numbers.
    if (![0, 1, 2].includes(security)) {
        throw new Error('Invalid security level.');
    }
    // Validate that the protocol string is a string and its length is within the allowed bounds.
    if (typeof protocolString !== 'string') {
        throw new Error('Invalid protocolID');
    }
    return [security, protocolString];
}
exports.deserializeWalletProtocol = deserializeWalletProtocol;

},{"../overlay-tools/index.js":39,"../primitives/index.js":61,"../script/index.js":72,"../transaction/index.js":105,"../wallet/index.js":113}],64:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./RegistryClient.js"), exports);
__exportStar(require("./types/index.js"), exports);

},{"./RegistryClient.js":63,"./types/index.js":65}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],66:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Script_js_1 = __importDefault(require("./Script.js"));
/**
 * The LockingScript class represents a locking script in a Bitcoin SV transaction.
 * It extends the Script class and is used specifically for output scripts that lock funds.
 *
 * Inherits all properties and methods from the Script class.
 *
 * @extends {Script}
 * @see {@link Script} for more information on Script.
 */
class LockingScript extends Script_js_1.default {
    /**
     * @method isLockingScript
     * Determines if the script is a locking script.
     * @returns {boolean} Always returns true for a LockingScript instance.
     */
    isLockingScript() {
        return true;
    }
    /**
     * @method isUnlockingScript
     * Determines if the script is an unlocking script.
     * @returns {boolean} Always returns false for a LockingScript instance.
     */
    isUnlockingScript() {
        return false;
    }
}
exports.default = LockingScript;

},{"./Script.js":68}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An object mapping opcode names (such as OP_DUP) to their corresponding numbers (such as 0x76), and vice versa.
 */
const OP = {
    // push value
    OP_FALSE: 0x00,
    OP_0: 0x00,
    OP_PUSHDATA1: 0x4c,
    OP_PUSHDATA2: 0x4d,
    OP_PUSHDATA4: 0x4e,
    OP_1NEGATE: 0x4f,
    OP_RESERVED: 0x50,
    OP_TRUE: 0x51,
    OP_1: 0x51,
    OP_2: 0x52,
    OP_3: 0x53,
    OP_4: 0x54,
    OP_5: 0x55,
    OP_6: 0x56,
    OP_7: 0x57,
    OP_8: 0x58,
    OP_9: 0x59,
    OP_10: 0x5a,
    OP_11: 0x5b,
    OP_12: 0x5c,
    OP_13: 0x5d,
    OP_14: 0x5e,
    OP_15: 0x5f,
    OP_16: 0x60,
    // control
    OP_NOP: 0x61,
    OP_VER: 0x62,
    OP_IF: 0x63,
    OP_NOTIF: 0x64,
    OP_VERIF: 0x65,
    OP_VERNOTIF: 0x66,
    OP_ELSE: 0x67,
    OP_ENDIF: 0x68,
    OP_VERIFY: 0x69,
    OP_RETURN: 0x6a,
    // stack ops
    OP_TOALTSTACK: 0x6b,
    OP_FROMALTSTACK: 0x6c,
    OP_2DROP: 0x6d,
    OP_2DUP: 0x6e,
    OP_3DUP: 0x6f,
    OP_2OVER: 0x70,
    OP_2ROT: 0x71,
    OP_2SWAP: 0x72,
    OP_IFDUP: 0x73,
    OP_DEPTH: 0x74,
    OP_DROP: 0x75,
    OP_DUP: 0x76,
    OP_NIP: 0x77,
    OP_OVER: 0x78,
    OP_PICK: 0x79,
    OP_ROLL: 0x7a,
    OP_ROT: 0x7b,
    OP_SWAP: 0x7c,
    OP_TUCK: 0x7d,
    // data manipulation ops
    OP_CAT: 0x7e,
    OP_SUBSTR: 0x7f,
    OP_SPLIT: 0x7f,
    OP_LEFT: 0x80,
    OP_NUM2BIN: 0x80,
    OP_RIGHT: 0x81,
    OP_BIN2NUM: 0x81,
    OP_SIZE: 0x82,
    // bit logic
    OP_INVERT: 0x83,
    OP_AND: 0x84,
    OP_OR: 0x85,
    OP_XOR: 0x86,
    OP_EQUAL: 0x87,
    OP_EQUALVERIFY: 0x88,
    OP_RESERVED1: 0x89,
    OP_RESERVED2: 0x8a,
    // numeric
    OP_1ADD: 0x8b,
    OP_1SUB: 0x8c,
    OP_2MUL: 0x8d,
    OP_2DIV: 0x8e,
    OP_NEGATE: 0x8f,
    OP_ABS: 0x90,
    OP_NOT: 0x91,
    OP_0NOTEQUAL: 0x92,
    OP_ADD: 0x93,
    OP_SUB: 0x94,
    OP_MUL: 0x95,
    OP_DIV: 0x96,
    OP_MOD: 0x97,
    OP_LSHIFT: 0x98,
    OP_RSHIFT: 0x99,
    OP_BOOLAND: 0x9a,
    OP_BOOLOR: 0x9b,
    OP_NUMEQUAL: 0x9c,
    OP_NUMEQUALVERIFY: 0x9d,
    OP_NUMNOTEQUAL: 0x9e,
    OP_LESSTHAN: 0x9f,
    OP_GREATERTHAN: 0xa0,
    OP_LESSTHANOREQUAL: 0xa1,
    OP_GREATERTHANOREQUAL: 0xa2,
    OP_MIN: 0xa3,
    OP_MAX: 0xa4,
    OP_WITHIN: 0xa5,
    // crypto
    OP_RIPEMD160: 0xa6,
    OP_SHA1: 0xa7,
    OP_SHA256: 0xa8,
    OP_HASH160: 0xa9,
    OP_HASH256: 0xaa,
    OP_CODESEPARATOR: 0xab,
    OP_CHECKSIG: 0xac,
    OP_CHECKSIGVERIFY: 0xad,
    OP_CHECKMULTISIG: 0xae,
    OP_CHECKMULTISIGVERIFY: 0xaf,
    // expansion
    OP_NOP1: 0xb0,
    OP_NOP2: 0xb1,
    OP_NOP3: 0xb2,
    OP_NOP4: 0xb3,
    OP_NOP5: 0xb4,
    OP_NOP6: 0xb5,
    OP_NOP7: 0xb6,
    OP_NOP8: 0xb7,
    OP_NOP9: 0xb8,
    OP_NOP10: 0xb9,
    OP_NOP11: 0xba,
    OP_NOP12: 0xbb,
    OP_NOP13: 0xbc,
    OP_NOP14: 0xbd,
    OP_NOP15: 0xbe,
    OP_NOP16: 0xbf,
    OP_NOP17: 0xc0,
    OP_NOP18: 0xc1,
    OP_NOP19: 0xc2,
    OP_NOP20: 0xc3,
    OP_NOP21: 0xc4,
    OP_NOP22: 0xc5,
    OP_NOP23: 0xc6,
    OP_NOP24: 0xc7,
    OP_NOP25: 0xc8,
    OP_NOP26: 0xc9,
    OP_NOP27: 0xca,
    OP_NOP28: 0xcb,
    OP_NOP29: 0xcc,
    OP_NOP30: 0xcd,
    OP_NOP31: 0xce,
    OP_NOP32: 0xcf,
    OP_NOP33: 0xd0,
    OP_NOP34: 0xd1,
    OP_NOP35: 0xd2,
    OP_NOP36: 0xd3,
    OP_NOP37: 0xd4,
    OP_NOP38: 0xd5,
    OP_NOP39: 0xd6,
    OP_NOP40: 0xd7,
    OP_NOP41: 0xd8,
    OP_NOP42: 0xd9,
    OP_NOP43: 0xda,
    OP_NOP44: 0xdb,
    OP_NOP45: 0xdc,
    OP_NOP46: 0xdd,
    OP_NOP47: 0xde,
    OP_NOP48: 0xdf,
    OP_NOP49: 0xe0,
    OP_NOP50: 0xe1,
    OP_NOP51: 0xe2,
    OP_NOP52: 0xe3,
    OP_NOP53: 0xe4,
    OP_NOP54: 0xe5,
    OP_NOP55: 0xe6,
    OP_NOP56: 0xe7,
    OP_NOP57: 0xe8,
    OP_NOP58: 0xe9,
    OP_NOP59: 0xea,
    OP_NOP60: 0xeb,
    OP_NOP61: 0xec,
    OP_NOP62: 0xed,
    OP_NOP63: 0xee,
    OP_NOP64: 0xef,
    OP_NOP65: 0xf0,
    OP_NOP66: 0xf1,
    OP_NOP67: 0xf2,
    OP_NOP68: 0xf3,
    OP_NOP69: 0xf4,
    OP_NOP70: 0xf5,
    OP_NOP71: 0xf6,
    OP_NOP72: 0xf7,
    OP_NOP73: 0xf8,
    OP_NOP77: 0xfc,
    // template matching params
    OP_SMALLDATA: 0xf9,
    OP_SMALLINTEGER: 0xfa,
    OP_PUBKEYS: 0xfb,
    OP_PUBKEYHASH: 0xfd,
    OP_PUBKEY: 0xfe,
    OP_INVALIDOPCODE: 0xff
};
for (const name in OP) {
    OP[OP[name]] = name;
}
exports.default = OP;

},{}],68:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const OP_js_1 = __importDefault(require("./OP.js"));
const utils_js_1 = require("../primitives/utils.js");
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
/**
 * The Script class represents a script in a Bitcoin SV transaction,
 * encapsulating the functionality to construct, parse, and serialize
 * scripts used in both locking (output) and unlocking (input) scripts.
 *
 * @property {ScriptChunk[]} chunks - An array of script chunks that make up the script.
 */
class Script {
    /**
     * @method fromASM
     * Static method to construct a Script instance from an ASM (Assembly) formatted string.
     * @param asm - The script in ASM string format.
     * @returns A new Script instance.
     * @example
     * const script = Script.fromASM("OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG")
     */
    static fromASM(asm) {
        const chunks = [];
        const tokens = asm.split(' ');
        let i = 0;
        while (i < tokens.length) {
            const token = tokens[i];
            let opCode;
            let opCodeNum = 0;
            if (token.startsWith('OP_') && typeof OP_js_1.default[token] !== 'undefined') {
                opCode = token;
                opCodeNum = OP_js_1.default[token];
            }
            // we start with two special cases, 0 and -1, which are handled specially in
            // toASM. see _chunkToString.
            if (token === '0') {
                opCodeNum = 0;
                chunks.push({
                    op: opCodeNum
                });
                i = i + 1;
            }
            else if (token === '-1') {
                opCodeNum = OP_js_1.default.OP_1NEGATE;
                chunks.push({
                    op: opCodeNum
                });
                i = i + 1;
            }
            else if (opCode === undefined) {
                let hex = tokens[i];
                if (hex.length % 2 !== 0) {
                    hex = '0' + hex;
                }
                const arr = (0, utils_js_1.toArray)(hex, 'hex');
                if ((0, utils_js_1.encode)(arr, 'hex') !== hex) {
                    throw new Error('invalid hex string in script');
                }
                const len = arr.length;
                if (len >= 0 && len < OP_js_1.default.OP_PUSHDATA1) {
                    opCodeNum = len;
                }
                else if (len < Math.pow(2, 8)) {
                    opCodeNum = OP_js_1.default.OP_PUSHDATA1;
                }
                else if (len < Math.pow(2, 16)) {
                    opCodeNum = OP_js_1.default.OP_PUSHDATA2;
                }
                else if (len < Math.pow(2, 32)) {
                    opCodeNum = OP_js_1.default.OP_PUSHDATA4;
                }
                chunks.push({
                    data: arr,
                    op: opCodeNum
                });
                i = i + 1;
            }
            else if (opCodeNum === OP_js_1.default.OP_PUSHDATA1 ||
                opCodeNum === OP_js_1.default.OP_PUSHDATA2 ||
                opCodeNum === OP_js_1.default.OP_PUSHDATA4) {
                chunks.push({
                    data: (0, utils_js_1.toArray)(tokens[i + 2], 'hex'),
                    op: opCodeNum
                });
                i = i + 3;
            }
            else {
                chunks.push({
                    op: opCodeNum
                });
                i = i + 1;
            }
        }
        return new Script(chunks);
    }
    /**
     * @method fromHex
     * Static method to construct a Script instance from a hexadecimal string.
     * @param hex - The script in hexadecimal format.
     * @returns A new Script instance.
     * @example
     * const script = Script.fromHex("76a9...");
     */
    static fromHex(hex) {
        if (hex.length === 0)
            return Script.fromBinary([]);
        if (hex.length % 2 !== 0) {
            throw new Error('There is an uneven number of characters in the string which suggests it is not hex encoded.');
        }
        if (!/^[0-9a-fA-F]+$/.test(hex)) {
            throw new Error('Some elements in this string are not hex encoded.');
        }
        return Script.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));
    }
    /**
     * @method fromBinary
     * Static method to construct a Script instance from a binary array.
     * @param bin - The script in binary array format.
     * @returns A new Script instance.
     * @example
     * const script = Script.fromBinary([0x76, 0xa9, ...])
     */
    static fromBinary(bin) {
        bin = [...bin];
        const chunks = [];
        let inConditionalBlock = 0;
        const br = new utils_js_1.Reader(bin);
        while (!br.eof()) {
            const op = br.readUInt8();
            // if OP_RETURN and not in a conditional block, do not parse the rest of the data,
            // rather just return the last chunk as data without prefixing with data length.
            if (op === OP_js_1.default.OP_RETURN && inConditionalBlock === 0) {
                chunks.push({
                    op,
                    data: br.read()
                });
                break;
            }
            if (op === OP_js_1.default.OP_IF || op === OP_js_1.default.OP_NOTIF || op === OP_js_1.default.OP_VERIF || op === OP_js_1.default.OP_VERNOTIF) {
                inConditionalBlock++;
            }
            else if (op === OP_js_1.default.OP_ENDIF) {
                inConditionalBlock--;
            }
            let len = 0;
            // eslint-disable-next-line @typescript-eslint/no-shadow
            let data = [];
            if (op > 0 && op < OP_js_1.default.OP_PUSHDATA1) {
                len = op;
                chunks.push({
                    data: br.read(len),
                    op
                });
            }
            else if (op === OP_js_1.default.OP_PUSHDATA1) {
                try {
                    len = br.readUInt8();
                    data = br.read(len);
                }
                catch {
                    br.read();
                }
                chunks.push({
                    data,
                    op
                });
            }
            else if (op === OP_js_1.default.OP_PUSHDATA2) {
                try {
                    len = br.readUInt16LE();
                    data = br.read(len);
                }
                catch {
                    br.read();
                }
                chunks.push({
                    data,
                    op
                });
            }
            else if (op === OP_js_1.default.OP_PUSHDATA4) {
                try {
                    len = br.readUInt32LE();
                    data = br.read(len);
                }
                catch {
                    br.read();
                }
                chunks.push({
                    data,
                    op
                });
            }
            else {
                chunks.push({
                    op
                });
            }
        }
        return new Script(chunks);
    }
    /**
     * @constructor
     * Constructs a new Script object.
     * @param chunks=[] - An array of script chunks to directly initialize the script.
     */
    constructor(chunks = []) {
        this.chunks = chunks;
    }
    /**
     * @method toASM
     * Serializes the script to an ASM formatted string.
     * @returns The script in ASM string format.
     */
    toASM() {
        let str = '';
        for (let i = 0; i < this.chunks.length; i++) {
            const chunk = this.chunks[i];
            str += this._chunkToString(chunk);
        }
        return str.slice(1);
    }
    /**
     * @method toHex
     * Serializes the script to a hexadecimal string.
     * @returns The script in hexadecimal format.
     */
    toHex() {
        return (0, utils_js_1.encode)(this.toBinary(), 'hex');
    }
    /**
     * @method toBinary
     * Serializes the script to a binary array.
     * @returns The script in binary array format.
     */
    toBinary() {
        const writer = new utils_js_1.Writer();
        for (let i = 0; i < this.chunks.length; i++) {
            const chunk = this.chunks[i];
            const op = chunk.op;
            writer.writeUInt8(op);
            if (op === OP_js_1.default.OP_RETURN && chunk.data != null) { // special case for unformatted data
                writer.write(chunk.data);
                break;
            }
            else if (chunk.data != null) {
                if (op < OP_js_1.default.OP_PUSHDATA1) {
                    writer.write(chunk.data);
                }
                else if (op === OP_js_1.default.OP_PUSHDATA1) {
                    writer.writeUInt8(chunk.data.length);
                    writer.write(chunk.data);
                }
                else if (op === OP_js_1.default.OP_PUSHDATA2) {
                    writer.writeUInt16LE(chunk.data.length);
                    writer.write(chunk.data);
                }
                else if (op === OP_js_1.default.OP_PUSHDATA4) {
                    writer.writeUInt32LE(chunk.data.length);
                    writer.write(chunk.data);
                }
            }
        }
        return writer.toArray();
    }
    /**
     * @method writeScript
     * Appends another script to this script.
     * @param script - The script to append.
     * @returns This script instance for chaining.
     */
    writeScript(script) {
        this.chunks = this.chunks.concat(script.chunks);
        return this;
    }
    /**
     * @method writeOpCode
     * Appends an opcode to the script.
     * @param op - The opcode to append.
     * @returns This script instance for chaining.
     */
    writeOpCode(op) {
        this.chunks.push({ op });
        return this;
    }
    /**
     * @method setChunkOpCode
     * Sets the opcode of a specific chunk in the script.
     * @param i - The index of the chunk.
     * @param op - The opcode to set.
     * @returns This script instance for chaining.
     */
    setChunkOpCode(i, op) {
        this.chunks[i] = { op };
        return this;
    }
    /**
     * @method writeBn
     * Appends a BigNumber to the script as an opcode.
     * @param bn - The BigNumber to append.
     * @returns This script instance for chaining.
     */
    writeBn(bn) {
        if (bn.cmpn(0) === OP_js_1.default.OP_0) {
            this.chunks.push({
                op: OP_js_1.default.OP_0
            });
        }
        else if (bn.cmpn(-1) === 0) {
            this.chunks.push({
                op: OP_js_1.default.OP_1NEGATE
            });
        }
        else if (bn.cmpn(1) >= 0 && bn.cmpn(16) <= 0) {
            // see OP_1 - OP_16
            this.chunks.push({
                op: bn.toNumber() + OP_js_1.default.OP_1 - 1
            });
        }
        else {
            const buf = bn.toSm('little');
            this.writeBin(buf);
        }
        return this;
    }
    /**
     * @method writeBin
     * Appends binary data to the script, determining the appropriate opcode based on length.
     * @param bin - The binary data to append.
     * @returns This script instance for chaining.
     * @throws {Error} Throws an error if the data is too large to be pushed.
     */
    writeBin(bin) {
        let op;
        const data = bin.length > 0 ? bin : undefined;
        if (bin.length > 0 && bin.length < OP_js_1.default.OP_PUSHDATA1) {
            op = bin.length;
        }
        else if (bin.length === 0) {
            op = OP_js_1.default.OP_0;
        }
        else if (bin.length < Math.pow(2, 8)) {
            op = OP_js_1.default.OP_PUSHDATA1;
        }
        else if (bin.length < Math.pow(2, 16)) {
            op = OP_js_1.default.OP_PUSHDATA2;
        }
        else if (bin.length < Math.pow(2, 32)) {
            op = OP_js_1.default.OP_PUSHDATA4;
        }
        else {
            throw new Error("You can't push that much data");
        }
        this.chunks.push({
            data,
            op
        });
        return this;
    }
    /**
     * @method writeNumber
     * Appends a number to the script.
     * @param num - The number to append.
     * @returns This script instance for chaining.
     */
    writeNumber(num) {
        this.writeBn(new BigNumber_js_1.default(num));
        return this;
    }
    /**
     * @method removeCodeseparators
     * Removes all OP_CODESEPARATOR opcodes from the script.
     * @returns This script instance for chaining.
     */
    removeCodeseparators() {
        const chunks = [];
        for (let i = 0; i < this.chunks.length; i++) {
            if (this.chunks[i].op !== OP_js_1.default.OP_CODESEPARATOR) {
                chunks.push(this.chunks[i]);
            }
        }
        this.chunks = chunks;
        return this;
    }
    /**
     * Deletes the given item wherever it appears in the current script.
     *
     * @param script - The script containing the item to delete from the current script.
     *
     * @returns This script instance for chaining.
     */
    findAndDelete(script) {
        const buf = script.toHex();
        for (let i = 0; i < this.chunks.length; i++) {
            const script2 = new Script([this.chunks[i]]);
            const buf2 = script2.toHex();
            if (buf === buf2) {
                this.chunks.splice(i, 1);
            }
        }
        return this;
    }
    /**
     * @method isPushOnly
     * Checks if the script contains only push data operations.
     * @returns True if the script is push-only, otherwise false.
     */
    isPushOnly() {
        for (let i = 0; i < this.chunks.length; i++) {
            const chunk = this.chunks[i];
            const opCodeNum = chunk.op;
            if (opCodeNum > OP_js_1.default.OP_16) {
                return false;
            }
        }
        return true;
    }
    /**
     * @method isLockingScript
     * Determines if the script is a locking script.
     * @returns True if the script is a locking script, otherwise false.
     */
    isLockingScript() {
        throw new Error('Not implemented');
    }
    /**
     * @method isUnlockingScript
     * Determines if the script is an unlocking script.
     * @returns True if the script is an unlocking script, otherwise false.
     */
    isUnlockingScript() {
        throw new Error('Not implemented');
    }
    /**
     * @private
     * @method _chunkToString
     * Converts a script chunk to its string representation.
     * @param chunk - The script chunk.
     * @returns The string representation of the chunk.
     */
    _chunkToString(chunk) {
        const op = chunk.op;
        let str = '';
        if (typeof chunk.data === 'undefined') {
            const val = OP_js_1.default[op];
            str = `${str} ${val}`;
        }
        else {
            str = `${str} ${(0, utils_js_1.toHex)(chunk.data)}`;
        }
        return str;
    }
}
exports.default = Script;

},{"../primitives/BigNumber.js":42,"../primitives/utils.js":62,"./OP.js":67}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("../primitives/utils.js");
class ScriptEvaluationError extends Error {
    constructor(params) {
        const stackHex = params.stackState.map(s => s != null && typeof s.length !== 'undefined' ? (0, utils_js_1.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');
        const altStackHex = params.altStackState.map(s => s != null && typeof s.length !== 'undefined' ? (0, utils_js_1.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');
        const pcInfo = `Context: ${params.context}, PC: ${params.programCounter}`;
        const stackInfo = `Stack: [${stackHex}] (len: ${params.stackState.length}, mem: ${params.stackMem})`;
        const altStackInfo = `AltStack: [${altStackHex}] (len: ${params.altStackState.length}, mem: ${params.altStackMem})`;
        const ifStackInfo = `IfStack: [${params.ifStackState.join(', ')}]`;
        const fullMessage = `Script evaluation error: ${params.message}\nTXID: ${params.txid}, OutputIdx: ${params.outputIndex}\n${pcInfo}\n${stackInfo}\n${altStackInfo}\n${ifStackInfo}`;
        super(fullMessage);
        this.name = this.constructor.name;
        this.txid = params.txid;
        this.outputIndex = params.outputIndex;
        this.context = params.context;
        this.programCounter = params.programCounter;
        this.stackState = params.stackState.map(s => s.slice());
        this.altStackState = params.altStackState.map(s => s.slice());
        this.ifStackState = params.ifStackState.slice();
        this.stackMem = params.stackMem;
        this.altStackMem = params.altStackMem;
    }
}
exports.default = ScriptEvaluationError;

},{"../primitives/utils.js":62}],70:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Script_js_1 = __importDefault(require("./Script.js"));
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
const OP_js_1 = __importDefault(require("./OP.js"));
const utils_js_1 = require("../primitives/utils.js");
const ScriptEvaluationError_js_1 = __importDefault(require("./ScriptEvaluationError.js"));
const Hash = __importStar(require("../primitives/Hash.js"));
const TransactionSignature_js_1 = __importDefault(require("../primitives/TransactionSignature.js"));
const PublicKey_js_1 = __importDefault(require("../primitives/PublicKey.js"));
const ECDSA_js_1 = require("../primitives/ECDSA.js");
// These constants control the current behavior of the interpreter.
const maxScriptElementSize = 1024 * 1024 * 1024;
const maxMultisigKeyCount = Math.pow(2, 31) - 1;
const requireMinimalPush = true;
const requirePushOnlyUnlockingScripts = true;
const requireLowSSignatures = true;
const requireCleanStack = true;
// --- Optimization: Pre-computed script numbers ---
const SCRIPTNUM_NEG_1 = Object.freeze(new BigNumber_js_1.default(-1).toScriptNum());
const SCRIPTNUMS_0_TO_16 = Object.freeze(Array.from({ length: 17 }, (_, i) => Object.freeze(new BigNumber_js_1.default(i).toScriptNum())));
// --- Helper functions ---
function compareNumberArrays(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
function isMinimallyEncodedHelper(buf, maxNumSize = Number.MAX_SAFE_INTEGER) {
    if (buf.length > maxNumSize) {
        return false;
    }
    if (buf.length > 0) {
        if ((buf[buf.length - 1] & 0x7f) === 0) {
            if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
                return false;
            }
        }
    }
    return true;
}
function isChecksigFormatHelper(buf) {
    // This is a simplified check. The full DER check is more complex and typically
    // done by TransactionSignature.fromChecksigFormat which can throw.
    // This helper is mostly for early bailout or non-throwing checks if needed.
    if (buf.length < 9 || buf.length > 73)
        return false;
    if (buf[0] !== 0x30)
        return false; // DER SEQUENCE
    if (buf[1] !== buf.length - 3)
        return false; // Total length (excluding type and length byte for sequence, and hash type)
    const rMarker = buf[2];
    const rLen = buf[3];
    if (rMarker !== 0x02)
        return false; // DER INTEGER
    if (rLen === 0)
        return false; // R length is zero
    if (5 + rLen >= buf.length)
        return false; // S length misplaced or R too long
    const sMarkerOffset = 4 + rLen;
    const sMarker = buf[sMarkerOffset];
    const sLen = buf[sMarkerOffset + 1];
    if (sMarker !== 0x02)
        return false; // DER INTEGER
    if (sLen === 0)
        return false; // S length is zero
    // Check R value negative or excessively padded
    if ((buf[4] & 0x80) !== 0)
        return false; // R value negative
    if (rLen > 1 && buf[4] === 0x00 && (buf[5] & 0x80) === 0)
        return false; // R value excessively padded
    // Check S value negative or excessively padded
    const sValueOffset = sMarkerOffset + 2;
    if ((buf[sValueOffset] & 0x80) !== 0)
        return false; // S value negative
    if (sLen > 1 && buf[sValueOffset] === 0x00 && (buf[sValueOffset + 1] & 0x80) === 0)
        return false; // S value excessively padded
    if (rLen + sLen + 7 !== buf.length)
        return false; // Final length check including hash type
    return true;
}
function isOpcodeDisabledHelper(op) {
    return (op === OP_js_1.default.OP_2MUL ||
        op === OP_js_1.default.OP_2DIV ||
        op === OP_js_1.default.OP_VERIF ||
        op === OP_js_1.default.OP_VERNOTIF ||
        op === OP_js_1.default.OP_VER);
}
function isChunkMinimalPushHelper(chunk) {
    const data = chunk.data;
    const op = chunk.op;
    if (!Array.isArray(data))
        return true;
    if (data.length === 0)
        return op === OP_js_1.default.OP_0;
    if (data.length === 1 && data[0] >= 1 && data[0] <= 16)
        return op === OP_js_1.default.OP_1 + (data[0] - 1);
    if (data.length === 1 && data[0] === 0x81)
        return op === OP_js_1.default.OP_1NEGATE;
    if (data.length <= 75)
        return op === data.length;
    if (data.length <= 255)
        return op === OP_js_1.default.OP_PUSHDATA1;
    if (data.length <= 65535)
        return op === OP_js_1.default.OP_PUSHDATA2;
    return true;
}
/**
 * The Spend class represents a spend action within a Bitcoin SV transaction.
 * It encapsulates all the necessary data required for spending a UTXO (Unspent Transaction Output)
 * and includes details about the source transaction, output, and the spending transaction itself.
 *
 * @property {string} sourceTXID - The transaction ID of the source UTXO.
 * @property {number} sourceOutputIndex - The index of the output in the source transaction.
 * @property {BigNumber} sourceSatoshis - The amount of satoshis in the source UTXO.
 * @property {LockingScript} lockingScript - The locking script associated with the UTXO.
 * @property {number} transactionVersion - The version of the current transaction.
 * @property {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} otherInputs -
 *           An array of other inputs in the transaction, each with a txid, outputIndex, and sequence number.
 * @property {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} outputs -
 *           An array of outputs of the current transaction, including the satoshi value and locking script for each.
 * @property {number} inputIndex - The index of this input in the current transaction.
 * @property {UnlockingScript} unlockingScript - The unlocking script that unlocks the UTXO for spending.
 * @property {number} inputSequence - The sequence number of this input.
 * @property {number} lockTime - The lock time of the transaction.
 */
class Spend {
    /**
     * @constructor
     * Constructs the Spend object with necessary transaction details.
     * @param {string} params.sourceTXID - The transaction ID of the source UTXO.
     * @param {number} params.sourceOutputIndex - The index of the output in the source transaction.
     * @param {BigNumber} params.sourceSatoshis - The amount of satoshis in the source UTXO.
     * @param {LockingScript} params.lockingScript - The locking script associated with the UTXO.
     * @param {number} params.transactionVersion - The version of the current transaction.
     * @param {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} params.otherInputs -
     *        An array of other inputs in the transaction.
     * @param {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} params.outputs -
     *        The outputs of the current transaction.
     * @param {number} params.inputIndex - The index of this input in the current transaction.
     * @param {UnlockingScript} params.unlockingScript - The unlocking script for this spend.
     * @param {number} params.inputSequence - The sequence number of this input.
     * @param {number} params.lockTime - The lock time of the transaction.
     *
     * @example
     * const spend = new Spend({
     *   sourceTXID: "abcd1234", // sourceTXID
     *   sourceOutputIndex: 0, // sourceOutputIndex
     *   sourceSatoshis: new BigNumber(1000), // sourceSatoshis
     *   lockingScript: LockingScript.fromASM("OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG"),
     *   transactionVersion: 1, // transactionVersion
     *   otherInputs: [{ sourceTXID: "abcd1234", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs
     *   outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM("OP_DUP...") }], // outputs
     *   inputIndex: 0, // inputIndex
     *   unlockingScript: UnlockingScript.fromASM("3045... 02ab..."),
     *   inputSequence: 0xffffffff // inputSequence
     *   memoryLimit: 100000 // memoryLimit
     * });
     */
    constructor(params) {
        this.sourceTXID = params.sourceTXID;
        this.sourceOutputIndex = params.sourceOutputIndex;
        this.sourceSatoshis = params.sourceSatoshis;
        this.lockingScript = params.lockingScript;
        this.transactionVersion = params.transactionVersion;
        this.otherInputs = params.otherInputs;
        this.outputs = params.outputs;
        this.inputIndex = params.inputIndex;
        this.unlockingScript = params.unlockingScript;
        this.inputSequence = params.inputSequence;
        this.lockTime = params.lockTime;
        this.memoryLimit = params.memoryLimit ?? 32000000;
        this.stack = [];
        this.altStack = [];
        this.ifStack = [];
        this.stackMem = 0;
        this.altStackMem = 0;
        this.reset();
    }
    reset() {
        this.context = 'UnlockingScript';
        this.programCounter = 0;
        this.lastCodeSeparator = null;
        this.stack = [];
        this.altStack = [];
        this.ifStack = [];
        this.stackMem = 0;
        this.altStackMem = 0;
    }
    ensureStackMem(additional) {
        if (this.stackMem + additional > this.memoryLimit) {
            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');
        }
    }
    ensureAltStackMem(additional) {
        if (this.altStackMem + additional > this.memoryLimit) {
            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');
        }
    }
    pushStack(item) {
        this.ensureStackMem(item.length);
        this.stack.push(item);
        this.stackMem += item.length;
    }
    pushStackCopy(item) {
        this.ensureStackMem(item.length);
        const copy = item.slice();
        this.stack.push(copy);
        this.stackMem += copy.length;
    }
    popStack() {
        if (this.stack.length === 0) {
            this.scriptEvaluationError('Attempted to pop from an empty stack.');
        }
        const item = this.stack.pop();
        this.stackMem -= item.length;
        return item;
    }
    stackTop(index = -1) {
        // index = -1 for top, -2 for second top, etc.
        // stack.length + index provides 0-based index from start
        if (this.stack.length === 0 || this.stack.length < Math.abs(index) || (index >= 0 && index >= this.stack.length)) {
            this.scriptEvaluationError(`Stack underflow accessing element at index ${index}. Stack length is ${this.stack.length}.`);
        }
        return this.stack[this.stack.length + index];
    }
    pushAltStack(item) {
        this.ensureAltStackMem(item.length);
        this.altStack.push(item);
        this.altStackMem += item.length;
    }
    popAltStack() {
        if (this.altStack.length === 0) {
            this.scriptEvaluationError('Attempted to pop from an empty alt stack.');
        }
        const item = this.altStack.pop();
        this.altStackMem -= item.length;
        return item;
    }
    checkSignatureEncoding(buf) {
        if (buf.length === 0)
            return true;
        if (!isChecksigFormatHelper(buf)) {
            this.scriptEvaluationError('The signature format is invalid.'); // Generic message like original
            return false;
        }
        try {
            const sig = TransactionSignature_js_1.default.fromChecksigFormat(buf); // This can throw for stricter DER rules
            if (requireLowSSignatures && !sig.hasLowS()) {
                this.scriptEvaluationError('The signature must have a low S value.');
                return false;
            }
            if ((sig.scope & TransactionSignature_js_1.default.SIGHASH_FORKID) === 0) {
                this.scriptEvaluationError('The signature must use SIGHASH_FORKID.');
                return false;
            }
        }
        catch (e) {
            this.scriptEvaluationError('The signature format is invalid.');
            return false;
        }
        return true;
    }
    checkPublicKeyEncoding(buf) {
        if (buf.length === 0) {
            this.scriptEvaluationError('Public key is empty.');
            return false;
        }
        if (buf.length < 33) {
            this.scriptEvaluationError('The public key is too short, it must be at least 33 bytes.');
            return false;
        }
        if (buf[0] === 0x04) {
            if (buf.length !== 65) {
                this.scriptEvaluationError('The non-compressed public key must be 65 bytes.');
                return false;
            }
        }
        else if (buf[0] === 0x02 || buf[0] === 0x03) {
            if (buf.length !== 33) {
                this.scriptEvaluationError('The compressed public key must be 33 bytes.');
                return false;
            }
        }
        else {
            this.scriptEvaluationError('The public key is in an unknown format.');
            return false;
        }
        try {
            PublicKey_js_1.default.fromDER(buf); // This can throw for stricter DER rules
        }
        catch (e) {
            this.scriptEvaluationError('The public key is in an unknown format.');
            return false;
        }
        return true;
    }
    verifySignature(sig, pubkey, subscript) {
        const preimage = TransactionSignature_js_1.default.format({
            sourceTXID: this.sourceTXID,
            sourceOutputIndex: this.sourceOutputIndex,
            sourceSatoshis: this.sourceSatoshis,
            transactionVersion: this.transactionVersion,
            otherInputs: this.otherInputs,
            outputs: this.outputs,
            inputIndex: this.inputIndex,
            subscript,
            inputSequence: this.inputSequence,
            lockTime: this.lockTime,
            scope: sig.scope
        });
        const hash = new BigNumber_js_1.default(Hash.hash256(preimage));
        return (0, ECDSA_js_1.verify)(hash, sig, pubkey);
    }
    step() {
        if (this.stackMem > this.memoryLimit) {
            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');
            return false; // Error thrown
        }
        if (this.altStackMem > this.memoryLimit) {
            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');
            return false; // Error thrown
        }
        if (this.context === 'UnlockingScript' &&
            this.programCounter >= this.unlockingScript.chunks.length) {
            this.context = 'LockingScript';
            this.programCounter = 0;
        }
        const currentScript = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;
        if (this.programCounter >= currentScript.chunks.length) {
            return false;
        }
        const operation = currentScript.chunks[this.programCounter];
        const currentOpcode = operation.op;
        if (typeof currentOpcode === 'undefined') {
            this.scriptEvaluationError(`Missing opcode in ${this.context} at pc=${this.programCounter}.`); // Error thrown
        }
        if (Array.isArray(operation.data) && operation.data.length > maxScriptElementSize) {
            this.scriptEvaluationError(`Data push > ${maxScriptElementSize} bytes (pc=${this.programCounter}).`); // Error thrown
        }
        const isScriptExecuting = !this.ifStack.includes(false);
        if (isScriptExecuting && isOpcodeDisabledHelper(currentOpcode)) {
            this.scriptEvaluationError(`This opcode is currently disabled. (Opcode: ${OP_js_1.default[currentOpcode]}, PC: ${this.programCounter})`); // Error thrown
        }
        if (isScriptExecuting && currentOpcode >= 0 && currentOpcode <= OP_js_1.default.OP_PUSHDATA4) {
            if (requireMinimalPush && !isChunkMinimalPushHelper(operation)) {
                this.scriptEvaluationError(`This data is not minimally-encoded. (PC: ${this.programCounter})`); // Error thrown
            }
            this.pushStack(Array.isArray(operation.data) ? operation.data : []);
        }
        else if (isScriptExecuting || (currentOpcode >= OP_js_1.default.OP_IF && currentOpcode <= OP_js_1.default.OP_ENDIF)) {
            let buf, buf1, buf2, buf3;
            let x1, x2, x3;
            let bn, bn1, bn2, bn3;
            let n, size, fValue, fSuccess, subscript;
            let bufSig, bufPubkey;
            let sig, pubkey;
            let i, ikey, isig, nKeysCount, nSigsCount, fOk;
            switch (currentOpcode) {
                case OP_js_1.default.OP_1NEGATE:
                    this.pushStackCopy(SCRIPTNUM_NEG_1);
                    break;
                case OP_js_1.default.OP_0:
                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[0]);
                    break;
                case OP_js_1.default.OP_1:
                case OP_js_1.default.OP_2:
                case OP_js_1.default.OP_3:
                case OP_js_1.default.OP_4:
                case OP_js_1.default.OP_5:
                case OP_js_1.default.OP_6:
                case OP_js_1.default.OP_7:
                case OP_js_1.default.OP_8:
                case OP_js_1.default.OP_9:
                case OP_js_1.default.OP_10:
                case OP_js_1.default.OP_11:
                case OP_js_1.default.OP_12:
                case OP_js_1.default.OP_13:
                case OP_js_1.default.OP_14:
                case OP_js_1.default.OP_15:
                case OP_js_1.default.OP_16:
                    n = currentOpcode - (OP_js_1.default.OP_1 - 1);
                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[n]);
                    break;
                case OP_js_1.default.OP_NOP:
                case OP_js_1.default.OP_NOP2: // Formerly CHECKLOCKTIMEVERIFY
                case OP_js_1.default.OP_NOP3: // Formerly CHECKSEQUENCEVERIFY
                case OP_js_1.default.OP_NOP1:
                case OP_js_1.default.OP_NOP4:
                case OP_js_1.default.OP_NOP5:
                case OP_js_1.default.OP_NOP6:
                case OP_js_1.default.OP_NOP7:
                case OP_js_1.default.OP_NOP8:
                case OP_js_1.default.OP_NOP9:
                case OP_js_1.default.OP_NOP10:
                /* falls through */
                // eslint-disable-next-line no-fallthrough
                // eslint-disable-next-line no-fallthrough
                case OP_js_1.default.OP_NOP11:
                case OP_js_1.default.OP_NOP12:
                case OP_js_1.default.OP_NOP13:
                case OP_js_1.default.OP_NOP14:
                case OP_js_1.default.OP_NOP15:
                case OP_js_1.default.OP_NOP16:
                case OP_js_1.default.OP_NOP17:
                case OP_js_1.default.OP_NOP18:
                case OP_js_1.default.OP_NOP19:
                case OP_js_1.default.OP_NOP20:
                case OP_js_1.default.OP_NOP21:
                case OP_js_1.default.OP_NOP22:
                case OP_js_1.default.OP_NOP23:
                case OP_js_1.default.OP_NOP24:
                case OP_js_1.default.OP_NOP25:
                case OP_js_1.default.OP_NOP26:
                case OP_js_1.default.OP_NOP27:
                case OP_js_1.default.OP_NOP28:
                case OP_js_1.default.OP_NOP29:
                case OP_js_1.default.OP_NOP30:
                case OP_js_1.default.OP_NOP31:
                case OP_js_1.default.OP_NOP32:
                case OP_js_1.default.OP_NOP33:
                case OP_js_1.default.OP_NOP34:
                case OP_js_1.default.OP_NOP35:
                case OP_js_1.default.OP_NOP36:
                case OP_js_1.default.OP_NOP37:
                case OP_js_1.default.OP_NOP38:
                case OP_js_1.default.OP_NOP39:
                case OP_js_1.default.OP_NOP40:
                case OP_js_1.default.OP_NOP41:
                case OP_js_1.default.OP_NOP42:
                case OP_js_1.default.OP_NOP43:
                case OP_js_1.default.OP_NOP44:
                case OP_js_1.default.OP_NOP45:
                case OP_js_1.default.OP_NOP46:
                case OP_js_1.default.OP_NOP47:
                case OP_js_1.default.OP_NOP48:
                case OP_js_1.default.OP_NOP49:
                case OP_js_1.default.OP_NOP50:
                case OP_js_1.default.OP_NOP51:
                case OP_js_1.default.OP_NOP52:
                case OP_js_1.default.OP_NOP53:
                case OP_js_1.default.OP_NOP54:
                case OP_js_1.default.OP_NOP55:
                case OP_js_1.default.OP_NOP56:
                case OP_js_1.default.OP_NOP57:
                case OP_js_1.default.OP_NOP58:
                case OP_js_1.default.OP_NOP59:
                case OP_js_1.default.OP_NOP60:
                case OP_js_1.default.OP_NOP61:
                case OP_js_1.default.OP_NOP62:
                case OP_js_1.default.OP_NOP63:
                case OP_js_1.default.OP_NOP64:
                case OP_js_1.default.OP_NOP65:
                case OP_js_1.default.OP_NOP66:
                case OP_js_1.default.OP_NOP67:
                case OP_js_1.default.OP_NOP68:
                case OP_js_1.default.OP_NOP69:
                case OP_js_1.default.OP_NOP70:
                case OP_js_1.default.OP_NOP71:
                case OP_js_1.default.OP_NOP72:
                case OP_js_1.default.OP_NOP73:
                case OP_js_1.default.OP_NOP77:
                    break;
                case OP_js_1.default.OP_IF:
                case OP_js_1.default.OP_NOTIF:
                    fValue = false;
                    if (isScriptExecuting) {
                        if (this.stack.length < 1)
                            this.scriptEvaluationError('OP_IF and OP_NOTIF require at least one item on the stack when they are used!');
                        buf = this.popStack();
                        fValue = this.castToBool(buf);
                        if (currentOpcode === OP_js_1.default.OP_NOTIF)
                            fValue = !fValue;
                    }
                    this.ifStack.push(fValue);
                    break;
                case OP_js_1.default.OP_ELSE:
                    if (this.ifStack.length === 0)
                        this.scriptEvaluationError('OP_ELSE requires a preceeding OP_IF.');
                    this.ifStack[this.ifStack.length - 1] = !this.ifStack[this.ifStack.length - 1];
                    break;
                case OP_js_1.default.OP_ENDIF:
                    if (this.ifStack.length === 0)
                        this.scriptEvaluationError('OP_ENDIF requires a preceeding OP_IF.');
                    this.ifStack.pop();
                    break;
                case OP_js_1.default.OP_VERIFY:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_VERIFY requires at least one item to be on the stack.');
                    buf1 = this.stackTop();
                    fValue = this.castToBool(buf1);
                    if (!fValue)
                        this.scriptEvaluationError('OP_VERIFY requires the top stack value to be truthy.');
                    this.popStack();
                    break;
                case OP_js_1.default.OP_RETURN:
                    if (this.context === 'UnlockingScript')
                        this.programCounter = this.unlockingScript.chunks.length;
                    else
                        this.programCounter = this.lockingScript.chunks.length;
                    this.ifStack = [];
                    this.programCounter--; // To counteract the final increment and ensure loop termination
                    break;
                case OP_js_1.default.OP_TOALTSTACK:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_TOALTSTACK requires at oeast one item to be on the stack.');
                    this.pushAltStack(this.popStack());
                    break;
                case OP_js_1.default.OP_FROMALTSTACK:
                    if (this.altStack.length < 1)
                        this.scriptEvaluationError('OP_FROMALTSTACK requires at least one item to be on the stack.'); // "stack" here means altstack
                    this.pushStack(this.popAltStack());
                    break;
                case OP_js_1.default.OP_2DROP:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_2DROP requires at least two items to be on the stack.');
                    this.popStack();
                    this.popStack();
                    break;
                case OP_js_1.default.OP_2DUP:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_2DUP requires at least two items to be on the stack.');
                    buf1 = this.stackTop(-2);
                    buf2 = this.stackTop(-1);
                    this.pushStackCopy(buf1);
                    this.pushStackCopy(buf2);
                    break;
                case OP_js_1.default.OP_3DUP:
                    if (this.stack.length < 3)
                        this.scriptEvaluationError('OP_3DUP requires at least three items to be on the stack.');
                    buf1 = this.stackTop(-3);
                    buf2 = this.stackTop(-2);
                    buf3 = this.stackTop(-1);
                    this.pushStackCopy(buf1);
                    this.pushStackCopy(buf2);
                    this.pushStackCopy(buf3);
                    break;
                case OP_js_1.default.OP_2OVER:
                    if (this.stack.length < 4)
                        this.scriptEvaluationError('OP_2OVER requires at least four items to be on the stack.');
                    buf1 = this.stackTop(-4);
                    buf2 = this.stackTop(-3);
                    this.pushStackCopy(buf1);
                    this.pushStackCopy(buf2);
                    break;
                case OP_js_1.default.OP_2ROT: {
                    if (this.stack.length < 6)
                        this.scriptEvaluationError('OP_2ROT requires at least six items to be on the stack.');
                    const rot6 = this.popStack();
                    const rot5 = this.popStack();
                    const rot4 = this.popStack();
                    const rot3 = this.popStack();
                    const rot2 = this.popStack();
                    const rot1 = this.popStack();
                    this.pushStack(rot3);
                    this.pushStack(rot4);
                    this.pushStack(rot5);
                    this.pushStack(rot6);
                    this.pushStack(rot1);
                    this.pushStack(rot2);
                    break;
                }
                case OP_js_1.default.OP_2SWAP: {
                    if (this.stack.length < 4)
                        this.scriptEvaluationError('OP_2SWAP requires at least four items to be on the stack.');
                    const swap4 = this.popStack();
                    const swap3 = this.popStack();
                    const swap2 = this.popStack();
                    const swap1 = this.popStack();
                    this.pushStack(swap3);
                    this.pushStack(swap4);
                    this.pushStack(swap1);
                    this.pushStack(swap2);
                    break;
                }
                case OP_js_1.default.OP_IFDUP:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_IFDUP requires at least one item to be on the stack.');
                    buf1 = this.stackTop();
                    if (this.castToBool(buf1)) {
                        this.pushStackCopy(buf1);
                    }
                    break;
                case OP_js_1.default.OP_DEPTH:
                    this.pushStack(new BigNumber_js_1.default(this.stack.length).toScriptNum());
                    break;
                case OP_js_1.default.OP_DROP:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_DROP requires at least one item to be on the stack.');
                    this.popStack();
                    break;
                case OP_js_1.default.OP_DUP:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_DUP requires at least one item to be on the stack.');
                    this.pushStackCopy(this.stackTop());
                    break;
                case OP_js_1.default.OP_NIP:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_NIP requires at least two items to be on the stack.');
                    buf2 = this.popStack();
                    this.popStack();
                    this.pushStack(buf2);
                    break;
                case OP_js_1.default.OP_OVER:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_OVER requires at least two items to be on the stack.');
                    this.pushStackCopy(this.stackTop(-2));
                    break;
                case OP_js_1.default.OP_PICK:
                case OP_js_1.default.OP_ROLL: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);
                    bn = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush);
                    n = bn.toNumber();
                    if (n < 0 || n >= this.stack.length) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top stack element to be 0 or a positive number less than the current size of the stack.`);
                    }
                    const itemToMoveOrCopy = this.stack[this.stack.length - 1 - n];
                    if (currentOpcode === OP_js_1.default.OP_ROLL) {
                        this.stack.splice(this.stack.length - 1 - n, 1);
                        this.stackMem -= itemToMoveOrCopy.length;
                        this.pushStack(itemToMoveOrCopy);
                    }
                    else { // OP_PICK
                        this.pushStackCopy(itemToMoveOrCopy);
                    }
                    break;
                }
                case OP_js_1.default.OP_ROT:
                    if (this.stack.length < 3)
                        this.scriptEvaluationError('OP_ROT requires at least three items to be on the stack.');
                    x3 = this.popStack();
                    x2 = this.popStack();
                    x1 = this.popStack();
                    this.pushStack(x2);
                    this.pushStack(x3);
                    this.pushStack(x1);
                    break;
                case OP_js_1.default.OP_SWAP:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_SWAP requires at least two items to be on the stack.');
                    x2 = this.popStack();
                    x1 = this.popStack();
                    this.pushStack(x2);
                    this.pushStack(x1);
                    break;
                case OP_js_1.default.OP_TUCK:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_TUCK requires at least two items to be on the stack.');
                    buf1 = this.stackTop(-1); // Top element (x2)
                    // stack is [... rest, x1, x2]
                    // We want [... rest, x2_copy, x1, x2]
                    this.ensureStackMem(buf1.length);
                    this.stack.splice(this.stack.length - 2, 0, buf1.slice()); // Insert copy of x2 before x1
                    this.stackMem += buf1.length; // Account for the new copy
                    break;
                case OP_js_1.default.OP_SIZE:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_SIZE requires at least one item to be on the stack.');
                    this.pushStack(new BigNumber_js_1.default(this.stackTop().length).toScriptNum());
                    break;
                case OP_js_1.default.OP_AND:
                case OP_js_1.default.OP_OR:
                case OP_js_1.default.OP_XOR: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items on the stack.`);
                    buf2 = this.popStack();
                    buf1 = this.popStack();
                    if (buf1.length !== buf2.length)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top two stack items to be the same size.`);
                    const resultBufBitwiseOp = new Array(buf1.length);
                    for (let k = 0; k < buf1.length; k++) {
                        if (currentOpcode === OP_js_1.default.OP_AND)
                            resultBufBitwiseOp[k] = buf1[k] & buf2[k];
                        else if (currentOpcode === OP_js_1.default.OP_OR)
                            resultBufBitwiseOp[k] = buf1[k] | buf2[k];
                        else
                            resultBufBitwiseOp[k] = buf1[k] ^ buf2[k];
                    }
                    this.pushStack(resultBufBitwiseOp);
                    break;
                }
                case OP_js_1.default.OP_INVERT: {
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_INVERT requires at least one item to be on the stack.');
                    buf = this.popStack();
                    const invertedBufOp = new Array(buf.length);
                    for (let k = 0; k < buf.length; k++) {
                        invertedBufOp[k] = (~buf[k]) & 0xff;
                    }
                    this.pushStack(invertedBufOp);
                    break;
                }
                case OP_js_1.default.OP_LSHIFT:
                case OP_js_1.default.OP_RSHIFT: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);
                    bn2 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // n (shift amount)
                    buf1 = this.popStack(); // value to shift
                    n = bn2.toNumber();
                    if (n < 0)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top item on the stack not to be negative.`);
                    if (buf1.length === 0) {
                        this.pushStack([]);
                        break;
                    }
                    bn1 = new BigNumber_js_1.default(buf1);
                    let shiftedBn;
                    if (currentOpcode === OP_js_1.default.OP_LSHIFT)
                        shiftedBn = bn1.ushln(n);
                    else
                        shiftedBn = bn1.ushrn(n);
                    const shiftedArr = shiftedBn.toArray('le', buf1.length);
                    this.pushStack(shiftedArr);
                    break;
                }
                case OP_js_1.default.OP_EQUAL:
                case OP_js_1.default.OP_EQUALVERIFY:
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);
                    buf2 = this.popStack();
                    buf1 = this.popStack();
                    fValue = compareNumberArrays(buf1, buf2);
                    this.pushStack(fValue ? [1] : []);
                    if (currentOpcode === OP_js_1.default.OP_EQUALVERIFY) {
                        if (!fValue)
                            this.scriptEvaluationError('OP_EQUALVERIFY requires the top two stack items to be equal.');
                        this.popStack();
                    }
                    break;
                case OP_js_1.default.OP_1ADD:
                case OP_js_1.default.OP_1SUB:
                case OP_js_1.default.OP_NEGATE:
                case OP_js_1.default.OP_ABS:
                case OP_js_1.default.OP_NOT:
                case OP_js_1.default.OP_0NOTEQUAL:
                    if (this.stack.length < 1)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least one item to be on the stack.`);
                    bn = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush);
                    switch (currentOpcode) {
                        case OP_js_1.default.OP_1ADD:
                            bn = bn.add(new BigNumber_js_1.default(1));
                            break;
                        case OP_js_1.default.OP_1SUB:
                            bn = bn.sub(new BigNumber_js_1.default(1));
                            break;
                        case OP_js_1.default.OP_NEGATE:
                            bn = bn.neg();
                            break;
                        case OP_js_1.default.OP_ABS:
                            if (bn.isNeg())
                                bn = bn.neg();
                            break;
                        case OP_js_1.default.OP_NOT:
                            bn = new BigNumber_js_1.default(bn.cmpn(0) === 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_0NOTEQUAL:
                            bn = new BigNumber_js_1.default(bn.cmpn(0) !== 0 ? 1 : 0);
                            break;
                    }
                    this.pushStack(bn.toScriptNum());
                    break;
                case OP_js_1.default.OP_ADD:
                case OP_js_1.default.OP_SUB:
                case OP_js_1.default.OP_MUL:
                case OP_js_1.default.OP_DIV:
                case OP_js_1.default.OP_MOD:
                case OP_js_1.default.OP_BOOLAND:
                case OP_js_1.default.OP_BOOLOR:
                case OP_js_1.default.OP_NUMEQUAL:
                case OP_js_1.default.OP_NUMEQUALVERIFY:
                case OP_js_1.default.OP_NUMNOTEQUAL:
                case OP_js_1.default.OP_LESSTHAN:
                case OP_js_1.default.OP_GREATERTHAN:
                case OP_js_1.default.OP_LESSTHANOREQUAL:
                case OP_js_1.default.OP_GREATERTHANOREQUAL:
                case OP_js_1.default.OP_MIN:
                case OP_js_1.default.OP_MAX: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);
                    buf2 = this.popStack();
                    buf1 = this.popStack();
                    bn2 = BigNumber_js_1.default.fromScriptNum(buf2, requireMinimalPush);
                    bn1 = BigNumber_js_1.default.fromScriptNum(buf1, requireMinimalPush);
                    let predictedLen = 0;
                    switch (currentOpcode) {
                        case OP_js_1.default.OP_MUL:
                            predictedLen = bn1.byteLength() + bn2.byteLength();
                            break;
                        case OP_js_1.default.OP_ADD:
                        case OP_js_1.default.OP_SUB:
                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength()) + 1;
                            break;
                        default:
                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength());
                    }
                    this.ensureStackMem(predictedLen);
                    let resultBnArithmetic = new BigNumber_js_1.default(0);
                    switch (currentOpcode) {
                        case OP_js_1.default.OP_ADD:
                            resultBnArithmetic = bn1.add(bn2);
                            break;
                        case OP_js_1.default.OP_SUB:
                            resultBnArithmetic = bn1.sub(bn2);
                            break;
                        case OP_js_1.default.OP_MUL:
                            resultBnArithmetic = bn1.mul(bn2);
                            break;
                        case OP_js_1.default.OP_DIV:
                            if (bn2.cmpn(0) === 0)
                                this.scriptEvaluationError('OP_DIV cannot divide by zero!');
                            resultBnArithmetic = bn1.div(bn2);
                            break;
                        case OP_js_1.default.OP_MOD:
                            if (bn2.cmpn(0) === 0)
                                this.scriptEvaluationError('OP_MOD cannot divide by zero!');
                            resultBnArithmetic = bn1.mod(bn2);
                            break;
                        case OP_js_1.default.OP_BOOLAND:
                            resultBnArithmetic = new BigNumber_js_1.default((bn1.cmpn(0) !== 0 && bn2.cmpn(0) !== 0) ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_BOOLOR:
                            resultBnArithmetic = new BigNumber_js_1.default((bn1.cmpn(0) !== 0 || bn2.cmpn(0) !== 0) ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_NUMEQUAL:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) === 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_NUMEQUALVERIFY:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) === 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_NUMNOTEQUAL:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) !== 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_LESSTHAN:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) < 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_GREATERTHAN:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) > 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_LESSTHANOREQUAL:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) <= 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_GREATERTHANOREQUAL:
                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) >= 0 ? 1 : 0);
                            break;
                        case OP_js_1.default.OP_MIN:
                            resultBnArithmetic = bn1.cmp(bn2) < 0 ? bn1 : bn2;
                            break;
                        case OP_js_1.default.OP_MAX:
                            resultBnArithmetic = bn1.cmp(bn2) > 0 ? bn1 : bn2;
                            break;
                    }
                    this.pushStack(resultBnArithmetic.toScriptNum());
                    if (currentOpcode === OP_js_1.default.OP_NUMEQUALVERIFY) {
                        if (!this.castToBool(this.stackTop()))
                            this.scriptEvaluationError('OP_NUMEQUALVERIFY requires the top stack item to be truthy.');
                        this.popStack();
                    }
                    break;
                }
                case OP_js_1.default.OP_WITHIN:
                    if (this.stack.length < 3)
                        this.scriptEvaluationError('OP_WITHIN requires at least three items to be on the stack.');
                    bn3 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // max
                    bn2 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // min
                    bn1 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // x
                    fValue = bn1.cmp(bn2) >= 0 && bn1.cmp(bn3) < 0;
                    this.pushStack(fValue ? [1] : []);
                    break;
                case OP_js_1.default.OP_RIPEMD160:
                case OP_js_1.default.OP_SHA1:
                case OP_js_1.default.OP_SHA256:
                case OP_js_1.default.OP_HASH160:
                case OP_js_1.default.OP_HASH256: {
                    if (this.stack.length < 1)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least one item to be on the stack.`);
                    buf = this.popStack();
                    let hashResult = []; // Initialize to empty, to satisfy TS compiler
                    if (currentOpcode === OP_js_1.default.OP_RIPEMD160)
                        hashResult = Hash.ripemd160(buf);
                    else if (currentOpcode === OP_js_1.default.OP_SHA1)
                        hashResult = Hash.sha1(buf);
                    else if (currentOpcode === OP_js_1.default.OP_SHA256)
                        hashResult = Hash.sha256(buf);
                    else if (currentOpcode === OP_js_1.default.OP_HASH160)
                        hashResult = Hash.hash160(buf);
                    else if (currentOpcode === OP_js_1.default.OP_HASH256)
                        hashResult = Hash.hash256(buf);
                    this.pushStack(hashResult);
                    break;
                }
                case OP_js_1.default.OP_CODESEPARATOR:
                    this.lastCodeSeparator = this.programCounter;
                    break;
                case OP_js_1.default.OP_CHECKSIG:
                case OP_js_1.default.OP_CHECKSIGVERIFY: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);
                    bufPubkey = this.popStack();
                    bufSig = this.popStack();
                    if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {
                        // Error already thrown by helpers
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires correct encoding for the public key and signature.`); // Fallback, should be unreachable
                    }
                    const scriptForChecksig = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;
                    const scriptCodeChunks = scriptForChecksig.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);
                    subscript = new Script_js_1.default(scriptCodeChunks);
                    subscript.findAndDelete(new Script_js_1.default().writeBin(bufSig));
                    fSuccess = false;
                    if (bufSig.length > 0) {
                        try {
                            sig = TransactionSignature_js_1.default.fromChecksigFormat(bufSig);
                            pubkey = PublicKey_js_1.default.fromDER(bufPubkey);
                            fSuccess = this.verifySignature(sig, pubkey, subscript);
                        }
                        catch (e) {
                            fSuccess = false;
                        }
                    }
                    this.pushStack(fSuccess ? [1] : []);
                    if (currentOpcode === OP_js_1.default.OP_CHECKSIGVERIFY) {
                        if (!fSuccess)
                            this.scriptEvaluationError('OP_CHECKSIGVERIFY requires that a valid signature is provided.');
                        this.popStack();
                    }
                    break;
                }
                case OP_js_1.default.OP_CHECKMULTISIG:
                case OP_js_1.default.OP_CHECKMULTISIGVERIFY: {
                    i = 1;
                    if (this.stack.length < i) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least 1 item for nKeys.`);
                    }
                    nKeysCount = BigNumber_js_1.default.fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();
                    if (nKeysCount < 0 || nKeysCount > maxMultisigKeyCount) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires a key count between 0 and ${maxMultisigKeyCount}.`);
                    }
                    ikey = ++i;
                    i += nKeysCount;
                    if (this.stack.length < i) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} stack too small for nKeys and keys. Need ${i}, have ${this.stack.length}.`);
                    }
                    nSigsCount = BigNumber_js_1.default.fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();
                    if (nSigsCount < 0 || nSigsCount > nKeysCount) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the number of signatures to be no greater than the number of keys.`);
                    }
                    isig = ++i;
                    i += nSigsCount;
                    if (this.stack.length < i) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} stack too small for N, keys, M, sigs, and dummy. Need ${i}, have ${this.stack.length}.`);
                    }
                    const baseScriptCMS = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;
                    const subscriptChunksCMS = baseScriptCMS.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);
                    subscript = new Script_js_1.default(subscriptChunksCMS);
                    for (let k = 0; k < nSigsCount; k++) {
                        bufSig = this.stackTop(-isig - k); // Sigs are closer to top than keys
                        subscript.findAndDelete(new Script_js_1.default().writeBin(bufSig));
                    }
                    fSuccess = true;
                    while (fSuccess && nSigsCount > 0) {
                        if (nKeysCount === 0) { // No more keys to check against but still sigs left
                            fSuccess = false;
                            break;
                        }
                        bufSig = this.stackTop(-isig);
                        bufPubkey = this.stackTop(-ikey);
                        if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {
                            this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires correct encoding for the public key and signature.`);
                        }
                        fOk = false;
                        if (bufSig.length > 0) {
                            try {
                                sig = TransactionSignature_js_1.default.fromChecksigFormat(bufSig);
                                pubkey = PublicKey_js_1.default.fromDER(bufPubkey);
                                fOk = this.verifySignature(sig, pubkey, subscript);
                            }
                            catch (e) {
                                fOk = false;
                            }
                        }
                        if (fOk) {
                            isig++;
                            nSigsCount--;
                        }
                        ikey++;
                        nKeysCount--;
                        if (nSigsCount > nKeysCount) {
                            fSuccess = false;
                        }
                    }
                    // Correct total items consumed by op (N_val, keys, M_val, sigs, dummy)
                    const itemsConsumedByOp = 1 + // N_val
                        BigNumber_js_1.default.fromScriptNum(this.stackTop(-1), false).toNumber() + // keys
                        1 + // M_val
                        BigNumber_js_1.default.fromScriptNum(this.stackTop(-(1 + BigNumber_js_1.default.fromScriptNum(this.stackTop(-1), false).toNumber() + 1)), false).toNumber() + // sigs
                        1; // dummy
                    let popCount = itemsConsumedByOp - 1; // Pop all except dummy
                    while (popCount > 0) {
                        this.popStack();
                        popCount--;
                    }
                    // Check and pop dummy
                    if (this.stack.length < 1) {
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires an extra item (dummy) to be on the stack.`);
                    }
                    const dummyBuf = this.popStack();
                    if (dummyBuf.length > 0) { // SCRIPT_VERIFY_NULLDUMMY
                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the extra stack item (dummy) to be empty.`);
                    }
                    this.pushStack(fSuccess ? [1] : []);
                    if (currentOpcode === OP_js_1.default.OP_CHECKMULTISIGVERIFY) {
                        if (!fSuccess)
                            this.scriptEvaluationError('OP_CHECKMULTISIGVERIFY requires that a sufficient number of valid signatures are provided.');
                        this.popStack();
                    }
                    break;
                }
                case OP_js_1.default.OP_CAT: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_CAT requires at least two items to be on the stack.');
                    buf2 = this.popStack();
                    buf1 = this.popStack();
                    const catResult = (buf1).concat(buf2);
                    if (catResult.length > maxScriptElementSize)
                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);
                    this.pushStack(catResult);
                    break;
                }
                case OP_js_1.default.OP_SPLIT: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_SPLIT requires at least two items to be on the stack.');
                    const posBuf = this.popStack();
                    const dataToSplit = this.popStack();
                    n = BigNumber_js_1.default.fromScriptNum(posBuf, requireMinimalPush).toNumber();
                    if (n < 0 || n > dataToSplit.length) {
                        this.scriptEvaluationError('OP_SPLIT requires the first stack item to be a non-negative number less than or equal to the size of the second-from-top stack item.');
                    }
                    this.pushStack(dataToSplit.slice(0, n));
                    this.pushStack(dataToSplit.slice(n));
                    break;
                }
                case OP_js_1.default.OP_NUM2BIN: {
                    if (this.stack.length < 2)
                        this.scriptEvaluationError('OP_NUM2BIN requires at least two items to be on the stack.');
                    size = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush).toNumber();
                    if (size > maxScriptElementSize || size < 0) { // size can be 0
                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes or negative size.`);
                    }
                    let rawnum = this.popStack(); // This is the number to convert
                    rawnum = (0, utils_js_1.minimallyEncode)(rawnum); // Get its minimal scriptnum form
                    if (rawnum.length > size) {
                        this.scriptEvaluationError('OP_NUM2BIN requires that the size expressed in the top stack item is large enough to hold the value expressed in the second-from-top stack item.');
                    }
                    if (rawnum.length === size) {
                        this.pushStack(rawnum);
                        break;
                    }
                    const resultN2B = new Array(size).fill(0x00);
                    let signbit = 0x00;
                    if (rawnum.length > 0) {
                        signbit = rawnum[rawnum.length - 1] & 0x80; // Store sign bit
                        rawnum[rawnum.length - 1] &= 0x7f; // Remove sign bit for padding
                    }
                    // Copy rawnum (now positive magnitude) into the result
                    for (let k = 0; k < rawnum.length; k++) {
                        resultN2B[k] = rawnum[k];
                    }
                    // If the original number was negative, the sign bit must be set on the new MSB
                    if (signbit !== 0) {
                        resultN2B[size - 1] |= 0x80;
                    }
                    this.pushStack(resultN2B);
                    break;
                }
                case OP_js_1.default.OP_BIN2NUM: {
                    if (this.stack.length < 1)
                        this.scriptEvaluationError('OP_BIN2NUM requires at least one item to be on the stack.');
                    buf1 = this.popStack();
                    const b2nResult = (0, utils_js_1.minimallyEncode)(buf1);
                    if (!isMinimallyEncodedHelper(b2nResult)) {
                        this.scriptEvaluationError('OP_BIN2NUM requires that the resulting number is valid.');
                    }
                    this.pushStack(b2nResult);
                    break;
                }
                default:
                    this.scriptEvaluationError(`Invalid opcode ${currentOpcode} (pc=${this.programCounter}).`);
            }
        }
        this.programCounter++;
        return true;
    }
    /**
     * @method validate
     * Validates the spend action by interpreting the locking and unlocking scripts.
     * @returns {boolean} Returns true if the scripts are valid and the spend is legitimate, otherwise false.
     * @example
     * if (spend.validate()) {
     *   console.log("Spend is valid!");
     * } else {
     *   console.log("Invalid spend!");
     * }
     */
    validate() {
        if (requirePushOnlyUnlockingScripts && !this.unlockingScript.isPushOnly()) {
            this.scriptEvaluationError('Unlocking scripts can only contain push operations, and no other opcodes.');
        }
        while (this.step()) {
            if (this.context === 'LockingScript' &&
                this.programCounter >= this.lockingScript.chunks.length) {
                break;
            }
        }
        if (this.ifStack.length > 0) {
            this.scriptEvaluationError('Every OP_IF, OP_NOTIF, or OP_ELSE must be terminated with OP_ENDIF prior to the end of the script.');
        }
        if (requireCleanStack) {
            if (this.stack.length !== 1) {
                this.scriptEvaluationError(`The clean stack rule requires exactly one item to be on the stack after script execution, found ${this.stack.length}.`);
            }
        }
        if (this.stack.length === 0) {
            this.scriptEvaluationError('The top stack element must be truthy after script evaluation (stack is empty).');
        }
        else if (!this.castToBool(this.stackTop())) {
            this.scriptEvaluationError('The top stack element must be truthy after script evaluation.');
        }
        return true;
    }
    castToBool(val) {
        if (val.length === 0)
            return false;
        for (let i = 0; i < val.length; i++) {
            if (val[i] !== 0) {
                return !(i === val.length - 1 && val[i] === 0x80);
            }
        }
        return false;
    }
    scriptEvaluationError(str) {
        throw new ScriptEvaluationError_js_1.default({
            message: str,
            txid: this.sourceTXID,
            outputIndex: this.sourceOutputIndex,
            context: this.context,
            programCounter: this.programCounter,
            stackState: this.stack,
            altStackState: this.altStack,
            ifStackState: this.ifStack,
            stackMem: this.stackMem,
            altStackMem: this.altStackMem
        });
    }
}
exports.default = Spend;

},{"../primitives/BigNumber.js":42,"../primitives/ECDSA.js":45,"../primitives/Hash.js":46,"../primitives/PublicKey.js":54,"../primitives/TransactionSignature.js":60,"../primitives/utils.js":62,"./OP.js":67,"./Script.js":68,"./ScriptEvaluationError.js":69}],71:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Script_js_1 = __importDefault(require("./Script.js"));
/**
 * The UnlockingScript class represents an unlocking script in a Bitcoin SV transaction.
 * It extends the Script class and is used specifically for input scripts that unlock funds.
 *
 * Inherits all properties and methods from the Script class.
 *
 * @extends {Script}
 * @see {@link Script} for more information on Script.
 */
class UnlockingScript extends Script_js_1.default {
    /**
     * @method isLockingScript
     * Determines if the script is a locking script.
     * @returns {boolean} Always returns false for an UnlockingScript instance.
     */
    isLockingScript() {
        return false;
    }
    /**
     * @method isUnlockingScript
     * Determines if the script is an unlocking script.
     * @returns {boolean} Always returns true for an UnlockingScript instance.
     */
    isUnlockingScript() {
        return true;
    }
}
exports.default = UnlockingScript;

},{"./Script.js":68}],72:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptEvaluationError = exports.Spend = exports.UnlockingScript = exports.LockingScript = exports.Script = exports.OP = void 0;
var OP_js_1 = require("./OP.js");
Object.defineProperty(exports, "OP", { enumerable: true, get: function () { return __importDefault(OP_js_1).default; } });
var Script_js_1 = require("./Script.js");
Object.defineProperty(exports, "Script", { enumerable: true, get: function () { return __importDefault(Script_js_1).default; } });
var LockingScript_js_1 = require("./LockingScript.js");
Object.defineProperty(exports, "LockingScript", { enumerable: true, get: function () { return __importDefault(LockingScript_js_1).default; } });
var UnlockingScript_js_1 = require("./UnlockingScript.js");
Object.defineProperty(exports, "UnlockingScript", { enumerable: true, get: function () { return __importDefault(UnlockingScript_js_1).default; } });
var Spend_js_1 = require("./Spend.js");
Object.defineProperty(exports, "Spend", { enumerable: true, get: function () { return __importDefault(Spend_js_1).default; } });
var ScriptEvaluationError_js_1 = require("./ScriptEvaluationError.js");
Object.defineProperty(exports, "ScriptEvaluationError", { enumerable: true, get: function () { return __importDefault(ScriptEvaluationError_js_1).default; } });
__exportStar(require("./templates/index.js"), exports);

},{"./LockingScript.js":66,"./OP.js":67,"./Script.js":68,"./ScriptEvaluationError.js":69,"./Spend.js":70,"./UnlockingScript.js":71,"./templates/index.js":76}],73:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const OP_js_1 = __importDefault(require("../OP.js"));
const utils_js_1 = require("../../primitives/utils.js");
const LockingScript_js_1 = __importDefault(require("../LockingScript.js"));
const UnlockingScript_js_1 = __importDefault(require("../UnlockingScript.js"));
const TransactionSignature_js_1 = __importDefault(require("../../primitives/TransactionSignature.js"));
const Hash_js_1 = require("../../primitives/Hash.js");
function verifyTruthy(v) {
    if (v == null)
        throw new Error('must have value');
    return v;
}
/**
 * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.
 *
 * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.
 */
class P2PKH {
    /**
     * Creates a P2PKH locking script for a given public key hash or address string
     *
     * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.
     * @returns {LockingScript} - A P2PKH locking script.
     */
    lock(pubkeyhash) {
        let data;
        if (typeof pubkeyhash === 'string') {
            const hash = (0, utils_js_1.fromBase58Check)(pubkeyhash);
            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f) {
                throw new Error('only P2PKH is supported');
            }
            data = hash.data;
        }
        else {
            data = pubkeyhash;
        }
        if (data.length !== 20) {
            throw new Error('P2PKH hash length must be 20 bytes');
        }
        return new LockingScript_js_1.default([
            { op: OP_js_1.default.OP_DUP },
            { op: OP_js_1.default.OP_HASH160 },
            { op: data.length, data },
            { op: OP_js_1.default.OP_EQUALVERIFY },
            { op: OP_js_1.default.OP_CHECKSIG }
        ]);
    }
    /**
     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.
     *
     * The returned object contains:
     * 1. `sign` - A function that, when invoked with a transaction and an input index,
     *    produces an unlocking script suitable for a P2PKH locked output.
     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
     *
     * @param {PrivateKey} privateKey - The private key used for signing the transaction.
     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.
     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.
     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
     */
    unlock(privateKey, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {
        return {
            sign: async (tx, inputIndex) => {
                let signatureScope = TransactionSignature_js_1.default.SIGHASH_FORKID;
                if (signOutputs === 'all') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ALL;
                }
                if (signOutputs === 'none') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_NONE;
                }
                if (signOutputs === 'single') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ANYONECANPAY;
                }
                const input = tx.inputs[inputIndex];
                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');
                if (sourceTXID == null || sourceTXID === undefined) {
                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');
                }
                if (sourceTXID === '') {
                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');
                }
                sourceSatoshis || (sourceSatoshis = input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis);
                if (sourceSatoshis == null || sourceSatoshis === undefined) {
                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');
                }
                lockingScript || (lockingScript = input.sourceTransaction?.outputs[input.sourceOutputIndex]
                    .lockingScript);
                if (lockingScript == null) {
                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');
                }
                const preimage = TransactionSignature_js_1.default.format({
                    sourceTXID,
                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),
                    sourceSatoshis,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: verifyTruthy(input.sequence),
                    subscript: lockingScript,
                    lockTime: tx.lockTime,
                    scope: signatureScope
                });
                const rawSignature = privateKey.sign((0, Hash_js_1.sha256)(preimage));
                const sig = new TransactionSignature_js_1.default(rawSignature.r, rawSignature.s, signatureScope);
                const sigForScript = sig.toChecksigFormat();
                const pubkeyForScript = privateKey
                    .toPublicKey()
                    .encode(true);
                return new UnlockingScript_js_1.default([
                    { op: sigForScript.length, data: sigForScript },
                    { op: pubkeyForScript.length, data: pubkeyForScript }
                ]);
            },
            estimateLength: async () => {
                // public key (1+33) + signature (1+73)
                // Note: We add 1 to each element's length because of the associated OP_PUSH
                return 108;
            }
        };
    }
}
exports.default = P2PKH;

},{"../../primitives/Hash.js":46,"../../primitives/TransactionSignature.js":60,"../../primitives/utils.js":62,"../LockingScript.js":66,"../OP.js":67,"../UnlockingScript.js":71}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("../index.js");
const index_js_2 = require("../../primitives/index.js");
function verifyTruthy(v) {
    if (v == null)
        throw new Error('must have value');
    return v;
}
/**
 * For a given piece of data to push onto the stack in script, creates the correct minimally-encoded script chunk,
 * including the correct push operation.
 *
 * TODO: This should be made into a TS-SDK util (distinct from the `minimallyEncode` util)
 */
const createMinimallyEncodedScriptChunk = (data) => {
    if (data.length === 0) {
        // Could have used OP_0.
        return { op: 0 };
    }
    if (data.length === 1 && data[0] === 0) {
        // Could have used OP_0.
        return { op: 0 };
    }
    if (data.length === 1 && data[0] > 0 && data[0] <= 16) {
        // Could have used OP_0 .. OP_16.
        return { op: 0x50 + data[0] };
    }
    if (data.length === 1 && data[0] === 0x81) {
        // Could have used OP_1NEGATE.
        return { op: 0x4f };
    }
    if (data.length <= 75) {
        // Could have used a direct push (opcode indicating number of bytes
        // pushed + those bytes).
        return { op: data.length, data };
    }
    if (data.length <= 255) {
        // Could have used OP_PUSHDATA.
        return { op: 0x4c, data };
    }
    if (data.length <= 65535) {
        // Could have used OP_PUSHDATA2.
        return { op: 0x4d, data };
    }
    return { op: 0x4e, data };
};
class PushDrop {
    /**
     * Decodes a PushDrop script back into its token fields and the locking public key. If a signature was present, it will be the last field returned.
     * Warning: Only works with a P2PK lock at the beginning of the script.
     * @param script PushDrop script to decode back into token fields
     * @returns An object containing PushDrop token fields and the locking public key. If a signature was included, it will be the last field.
     */
    static decode(script) {
        const lockingPublicKey = index_js_2.PublicKey.fromString(index_js_2.Utils.toHex(verifyTruthy(script.chunks[0].data)) // ✅ Ensure not undefined
        );
        const fields = [];
        for (let i = 2; i < script.chunks.length; i++) {
            const nextOpcode = script.chunks[i + 1]?.op; // ✅ Prevent accessing `op` from `undefined`
            let chunk = script.chunks[i].data ?? []; // ✅ Ensure `chunk` is always `number[]`
            if (chunk.length === 0) {
                // ✅ Only modify `chunk` if it was empty
                if (script.chunks[i].op >= 80 && script.chunks[i].op <= 95) {
                    chunk = [script.chunks[i].op - 80];
                }
                else if (script.chunks[i].op === 0) {
                    chunk = [0];
                }
                else if (script.chunks[i].op === 0x4f) {
                    chunk = [0x81];
                }
            }
            fields.push(chunk);
            // If the next value is DROP or 2DROP then this is the final field
            if (nextOpcode === index_js_1.OP.OP_DROP || nextOpcode === index_js_1.OP.OP_2DROP) {
                break;
            }
        }
        return {
            fields,
            lockingPublicKey
        };
    }
    /**
     * Constructs a new instance of the PushDrop class.
     *
     * @param {WalletInterface} wallet - The wallet interface used for creating signatures and accessing public keys.
     * @param {string} originator — The originator to use with Wallet requests
     */
    constructor(wallet, originator) {
        this.wallet = wallet;
        this.originator = originator;
    }
    /**
     * Creates a PushDrop locking script with arbitrary data fields and a public key lock.
     *
     * @param {number[][]} fields - The token fields to include in the locking script.
     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.
     * @param {string} keyID - The key ID to use.
     * @param {string} counterparty - The counterparty involved in the transaction, "self" or "anyone".
     * @param {boolean} [forSelf=false] - Flag indicating if the lock is for the creator (default no).
     * @param {boolean} [includeSignature=true] - Flag indicating if a signature should be included in the script (default yes).
     * @returns {Promise<LockingScript>} The generated PushDrop locking script.
     */
    async lock(fields, protocolID, keyID, counterparty, forSelf = false, includeSignature = true, lockPosition = 'before') {
        const { publicKey } = await this.wallet.getPublicKey({
            protocolID,
            keyID,
            counterparty,
            forSelf
        }, this.originator);
        const lockChunks = [];
        const pushDropChunks = [];
        lockChunks.push({
            op: publicKey.length / 2,
            data: index_js_2.Utils.toArray(publicKey, 'hex')
        });
        lockChunks.push({ op: index_js_1.OP.OP_CHECKSIG });
        if (includeSignature) {
            const dataToSign = fields.reduce((a, e) => [...a, ...e], []);
            const { signature } = await this.wallet.createSignature({
                data: dataToSign,
                protocolID,
                keyID,
                counterparty
            }, this.originator);
            fields.push(signature);
        }
        for (const field of fields) {
            pushDropChunks.push(createMinimallyEncodedScriptChunk(field));
        }
        let notYetDropped = fields.length;
        while (notYetDropped > 1) {
            pushDropChunks.push({ op: index_js_1.OP.OP_2DROP });
            notYetDropped -= 2;
        }
        if (notYetDropped !== 0) {
            pushDropChunks.push({ op: index_js_1.OP.OP_DROP });
        }
        if (lockPosition === 'before') {
            return new index_js_1.LockingScript([...lockChunks, ...pushDropChunks]);
        }
        else {
            return new index_js_1.LockingScript([...pushDropChunks, ...lockChunks]);
        }
    }
    /**
     * Creates an unlocking script for spending a PushDrop token output.
     *
     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.
     * @param {string} keyID - The key ID to use.
     * @param {string} counterparty - The counterparty involved in the transaction, "self" or "anyone".
     * @param {string} [sourceTXID] - The TXID of the source transaction.
     * @param {number} [sourceSatoshis] - The number of satoshis in the source output.
     * @param {LockingScript} [lockingScript] - The locking script of the source output.
     * @param {'all' | 'none' | 'single'} [signOutputs='all'] - Specifies which outputs to sign.
     * @param {boolean} [anyoneCanPay=false] - Specifies if the anyone-can-pay flag is set.
     * @returns {Object} An object containing functions to sign the transaction and estimate the script length.
     */
    unlock(protocolID, keyID, counterparty, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {
        return {
            sign: async (tx, inputIndex) => {
                let signatureScope = index_js_2.TransactionSignature.SIGHASH_FORKID;
                if (signOutputs === 'all') {
                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_ALL;
                }
                if (signOutputs === 'none') {
                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_NONE;
                }
                if (signOutputs === 'single') {
                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_ANYONECANPAY;
                }
                const input = tx.inputs[inputIndex];
                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);
                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');
                if (sourceTXID == null || sourceTXID === undefined) {
                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');
                }
                sourceSatoshis || (sourceSatoshis = input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis);
                if (sourceSatoshis == null || sourceSatoshis === undefined) {
                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');
                }
                lockingScript || (lockingScript = input.sourceTransaction?.outputs[input.sourceOutputIndex]
                    .lockingScript);
                if (lockingScript == null) {
                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');
                }
                const preimage = index_js_2.TransactionSignature.format({
                    sourceTXID,
                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),
                    sourceSatoshis,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: input.sequence ?? 0xffffffff,
                    subscript: lockingScript,
                    lockTime: tx.lockTime,
                    scope: signatureScope
                });
                const preimageHash = index_js_2.Hash.sha256(preimage);
                const { signature: bareSignature } = await this.wallet.createSignature({
                    data: preimageHash,
                    protocolID,
                    keyID,
                    counterparty
                }, this.originator);
                const signature = index_js_2.Signature.fromDER([...bareSignature]);
                const txSignature = new index_js_2.TransactionSignature(signature.r, signature.s, signatureScope);
                const sigForScript = txSignature.toChecksigFormat();
                return new index_js_1.UnlockingScript([
                    { op: sigForScript.length, data: sigForScript }
                ]);
            },
            estimateLength: async () => 73
        };
    }
}
exports.default = PushDrop;

},{"../../primitives/index.js":61,"../index.js":72}],75:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const OP_js_1 = __importDefault(require("../OP.js"));
const LockingScript_js_1 = __importDefault(require("../LockingScript.js"));
const UnlockingScript_js_1 = __importDefault(require("../UnlockingScript.js"));
const PrivateKey_js_1 = __importDefault(require("../../primitives/PrivateKey.js"));
const TransactionSignature_js_1 = __importDefault(require("../../primitives/TransactionSignature.js"));
const Hash_js_1 = require("../../primitives/Hash.js");
const Script_js_1 = __importDefault(require("../Script.js"));
/**
 * RPuzzle class implementing ScriptTemplate.
 *
 * This class provides methods to create R Puzzle and R Puzzle Hash locking and unlocking scripts, including the unlocking of UTXOs with the correct K value.
 */
class RPuzzle {
    /**
     * @constructor
     * Constructs an R Puzzle template instance for a given puzzle type
     *
     * @param {'raw'|'SHA1'|'SHA256'|'HASH256'|'RIPEMD160'|'HASH160'} type Denotes the type of puzzle to create
     */
    constructor(type = 'raw') {
        this.type = 'raw';
        this.type = type;
    }
    /**
     * Creates an R puzzle locking script for a given R value or R value hash.
     *
     * @param {number[]} value - An array representing the R value or its hash.
     * @returns {LockingScript} - An R puzzle locking script.
     */
    lock(value) {
        const chunks = [
            { op: OP_js_1.default.OP_OVER },
            { op: OP_js_1.default.OP_3 },
            { op: OP_js_1.default.OP_SPLIT },
            { op: OP_js_1.default.OP_NIP },
            { op: OP_js_1.default.OP_1 },
            { op: OP_js_1.default.OP_SPLIT },
            { op: OP_js_1.default.OP_SWAP },
            { op: OP_js_1.default.OP_SPLIT },
            { op: OP_js_1.default.OP_DROP }
        ];
        if (this.type !== 'raw') {
            chunks.push({
                op: OP_js_1.default['OP_' + this.type]
            });
        }
        chunks.push({ op: value.length, data: value });
        chunks.push({ op: OP_js_1.default.OP_EQUALVERIFY });
        chunks.push({ op: OP_js_1.default.OP_CHECKSIG });
        return new LockingScript_js_1.default(chunks);
    }
    /**
     * Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.
     *
     * The returned object contains:
     * 1. `sign` - A function that, when invoked with a transaction and an input index,
     *    produces an unlocking script suitable for an R puzzle locked output.
     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.
     *
     * @param {BigNumber} k — The K-value used to unlock the R-puzzle.
     * @param {PrivateKey} privateKey - The private key used for signing the transaction. If not provided, a random key will be generated.
     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.
     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.
     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.
     */
    unlock(k, privateKey, signOutputs = 'all', anyoneCanPay = false) {
        return {
            sign: async (tx, inputIndex) => {
                if (typeof privateKey === 'undefined') {
                    privateKey = PrivateKey_js_1.default.fromRandom();
                }
                let signatureScope = TransactionSignature_js_1.default.SIGHASH_FORKID;
                if (signOutputs === 'all') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ALL;
                }
                if (signOutputs === 'none') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_NONE;
                }
                if (signOutputs === 'single') {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_SINGLE;
                }
                if (anyoneCanPay) {
                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ANYONECANPAY;
                }
                const otherInputs = [...tx.inputs];
                const [input] = otherInputs.splice(inputIndex, 1);
                if (typeof input.sourceTransaction !== 'object') {
                    throw new Error('The source transaction is needed for transaction signing.');
                }
                const preimage = TransactionSignature_js_1.default.format({
                    sourceTXID: input.sourceTransaction?.id('hex') ?? '',
                    sourceOutputIndex: input.sourceOutputIndex ?? 0,
                    sourceSatoshis: input.sourceTransaction?.outputs[input.sourceOutputIndex]
                        ?.satoshis ?? 0,
                    transactionVersion: tx.version,
                    otherInputs,
                    inputIndex,
                    outputs: tx.outputs,
                    inputSequence: input.sequence ?? 0xffffffff,
                    subscript: input.sourceTransaction?.outputs[input.sourceOutputIndex]
                        ?.lockingScript ?? new Script_js_1.default(),
                    lockTime: tx.lockTime,
                    scope: signatureScope
                });
                const rawSignature = privateKey.sign((0, Hash_js_1.sha256)(preimage), undefined, true, k);
                const sig = new TransactionSignature_js_1.default(rawSignature.r, rawSignature.s, signatureScope);
                const sigForScript = sig.toChecksigFormat();
                const pubkeyForScript = privateKey
                    .toPublicKey()
                    .encode(true);
                return new UnlockingScript_js_1.default([
                    { op: sigForScript.length, data: sigForScript },
                    { op: pubkeyForScript.length, data: pubkeyForScript }
                ]);
            },
            estimateLength: async () => {
                // public key (1+33) + signature (1+73)
                // Note: We add 1 to each element's length because of the associated OP_PUSH
                return 108;
            }
        };
    }
}
exports.default = RPuzzle;

},{"../../primitives/Hash.js":46,"../../primitives/PrivateKey.js":53,"../../primitives/TransactionSignature.js":60,"../LockingScript.js":66,"../OP.js":67,"../Script.js":68,"../UnlockingScript.js":71}],76:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushDrop = exports.RPuzzle = exports.P2PKH = void 0;
var P2PKH_js_1 = require("./P2PKH.js");
Object.defineProperty(exports, "P2PKH", { enumerable: true, get: function () { return __importDefault(P2PKH_js_1).default; } });
var RPuzzle_js_1 = require("./RPuzzle.js");
Object.defineProperty(exports, "RPuzzle", { enumerable: true, get: function () { return __importDefault(RPuzzle_js_1).default; } });
var PushDrop_js_1 = require("./PushDrop.js");
Object.defineProperty(exports, "PushDrop", { enumerable: true, get: function () { return __importDefault(PushDrop_js_1).default; } });

},{"./P2PKH.js":73,"./PushDrop.js":74,"./RPuzzle.js":75}],77:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageDownloader = void 0;
const index_js_1 = require("../overlay-tools/index.js");
const index_js_2 = require("./index.js");
const PushDrop_js_1 = __importDefault(require("../script/templates/PushDrop.js"));
const Transaction_js_1 = __importDefault(require("../transaction/Transaction.js"));
const index_js_3 = require("../primitives/index.js");
class StorageDownloader {
    constructor(config) {
        this.networkPreset = 'mainnet';
        this.networkPreset = config?.networkPreset ?? 'mainnet';
        this.lookupResolver = new index_js_1.LookupResolver({ networkPreset: this.networkPreset });
    }
    /**
     * Resolves the UHRP URL to a list of HTTP URLs where content can be downloaded.
     * @param uhrpUrl The UHRP URL to resolve.
     * @returns A promise that resolves to an array of HTTP URLs.
     */
    async resolve(uhrpUrl) {
        // Use UHRP lookup service
        const response = await this.lookupResolver.query({ service: 'ls_uhrp', query: { uhrpUrl } });
        if (response.type !== 'output-list') {
            throw new Error('Lookup answer must be an output list');
        }
        const decodedResults = [];
        const currentTime = Math.floor(Date.now() / 1000);
        for (let i = 0; i < response.outputs.length; i++) {
            const tx = Transaction_js_1.default.fromBEEF(response.outputs[i].beef);
            const { fields } = PushDrop_js_1.default.decode(tx.outputs[response.outputs[i].outputIndex].lockingScript);
            const expiryTime = new index_js_3.Utils.Reader(fields[3]).readVarIntNum();
            if (expiryTime < currentTime) {
                continue;
            }
            decodedResults.push(index_js_3.Utils.toUTF8(fields[2]));
        }
        return decodedResults;
    }
    /**
     * Downloads the content from the UHRP URL after validating the hash for integrity.
     * @param uhrpUrl The UHRP URL to download.
     * @returns A promise that resolves to the downloaded content.
     */
    async download(uhrpUrl) {
        if (!index_js_2.StorageUtils.isValidURL(uhrpUrl)) {
            throw new Error('Invalid parameter UHRP url');
        }
        const hash = index_js_2.StorageUtils.getHashFromURL(uhrpUrl);
        const expected = index_js_3.Utils.toHex(hash);
        const downloadURLs = await this.resolve(uhrpUrl);
        if (!Array.isArray(downloadURLs) || downloadURLs.length === 0) {
            throw new Error('No one currently hosts this file!');
        }
        for (let i = 0; i < downloadURLs.length; i++) {
            try {
                // The url is fetched
                const result = await fetch(downloadURLs[i], { method: 'GET' });
                // If the request fails, continue to the next url
                if (!result.ok || result.status >= 400 || result.body == null) {
                    continue;
                }
                const reader = result.body.getReader();
                const hashStream = new index_js_3.Hash.SHA256();
                const chunks = [];
                let totalLength = 0;
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        break;
                    hashStream.update(Array.from(value));
                    chunks.push(value);
                    totalLength += value.length;
                }
                const digest = index_js_3.Utils.toHex(hashStream.digest());
                if (digest !== expected) {
                    throw new Error('Data integrity error: value of content does not match hash of the url given');
                }
                const data = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    data.set(chunk, offset);
                    offset += chunk.length;
                }
                return {
                    data,
                    mimeType: result.headers.get('Content-Type')
                };
            }
            catch (error) {
                continue;
            }
        }
        throw new Error(`Unable to download content from ${uhrpUrl}`);
    }
}
exports.StorageDownloader = StorageDownloader;

},{"../overlay-tools/index.js":39,"../primitives/index.js":61,"../script/templates/PushDrop.js":74,"../transaction/Transaction.js":88,"./index.js":80}],78:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageUploader = void 0;
const AuthFetch_js_1 = require("../auth/clients/AuthFetch.js");
const StorageUtils = __importStar(require("./StorageUtils.js"));
/**
 * The StorageUploader class provides client-side methods for:
 * - Uploading files with a specified retention period
 * - Finding file metadata by UHRP URL
 * - Listing all user uploads
 * - Renewing an existing advertisement's expiry time
 */
class StorageUploader {
    /**
     * Creates a new StorageUploader instance.
     * @param {UploaderConfig} config - An object containing the storage server's URL and a wallet interface
     */
    constructor(config) {
        this.baseURL = config.storageURL;
        this.authFetch = new AuthFetch_js_1.AuthFetch(config.wallet);
    }
    /**
     * Requests information from the server to upload a file (including presigned URL and headers).
     * @private
     * @param {number} fileSize - The size of the file, in bytes
     * @param {number} retentionPeriod - The desired hosting time, in minutes
     * @returns {Promise<{ uploadURL: string; requiredHeaders: Record<string, string>; amount?: number }>}
     * @throws {Error} If the server returns a non-OK response or an error status
     */
    async getUploadInfo(fileSize, retentionPeriod) {
        const url = `${this.baseURL}/upload`;
        const body = { fileSize, retentionPeriod };
        const response = await this.authFetch.fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!response.ok) {
            throw new Error(`Upload info request failed: HTTP ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'error') {
            throw new Error('Upload route returned an error.');
        }
        return {
            uploadURL: data.uploadURL,
            requiredHeaders: data.requiredHeaders,
            amount: data.amount
        };
    }
    /**
     * Performs the actual file upload (HTTP PUT) to the presigned URL returned by the server.
     * @private
     * @param {string} uploadURL - The presigned URL where the file is to be uploaded
     * @param {UploadableFile} file - The file to upload, including its raw data and MIME type
     * @param {Record<string, string>} requiredHeaders - Additional headers required by the server (e.g. content-length)
     * @returns {Promise<UploadFileResult>} An object indicating whether publishing was successful and the resulting UHRP URL
     * @throws {Error} If the server returns a non-OK response
     */
    async uploadFile(uploadURL, file, requiredHeaders) {
        const body = file.data instanceof Uint8Array ? file.data : Uint8Array.from(file.data);
        const response = await fetch(uploadURL, {
            method: 'PUT',
            body,
            headers: {
                'Content-Type': file.type,
                ...requiredHeaders
            }
        });
        if (!response.ok) {
            throw new Error(`File upload failed: HTTP ${response.status}`);
        }
        const uhrpURL = StorageUtils.getURLForFile(body);
        return {
            published: true,
            uhrpURL
        };
    }
    /**
     * Publishes a file to the storage server with the specified retention period.
     *
     * This will:
     * 1. Request an upload URL from the server.
     * 2. Perform an HTTP PUT to upload the file’s raw bytes.
     * 3. Return a UHRP URL referencing the file once published.
     *
     * @param {Object} params
     * @param {UploadableFile} params.file - The file data + type
     * @param {number} params.retentionPeriod - Number of minutes to host the file
     * @returns {Promise<UploadFileResult>} An object with the file's UHRP URL
     * @throws {Error} If the server or upload step returns a non-OK response
     */
    async publishFile(params) {
        const { file, retentionPeriod } = params;
        const data = file.data instanceof Uint8Array ? file.data : Uint8Array.from(file.data);
        const fileSize = data.byteLength;
        const { uploadURL, requiredHeaders } = await this.getUploadInfo(fileSize, retentionPeriod);
        return await this.uploadFile(uploadURL, { data, type: file.type }, requiredHeaders);
    }
    /**
     * Retrieves metadata for a file matching the given UHRP URL from the `/find` route.
     * @param {string} uhrpUrl - The UHRP URL, e.g. "uhrp://abcd..."
     * @returns {Promise<FindFileData>} An object with file name, size, MIME type, and expiry time
     * @throws {Error} If the server or the route returns an error
     */
    async findFile(uhrpUrl) {
        const url = new URL(`${this.baseURL}/find`);
        url.searchParams.set('uhrpUrl', uhrpUrl);
        const response = await this.authFetch.fetch(url.toString(), {
            method: 'GET'
        });
        if (!response.ok) {
            throw new Error(`findFile request failed: HTTP ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'error') {
            const errCode = data.code ?? 'unknown-code';
            const errDesc = data.description ?? 'no-description';
            throw new Error(`findFile returned an error: ${errCode} - ${errDesc}`);
        }
        return data.data;
    }
    /**
     * Lists all advertisements belonging to the user from the `/list` route.
     * @returns {Promise<any>} The array of uploads returned by the server
     * @throws {Error} If the server or the route returns an error
     */
    async listUploads() {
        const url = `${this.baseURL}/list`;
        const response = await this.authFetch.fetch(url, {
            method: 'GET'
        });
        if (!response.ok) {
            throw new Error(`listUploads request failed: HTTP ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'error') {
            const errCode = data.code ?? 'unknown-code';
            const errDesc = data.description ?? 'no-description';
            throw new Error(`listUploads returned an error: ${errCode} - ${errDesc}`);
        }
        return data.uploads;
    }
    /**
     * Renews the hosting time for an existing file advertisement identified by uhrpUrl.
     * Calls the `/renew` route to add `additionalMinutes` to the GCS customTime
     * and re-mint the advertisement token on-chain.
     *
     * @param {string} uhrpUrl - The UHRP URL of the file (e.g., "uhrp://abcd1234...")
     * @param {number} additionalMinutes - The number of minutes to extend
     * @returns {Promise<RenewFileResult>} An object with the new and previous expiry times, plus any cost
     * @throws {Error} If the request fails or the server returns an error
     */
    async renewFile(uhrpUrl, additionalMinutes) {
        const url = `${this.baseURL}/renew`;
        const body = { uhrpUrl, additionalMinutes };
        const response = await this.authFetch.fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!response.ok) {
            throw new Error(`renewFile request failed: HTTP ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'error') {
            const errCode = data.code ?? 'unknown-code';
            const errDesc = data.description ?? 'no-description';
            throw new Error(`renewFile returned an error: ${errCode} - ${errDesc}`);
        }
        return {
            status: data.status,
            prevExpiryTime: data.prevExpiryTime,
            newExpiryTime: data.newExpiryTime,
            amount: data.amount
        };
    }
}
exports.StorageUploader = StorageUploader;

},{"../auth/clients/AuthFetch.js":9,"./StorageUtils.js":79}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidURL = exports.getHashFromURL = exports.getURLForFile = exports.getURLForHash = exports.normalizeURL = void 0;
const utils_js_1 = require("../primitives/utils.js");
const index_js_1 = require("../primitives/index.js");
/**
 * Takes a UHRP URL and removes any prefixes.
 * @param {string} URL - The UHRP URL.
 * @returns {string} - Normalized URL.
 */
const normalizeURL = (URL) => {
    if (URL.toLowerCase().startsWith('uhrp:'))
        URL = URL.slice(5);
    if (URL.startsWith('//'))
        URL = URL.slice(2);
    return URL;
};
exports.normalizeURL = normalizeURL;
/**
 * Generates a UHRP URL from a given SHA-256 hash.
 * @param {number[]} hash - 32-byte SHA-256 hash.
 * @returns {string} - Base58Check encoded URL.
 */
const getURLForHash = (hash) => {
    if (hash.length !== 32) {
        throw new Error('Hash length must be 32 bytes (sha256)');
    }
    return (0, utils_js_1.toBase58Check)(hash, (0, utils_js_1.toArray)('ce00', 'hex'));
};
exports.getURLForHash = getURLForHash;
/**
 * Generates a UHRP URL for a given file.
 * Uses a streaming hash to avoid excessive memory usage with large files.
 * @param {Uint8Array | number[]} file - File content as a typed array or number array.
 * @returns {string} - Base58Check encoded URL.
 */
const getURLForFile = (file) => {
    const data = file instanceof Uint8Array ? file : Uint8Array.from(file);
    const hasher = new index_js_1.Hash.SHA256();
    const chunkSize = 1024 * 1024;
    for (let i = 0; i < data.length; i += chunkSize) {
        const chunk = data.subarray(i, i + chunkSize);
        hasher.update(Array.from(chunk));
    }
    const hash = hasher.digest();
    return (0, exports.getURLForHash)(hash);
};
exports.getURLForFile = getURLForFile;
/**
 * Extracts the hash from a UHRP URL.
 * @param {string} URL - UHRP URL.
 * @returns {number[]} - Extracted SHA-256 hash.
 */
const getHashFromURL = (URL) => {
    URL = (0, exports.normalizeURL)(URL);
    const { data, prefix } = (0, utils_js_1.fromBase58Check)(URL, undefined, 2);
    if (data.length !== 32) {
        throw new Error('Invalid length!');
    }
    if ((0, utils_js_1.toHex)(prefix) !== 'ce00') {
        throw new Error('Bad prefix');
    }
    return data;
};
exports.getHashFromURL = getHashFromURL;
/**
 * Checks if a URL is a valid UHRP URL.
 * @param {string} URL - The URL to validate.
 * @returns {boolean} - True if valid, false otherwise.
 */
const isValidURL = (URL) => {
    try {
        (0, exports.getHashFromURL)(URL);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.isValidURL = isValidURL;

},{"../primitives/index.js":61,"../primitives/utils.js":62}],80:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageDownloader = exports.StorageUploader = exports.StorageUtils = void 0;
exports.StorageUtils = __importStar(require("./StorageUtils.js"));
var StorageUploader_js_1 = require("./StorageUploader.js");
Object.defineProperty(exports, "StorageUploader", { enumerable: true, get: function () { return StorageUploader_js_1.StorageUploader; } });
var StorageDownloader_js_1 = require("./StorageDownloader.js");
Object.defineProperty(exports, "StorageDownloader", { enumerable: true, get: function () { return StorageDownloader_js_1.StorageDownloader; } });

},{"./StorageDownloader.js":77,"./StorageUploader.js":78,"./StorageUtils.js":79}],81:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./totp.js"), exports);

},{"./totp.js":82}],82:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TOTP = void 0;
const Hash_js_1 = require("../primitives/Hash.js");
const BigNumber_js_1 = __importDefault(require("../primitives/BigNumber.js"));
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class TOTP {
    /**
     * Generates a Time-based One-Time Password (TOTP).
     * @param {number[]} secret - The secret key for TOTP.
     * @param {TOTPOptions} options - Optional parameters for TOTP.
     * @returns {string} The generated TOTP.
     */
    static generate(secret, options) {
        const _options = this.withDefaultOptions(options);
        const counter = this.getCounter(_options.timestamp, _options.period);
        const otp = generateHOTP(secret, counter, _options);
        return otp;
    }
    /**
     * Validates a Time-based One-Time Password (TOTP).
     * @param {number[]} secret - The secret key for TOTP.
     * @param {string} passcode - The passcode to validate.
     * @param {TOTPValidateOptions} options - Optional parameters for TOTP validation.
     * @returns {boolean} A boolean indicating whether the passcode is valid.
     */
    static validate(secret, passcode, options) {
        const _options = this.withDefaultValidateOptions(options);
        passcode = passcode.trim();
        if (passcode.length !== _options.digits) {
            return false;
        }
        const counter = this.getCounter(_options.timestamp, _options.period);
        const counters = [counter];
        for (let i = 1; i <= _options.skew; i++) {
            counters.push(counter + i);
            counters.push(counter - i);
        }
        for (const c of counters) {
            if (passcode === generateHOTP(secret, c, _options)) {
                return true;
            }
        }
        return false;
    }
    static getCounter(timestamp, period) {
        const epochSeconds = Math.floor(timestamp / 1000);
        const counter = Math.floor(epochSeconds / period);
        return counter;
    }
    static withDefaultOptions(options) {
        return {
            digits: 2,
            algorithm: 'SHA-1',
            period: 30,
            timestamp: Date.now(),
            ...options
        };
    }
    static withDefaultValidateOptions(options) {
        return { skew: 1, ...this.withDefaultOptions(options) };
    }
}
exports.TOTP = TOTP;
function generateHOTP(secret, counter, options) {
    const timePad = new BigNumber_js_1.default(counter).toArray('be', 8);
    const hmac = calcHMAC(secret, timePad, options.algorithm);
    const signature = hmac.digest();
    // RFC 4226 https://datatracker.ietf.org/doc/html/rfc4226#section-5.4
    const offset = signature[signature.length - 1] & 0x0f; // offset is the last byte in the hmac
    const fourBytesRange = signature.slice(offset, offset + 4); // starting from offset, get 4 bytes
    const mask = 0x7fffffff; // 32-bit number with a leading 0 followed by 31 ones [0111 (...) 1111]
    const masked = new BigNumber_js_1.default(fourBytesRange).toNumber() & mask;
    const otp = masked.toString().slice(-options.digits);
    return otp;
}
function calcHMAC(secret, timePad, algorithm) {
    switch (algorithm) {
        case 'SHA-1':
            return new Hash_js_1.SHA1HMAC(secret).update(timePad);
        case 'SHA-256':
            return new Hash_js_1.SHA256HMAC(secret).update(timePad);
        case 'SHA-512':
            return new Hash_js_1.SHA512HMAC(secret).update(timePad);
        default:
            throw new Error('unsupported HMAC algorithm');
    }
}

},{"../primitives/BigNumber.js":42,"../primitives/Hash.js":46}],83:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Beef = exports.TX_DATA_FORMAT = exports.ATOMIC_BEEF = exports.BEEF_V2 = exports.BEEF_V1 = void 0;
const MerklePath_js_1 = __importDefault(require("./MerklePath.js"));
const BeefTx_js_1 = __importDefault(require("./BeefTx.js"));
const utils_js_1 = require("../primitives/utils.js");
const Hash_js_1 = require("../primitives/Hash.js");
function verifyTruthy(v) {
    if (v == null)
        throw new Error('Expected a valid value, but got undefined.');
    return v;
}
exports.BEEF_V1 = 4022206465; // 0100BEEF in LE order
exports.BEEF_V2 = 4022206466; // 0200BEEF in LE order
exports.ATOMIC_BEEF = 0x01010101; // 01010101
var TX_DATA_FORMAT;
(function (TX_DATA_FORMAT) {
    TX_DATA_FORMAT[TX_DATA_FORMAT["RAWTX"] = 0] = "RAWTX";
    TX_DATA_FORMAT[TX_DATA_FORMAT["RAWTX_AND_BUMP_INDEX"] = 1] = "RAWTX_AND_BUMP_INDEX";
    TX_DATA_FORMAT[TX_DATA_FORMAT["TXID_ONLY"] = 2] = "TXID_ONLY";
})(TX_DATA_FORMAT || (exports.TX_DATA_FORMAT = TX_DATA_FORMAT = {}));
/*
 * BEEF standard: BRC-62: Background Evaluation Extended Format (BEEF) Transactions
 * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0062.md
 *
 * BUMP standard: BRC-74: BSV Unified Merkle Path (BUMP) Format
 * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0074.md
 *
 * BRC-95: Atomic BEEF Transactions
 * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0095.md
 *
 * The Atomic BEEF format is supported by the binary deserialization static method `fromBinary`.
 *
 * BRC-96: BEEF V2, Txid Only Extension
 * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0096.md
 *
 * A valid serialized BEEF is the cornerstone of Simplified Payment Validation (SPV)
 * where they are exchanged between two non-trusting parties to establish the
 * validity of a newly constructed bitcoin transaction and its inputs from prior
 * transactions.
 *
 * A `Beef` is fundamentally an list of `BUMP`s and a list of transactions.
 *
 * A `BUMP` is a partial merkle tree for a 'mined' bitcoin block.
 * It can therefore be used to prove the validity of transaction data
 * for each transaction txid whose merkle path is included in the tree.
 *
 * To be valid, the list of transactions must be sorted in dependency order:
 * oldest transaction first;
 * and each transaction must either
 * have a merkle path in one of the BUMPs, or
 * have all of its input transactions included in the list of transactions.
 *
 * The `Beef` class supports the construction of valid BEEFs by allowing BUMPs
 * (merkle paths) and transactions to be merged sequentially.
 *
 * The `Beef` class also extends the standard by supporting 'known' transactions.
 * A 'known' transaction is represented solely by its txid.
 * To become valid, all the 'known' transactions in a `Beef` must be replaced by full
 * transactions and merkle paths, if they are mined.
 *
 * The purpose of supporting 'known' transactions is that one or both parties
 * generating and exchanging BEEFs often possess partial knowledge of valid transactions
 * due to their history.
 *
 * A valid `Beef` is only required when sent to a party with no shared history,
 * such as a transaction processor.
 *
 * IMPORTANT NOTE:
 * It is fundamental to the BEEF value proposition that only valid transactions and valid
 * merkle path (BUMP) data be added to it. Merging invalid data breaks the `verify` and `isValid`
 * functions. There is no support for removing invalid data. A `Beef` that becomes invalid
 * must be discarded.
 */
class Beef {
    constructor(version = exports.BEEF_V2) {
        this.bumps = [];
        this.txs = [];
        this.version = exports.BEEF_V2;
        this.atomicTxid = undefined;
        this.version = version;
    }
    /**
     * @param txid of `beefTx` to find
     * @returns `BeefTx` in `txs` with `txid`.
     */
    findTxid(txid) {
        return this.txs.find((tx) => tx.txid === txid);
    }
    /**
     * Replaces `BeefTx` for this txid with txidOnly.
     *
     * Replacement is done so that a `clone()` can be
     * updated by this method without affecting the
     * original.
     *
     * @param txid
     * @returns undefined if txid is unknown.
     */
    makeTxidOnly(txid) {
        const i = this.txs.findIndex((tx) => tx.txid === txid);
        if (i === -1)
            return undefined;
        let btx = this.txs[i];
        if (btx.isTxidOnly) {
            return btx;
        }
        this.txs.splice(i, 1);
        btx = this.mergeTxidOnly(txid);
        return btx;
    }
    /**
     * @returns `MerklePath` with level zero hash equal to txid or undefined.
     */
    findBump(txid) {
        return this.bumps.find((b) => b.path[0].some((leaf) => leaf.hash === txid) // ✅ Ensure boolean return with `.some()`
        );
    }
    /**
     * Finds a Transaction in this `Beef`
     * and adds any missing input SourceTransactions from this `Beef`.
     *
     * The result is suitable for signing.
     *
     * @param txid The id of the target transaction.
     * @returns Transaction with all available input `SourceTransaction`s from this Beef.
     */
    findTransactionForSigning(txid) {
        const beefTx = this.findTxid(txid);
        if ((beefTx == null) || (beefTx.tx == null))
            return undefined; // Ensure beefTx.tx exists before using it
        for (const i of beefTx.tx.inputs) {
            if (i.sourceTransaction == null) {
                const itx = this.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid
                if (itx != null) {
                    i.sourceTransaction = itx.tx;
                }
            }
        }
        return beefTx.tx;
    }
    /**
     * Builds the proof tree rooted at a specific `Transaction`.
     *
     * To succeed, the Beef must contain all the required transaction and merkle path data.
     *
     * @param txid The id of the target transaction.
     * @returns Transaction with input `SourceTransaction` and `MerklePath` populated from this Beef.
     */
    findAtomicTransaction(txid) {
        const beefTx = this.findTxid(txid);
        if ((beefTx == null) || (beefTx.tx == null))
            return undefined; // Ensure beefTx.tx exists before using it
        const addInputProof = (beef, tx) => {
            const mp = beef.findBump(tx.id('hex'));
            if (mp != null) {
                tx.merklePath = mp;
            }
            else {
                for (const i of tx.inputs) {
                    if (i.sourceTransaction == null) {
                        const itx = beef.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid
                        if (itx != null) {
                            i.sourceTransaction = itx.tx;
                        }
                    }
                    if (i.sourceTransaction != null) {
                        const mp = beef.findBump(i.sourceTransaction.id('hex'));
                        if (mp != null) {
                            i.sourceTransaction.merklePath = mp;
                        }
                        else {
                            addInputProof(beef, i.sourceTransaction);
                        }
                    }
                }
            }
        };
        addInputProof(this, beefTx.tx); // Safe because we checked that beefTx.tx exists
        return beefTx.tx;
    }
    /**
     * Merge a MerklePath that is assumed to be fully valid.
     * @param bump
     * @returns index of merged bump
     */
    mergeBump(bump) {
        let bumpIndex;
        // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.
        for (let i = 0; i < this.bumps.length; i++) {
            const b = this.bumps[i];
            if (b === bump) {
                // Literally the same
                return i;
            }
            if (b.blockHeight === bump.blockHeight) {
                // Probably the same...
                const rootA = b.computeRoot();
                const rootB = bump.computeRoot();
                if (rootA === rootB) {
                    // Definitely the same... combine them to save space
                    b.combine(bump);
                    bumpIndex = i;
                    break;
                }
            }
        }
        // if the proof is not yet added, add a new path.
        if (bumpIndex === undefined) {
            bumpIndex = this.bumps.length;
            this.bumps.push(bump);
        }
        // Review if any transactions are proven by this bump
        const b = this.bumps[bumpIndex];
        for (const tx of this.txs) {
            const txid = tx.txid;
            if (tx.bumpIndex == null) { // ✅ Explicitly check for null or undefined
                for (const n of b.path[0]) {
                    if (n.hash === txid) {
                        tx.bumpIndex = bumpIndex;
                        n.txid = true;
                        break;
                    }
                }
            }
        }
        return bumpIndex;
    }
    /**
     * Merge a serialized transaction.
     *
     * Checks that a transaction with the same txid hasn't already been merged.
     *
     * Replaces existing transaction with same txid.
     *
     * @param rawTx
     * @param bumpIndex Optional. If a number, must be valid index into bumps array.
     * @returns txid of rawTx
     */
    mergeRawTx(rawTx, bumpIndex) {
        const newTx = new BeefTx_js_1.default(rawTx, bumpIndex);
        this.removeExistingTxid(newTx.txid);
        this.txs.push(newTx);
        this.tryToValidateBumpIndex(newTx);
        return newTx;
    }
    /**
     * Merge a `Transaction` and any referenced `merklePath` and `sourceTransaction`, recursifely.
     *
     * Replaces existing transaction with same txid.
     *
     * Attempts to match an existing bump to the new transaction.
     *
     * @param tx
     * @returns txid of tx
     */
    mergeTransaction(tx) {
        const txid = tx.id('hex');
        this.removeExistingTxid(txid);
        let bumpIndex;
        if (tx.merklePath != null) {
            bumpIndex = this.mergeBump(tx.merklePath);
        }
        const newTx = new BeefTx_js_1.default(tx, bumpIndex);
        this.txs.push(newTx);
        this.tryToValidateBumpIndex(newTx);
        bumpIndex = newTx.bumpIndex;
        if (bumpIndex === undefined) {
            for (const input of tx.inputs) {
                if (input.sourceTransaction != null) {
                    this.mergeTransaction(input.sourceTransaction);
                }
            }
        }
        return newTx;
    }
    /**
     * Removes an existing transaction from the BEEF, given its TXID
     * @param txid TXID of the transaction to remove
     */
    removeExistingTxid(txid) {
        const existingTxIndex = this.txs.findIndex((t) => t.txid === txid);
        if (existingTxIndex >= 0) {
            this.txs.splice(existingTxIndex, 1);
        }
    }
    mergeTxidOnly(txid) {
        let tx = this.txs.find((t) => t.txid === txid);
        if (tx == null) {
            tx = new BeefTx_js_1.default(txid);
            this.txs.push(tx);
            this.tryToValidateBumpIndex(tx);
        }
        return tx;
    }
    mergeBeefTx(btx) {
        let beefTx = this.findTxid(btx.txid);
        if (btx.isTxidOnly && (beefTx == null)) {
            beefTx = this.mergeTxidOnly(btx.txid);
        }
        else if ((btx._tx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {
            beefTx = this.mergeTransaction(btx._tx);
        }
        else if ((btx._rawTx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {
            beefTx = this.mergeRawTx(btx._rawTx);
        }
        if (beefTx == null) {
            throw new Error(`Failed to merge BeefTx for txid: ${btx.txid}`);
        }
        return beefTx;
    }
    mergeBeef(beef) {
        const b = Array.isArray(beef) ? Beef.fromBinary(beef) : beef;
        for (const bump of b.bumps) {
            this.mergeBump(bump);
        }
        for (const tx of b.txs) {
            this.mergeBeefTx(tx);
        }
    }
    /**
     * Sorts `txs` and checks structural validity of beef.
     *
     * Does NOT verify merkle roots.
     *
     * Validity requirements:
     * 1. No 'known' txids, unless `allowTxidOnly` is true.
     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).
     * 3. Order of transactions satisfies dependencies before dependents.
     * 4. No transactions with duplicate txids.
     *
     * @param allowTxidOnly optional. If true, transaction txid only is assumed valid
     */
    isValid(allowTxidOnly) {
        return this.verifyValid(allowTxidOnly).valid;
    }
    /**
     * Sorts `txs` and confirms validity of transaction data contained in beef
     * by validating structure of this beef and confirming computed merkle roots
     * using `chainTracker`.
     *
     * Validity requirements:
     * 1. No 'known' txids, unless `allowTxidOnly` is true.
     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).
     * 3. Order of transactions satisfies dependencies before dependents.
     * 4. No transactions with duplicate txids.
     *
     * @param chainTracker Used to verify computed merkle path roots for all bump txids.
     * @param allowTxidOnly optional. If true, transaction txid is assumed valid
     */
    async verify(chainTracker, allowTxidOnly) {
        const r = this.verifyValid(allowTxidOnly);
        if (!r.valid)
            return false;
        for (const height of Object.keys(r.roots)) {
            const isValid = await chainTracker.isValidRootForHeight(r.roots[height], Number(height));
            if (!isValid) {
                return false;
            }
        }
        return true;
    }
    /**
     * Sorts `txs` and confirms validity of transaction data contained in beef
     * by validating structure of this beef.
     *
     * Returns block heights and merkle root values to be confirmed by a chaintracker.
     *
     * Validity requirements:
     * 1. No 'known' txids, unless `allowTxidOnly` is true.
     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).
     * 3. Order of transactions satisfies dependencies before dependents.
     * 4. No transactions with duplicate txids.
     *
     * @param allowTxidOnly optional. If true, transaction txid is assumed valid
     * @returns {{valid: boolean, roots: Record<number, string>}}
     * `valid` is true iff this Beef is structuraly valid.
     * `roots` is a record where keys are block heights and values are the corresponding merkle roots to be validated.
     */
    verifyValid(allowTxidOnly) {
        const r = {
            valid: false,
            roots: {}
        };
        const sr = this.sortTxs();
        if (sr.missingInputs.length > 0 ||
            sr.notValid.length > 0 ||
            (sr.txidOnly.length > 0 && allowTxidOnly !== true) ||
            sr.withMissingInputs.length > 0) {
            return r;
        }
        // valid txids: only txids if allowed, bump txids, then txids with input's in txids
        const txids = {};
        for (const tx of this.txs) {
            if (tx.isTxidOnly) {
                if (allowTxidOnly !== true)
                    return r; // ✅ Explicit check for `true`
                txids[tx.txid] = true;
            }
        }
        const confirmComputedRoot = (b, txid) => {
            const root = b.computeRoot(txid);
            if (r.roots[b.blockHeight] === undefined || r.roots[b.blockHeight] === '') {
                // accept the root as valid for this block and reuse for subsequent txids
                r.roots[b.blockHeight] = root;
            }
            if (r.roots[b.blockHeight] !== root) {
                return false;
            }
            return true;
        };
        for (const b of this.bumps) {
            for (const n of b.path[0]) {
                if (n.txid === true && typeof n.hash === 'string' && n.hash.length > 0) {
                    txids[n.hash] = true;
                    // All txid hashes in all bumps must agree on computed merkle path roots
                    if (!confirmComputedRoot(b, n.hash)) {
                        return r;
                    }
                }
            }
        }
        // All txs with a bumpIndex have matching txid leaf at level zero of BUMP.
        for (const t of this.txs) {
            if (t.bumpIndex !== undefined) {
                const leaf = this.bumps[t.bumpIndex].path[0].find(l => l.hash === t.txid);
                if (leaf == null) {
                    return r;
                }
            }
        }
        for (const t of this.txs) {
            // all input txids must be included before they are referenced
            for (const i of t.inputTxids) {
                if (!txids[i])
                    return r;
            }
            txids[t.txid] = true;
        }
        r.valid = true;
        return r;
    }
    /**
     * Serializes this data to `writer`
     * @param writer
     */
    toWriter(writer) {
        writer.writeUInt32LE(this.version);
        writer.writeVarIntNum(this.bumps.length);
        for (const b of this.bumps) {
            writer.write(b.toBinary());
        }
        writer.writeVarIntNum(this.txs.length);
        for (const tx of this.txs) {
            tx.toWriter(writer, this.version);
        }
    }
    /**
     * Returns a binary array representing the serialized BEEF
     * @returns A binary array representing the BEEF
     */
    toBinary() {
        // Always serialize in dependency sorted order.
        this.sortTxs();
        const writer = new utils_js_1.Writer();
        this.toWriter(writer);
        return writer.toArray();
    }
    /**
     * Serialize this Beef as AtomicBEEF.
     *
     * `txid` must exist
     *
     * after sorting, if txid is not last txid, creates a clone and removes newer txs
     *
     * @param txid
     * @returns serialized contents of this Beef with AtomicBEEF prefix.
     */
    toBinaryAtomic(txid) {
        this.sortTxs();
        const tx = this.findTxid(txid);
        if (tx == null) {
            throw new Error(`${txid} does not exist in this Beef`);
        }
        // If the transaction is not the last one, clone and modify
        const beef = (this.txs[this.txs.length - 1] === tx) ? this : this.clone();
        if (beef !== this) {
            const i = this.txs.findIndex((t) => t.txid === txid);
            beef.txs.splice(i + 1);
        }
        const writer = new utils_js_1.Writer();
        writer.writeUInt32LE(exports.ATOMIC_BEEF);
        writer.writeReverse((0, utils_js_1.toArray)(txid, 'hex'));
        beef.toWriter(writer);
        return writer.toArray();
    }
    /**
     * Returns a hex string representing the serialized BEEF
     * @returns A hex string representing the BEEF
     */
    toHex() {
        return (0, utils_js_1.toHex)(this.toBinary());
    }
    static fromReader(br) {
        let version = br.readUInt32LE();
        let atomicTxid;
        if (version === exports.ATOMIC_BEEF) {
            // Skip the txid and re-read the BEEF version
            atomicTxid = (0, utils_js_1.toHex)(br.readReverse(32));
            version = br.readUInt32LE();
        }
        if (version !== exports.BEEF_V1 && version !== exports.BEEF_V2) {
            throw new Error(`Serialized BEEF must start with ${exports.BEEF_V1} or ${exports.BEEF_V2} but starts with ${version}`);
        }
        const beef = new Beef(version);
        const bumpsLength = br.readVarIntNum();
        for (let i = 0; i < bumpsLength; i++) {
            const bump = MerklePath_js_1.default.fromReader(br, false);
            beef.bumps.push(bump);
        }
        const txsLength = br.readVarIntNum();
        for (let i = 0; i < txsLength; i++) {
            const beefTx = BeefTx_js_1.default.fromReader(br, version);
            beef.txs.push(beefTx);
        }
        beef.atomicTxid = atomicTxid;
        return beef;
    }
    /**
     * Constructs an instance of the Beef class based on the provided binary array
     * @param bin The binary array from which to construct BEEF
     * @returns An instance of the Beef class constructed from the binary data
     */
    static fromBinary(bin) {
        const br = new utils_js_1.Reader(bin);
        return Beef.fromReader(br);
    }
    /**
     * Constructs an instance of the Beef class based on the provided string
     * @param s The string value from which to construct BEEF
     * @param enc The encoding of the string value from which BEEF should be constructed
     * @returns An instance of the Beef class constructed from the string
     */
    static fromString(s, enc = 'hex') {
        const bin = (0, utils_js_1.toArray)(s, enc);
        const br = new utils_js_1.Reader(bin);
        return Beef.fromReader(br);
    }
    /**
     * Try to validate newTx.bumpIndex by looking for an existing bump
     * that proves newTx.txid
     *
     * @param newTx A new `BeefTx` that has been added to this.txs
     * @returns true if a bump was found, false otherwise
     */
    tryToValidateBumpIndex(newTx) {
        if (newTx.bumpIndex !== undefined) {
            return true;
        }
        const txid = newTx.txid;
        for (let i = 0; i < this.bumps.length; i++) {
            const j = this.bumps[i].path[0].findIndex((b) => b.hash === txid);
            if (j >= 0) {
                newTx.bumpIndex = i;
                this.bumps[i].path[0][j].txid = true;
                return true;
            }
        }
        return false;
    }
    /**
     * Sort the `txs` by input txid dependency order:
     * - Oldest Tx Anchored by Path or txid only
     * - Newer Txs depending on Older parents
     * - Newest Tx
     *
     * with proof (MerklePath) last, longest chain of dependencies first
     *
     * @returns `{ missingInputs, notValid, valid, withMissingInputs }`
     */
    sortTxs() {
        // Hashtable of valid txids (with proof or all inputs chain to proof)
        const validTxids = {};
        // Hashtable of all transaction txids to transaction
        const txidToTx = {};
        // queue of unsorted transactions ...
        let queue = [];
        // sorted transactions: hasProof to with longest dependency chain
        const result = [];
        const txidOnly = [];
        for (const tx of this.txs) {
            txidToTx[tx.txid] = tx;
            tx.isValid = tx.hasProof;
            if (tx.isValid) {
                validTxids[tx.txid] = true;
                result.push(tx);
            }
            else if (tx.isTxidOnly && tx.inputTxids.length === 0) {
                validTxids[tx.txid] = true;
                txidOnly.push(tx);
            }
            else {
                queue.push(tx);
            }
        }
        // Hashtable of unknown input txids used to fund transactions without their own proof.
        const missingInputs = {};
        // transactions with one or more missing inputs
        const txsMissingInputs = [];
        const possiblyMissingInputs = queue;
        queue = [];
        // all tx are isValid false, hasProof false.
        // if isTxidOnly then has inputTxids
        for (const tx of possiblyMissingInputs) {
            let hasMissingInput = false;
            // For all the unproven transactions,
            // link their inputs that exist in this beef,
            // make a note of missing inputs.
            for (const inputTxid of tx.inputTxids) {
                if (txidToTx[inputTxid] === undefined) { // Explicitly check for undefined
                    missingInputs[inputTxid] = true;
                    hasMissingInput = true;
                }
            }
            if (hasMissingInput) {
                txsMissingInputs.push(tx);
            }
            else {
                queue.push(tx);
            }
        }
        // As long as we have unsorted transactions...
        while (queue.length > 0) {
            const oldQueue = queue;
            queue = [];
            // all tx are isValid false, hasProof false.
            // if isTxidOnly then has inputTxids
            for (const tx of oldQueue) {
                if (tx.inputTxids.every((txid) => validTxids[txid])) {
                    validTxids[tx.txid] = true;
                    result.push(tx);
                }
                else {
                    queue.push(tx);
                }
            }
            if (oldQueue.length === queue.length) {
                break;
            }
        }
        // transactions that don't have proofs and don't chain to proofs
        const txsNotValid = queue;
        // New order of txs is unsortable (missing inputs or depends on missing inputs), txidOnly, sorted (so newest sorted is last)
        this.txs = txsMissingInputs
            .concat(txsNotValid)
            .concat(txidOnly)
            .concat(result);
        return {
            missingInputs: Object.keys(missingInputs),
            notValid: txsNotValid.map((tx) => tx.txid),
            valid: Object.keys(validTxids),
            withMissingInputs: txsMissingInputs.map((tx) => tx.txid),
            txidOnly: txidOnly.map((tx) => tx.txid)
        };
    }
    /**
     * @returns a shallow copy of this beef
     */
    clone() {
        const c = new Beef();
        c.version = this.version;
        c.bumps = Array.from(this.bumps);
        c.txs = Array.from(this.txs);
        return c;
    }
    /**
     * Ensure that all the txids in `knownTxids` are txidOnly
     * @param knownTxids
     */
    trimKnownTxids(knownTxids) {
        for (let i = 0; i < this.txs.length;) {
            const tx = this.txs[i];
            if (tx.isTxidOnly && knownTxids.includes(tx.txid)) {
                this.txs.splice(i, 1);
            }
            else {
                i++;
            }
        }
        // TODO: bumps could be trimmed to eliminate unreferenced proofs.
    }
    /**
     * @returns array of transaction txids that either have a proof or whose inputs chain back to a proven transaction.
     */
    getValidTxids() {
        const r = this.sortTxs();
        return r.valid;
    }
    /**
     * @returns Summary of `Beef` contents as multi-line string.
     */
    toLogString() {
        let log = '';
        log += `BEEF with ${this.bumps.length} BUMPS and ${this.txs.length} Transactions, isValid ${this.isValid().toString()}\n`;
        let i = -1;
        for (const b of this.bumps) {
            i++;
            log += `  BUMP ${i}\n    block: ${b.blockHeight}\n    txids: [\n${b.path[0]
                .filter((n) => n.txid === true) // ✅ Explicitly check if txid is `true`
                .map((n) => `      '${n.hash ?? ''}'`)
                .join(',\n')}\n    ]\n`;
        }
        i = -1;
        for (const t of this.txs) {
            i++;
            log += `  TX ${i}\n    txid: ${t.txid}\n`;
            if (t.bumpIndex !== undefined) {
                log += `    bumpIndex: ${t.bumpIndex}\n`;
            }
            if (t.isTxidOnly) {
                log += '    txidOnly\n';
            }
            else {
                log += `    rawTx length=${t.rawTx?.length ?? 0}\n`; // ✅ Fix applied here
            }
            if (t.inputTxids.length > 0) {
                log += `    inputs: [\n${t.inputTxids
                    .map((it) => `      '${it}'`)
                    .join(',\n')}\n    ]\n`;
            }
        }
        return log;
    }
    /**
   * In some circumstances it may be helpful for the BUMP MerklePaths to include
   * leaves that can be computed from row zero.
   */
    addComputedLeaves() {
        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());
        for (const bump of this.bumps) { // ✅ Use `this` instead of `beef`
            for (let row = 1; row < bump.path.length; row++) {
                for (const leafL of bump.path[row - 1]) {
                    if (typeof leafL.hash === 'string' && (leafL.offset & 1) === 0) {
                        const leafR = bump.path[row - 1].find((l) => l.offset === leafL.offset + 1);
                        const offsetOnRow = leafL.offset >> 1;
                        if (leafR !== undefined &&
                            typeof leafR.hash === 'string' &&
                            bump.path[row].every((l) => l.offset !== offsetOnRow)) {
                            // Computable leaf is missing... add it.
                            bump.path[row].push({
                                offset: offsetOnRow,
                                // String concatenation puts the right leaf on the left of the left leaf hash
                                hash: hash(leafR.hash + leafL.hash)
                            });
                        }
                    }
                }
            }
        }
    }
}
exports.Beef = Beef;

},{"../primitives/Hash.js":46,"../primitives/utils.js":62,"./BeefTx.js":85,"./MerklePath.js":87}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeefParty = void 0;
const Beef_js_1 = require("./Beef.js");
/**
 * Extends `Beef` that is used to exchange transaction validity data with more than one external party.
 *
 * Use `addKnownTxidsForParty` to keep track of who knows what to reduce re-transmission of potentially large transactions.
 *
 * Use `getTrimmedBeefForParty` to obtain a `Beef` trimmed of transaction validity data known to a specific party.
 *
 * Typical usage scenario:
 *
 * 1. Query a wallet storage provider for spendable outputs.
 * 2. The provider replies with a Beef validating the returned outputs.
 * 3. Construct a new transaction using some of the queried outputs as inputs, including Beef validating all the inputs.
 * 4. Receive new valid raw transaction after processing and Beef validating change outputs added to original inputs.
 * 5. Return to step 1, continuing to build on old and new spendable outputs.
 *
 * By default, each Beef is required to be complete and valid: All transactions appear as full serialized bitcoin transactions and
 * each transaction either has a merkle path proof (it has been mined) or all of its input transactions are included.
 *
 * The size and redundancy of these Beefs becomes a problem when chained transaction creation out-paces the block mining rate.
 *
 */
class BeefParty extends Beef_js_1.Beef {
    /**
     *
     * @param parties Optional array of initial unique party identifiers.
     */
    constructor(parties) {
        super();
        /**
         * keys are party identifiers.
         * values are records of txids with truthy value for which the party already has validity proof.
         */
        this.knownTo = {};
        if (parties != null) {
            for (const party of parties) {
                this.addParty(party);
            }
        }
    }
    /**
     * @param party
     * @returns `true` if `party` has already been added to this `BeefParty`.
     */
    isParty(party) {
        const r = Object.keys(this.knownTo).includes(party);
        return r;
    }
    /**
     * Adds a new unique party identifier to this `BeefParty`.
     * @param party
     */
    addParty(party) {
        if (this.isParty(party)) {
            throw new Error(`Party ${party} already exists.`);
        }
        this.knownTo[party] = {};
    }
    /**
     * @param party
     * @returns Array of txids "known" to `party`.
     */
    getKnownTxidsForParty(party) {
        const knownTxids = this.knownTo[party];
        if (knownTxids === undefined) { // ✅ Explicitly check for undefined
            throw new Error(`Party ${party} is unknown.`);
        }
        return Object.keys(knownTxids);
    }
    /**
     * @param party
     * @returns trimmed beef of unknown transactions and proofs for `party`
     */
    getTrimmedBeefForParty(party) {
        const knownTxids = this.getKnownTxidsForParty(party);
        const prunedBeef = this.clone();
        prunedBeef.trimKnownTxids(knownTxids);
        return prunedBeef;
    }
    /**
     * Make note of additional txids "known" to `party`.
     * @param party unique identifier, added if new.
     * @param knownTxids
     */
    addKnownTxidsForParty(party, knownTxids) {
        if (!this.isParty(party)) {
            this.addParty(party);
        }
        const kts = this.knownTo[party];
        for (const txid of knownTxids) {
            kts[txid] = true;
            this.mergeTxidOnly(txid);
        }
    }
    /**
     * Merge a `beef` received from a specific `party`.
     *
     * Updates this `BeefParty` to track all the txids
     * corresponding to transactions for which `party`
     * has raw transaction and validity proof data.
     *
     * @param party
     * @param beef
     */
    mergeBeefFromParty(party, beef) {
        const b = Array.isArray(beef) ? Beef_js_1.Beef.fromBinary(beef) : beef;
        const knownTxids = b.getValidTxids();
        this.mergeBeef(b);
        this.addKnownTxidsForParty(party, knownTxids);
    }
}
exports.BeefParty = BeefParty;
exports.default = BeefParty;

},{"./Beef.js":83}],85:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Hash_js_1 = require("../primitives/Hash.js");
const utils_js_1 = require("../primitives/utils.js");
const Transaction_js_1 = __importDefault(require("./Transaction.js"));
const Beef_js_1 = require("./Beef.js");
/**
 * A single bitcoin transaction associated with a `Beef` validity proof set.
 *
 * Simple case is transaction data included directly, either as raw bytes or fully parsed data, or both.
 *
 * Supports 'known' transactions which are represented by just their txid.
 * It is assumed that intended consumer of this beef already has validity proof for such a transaction,
 * which they can merge if necessary to create a valid beef.
 */
class BeefTx {
    get bumpIndex() {
        return this._bumpIndex;
    }
    set bumpIndex(v) {
        this._bumpIndex = v;
        this.updateInputTxids();
    }
    get hasProof() {
        return this._bumpIndex !== undefined;
    }
    get isTxidOnly() {
        return this._txid !== undefined && this._txid !== null && (this._rawTx == null) && (this._tx == null);
    }
    get txid() {
        if (this._txid !== undefined && this._txid !== null && this._txid !== '')
            return this._txid;
        if (this._tx != null) {
            this._txid = this._tx.id('hex');
            return this._txid;
        }
        if (this._rawTx != null) {
            this._txid = (0, utils_js_1.toHex)((0, Hash_js_1.hash256)(this._rawTx));
            return this._txid;
        }
        throw new Error('Internal');
    }
    get tx() {
        if (this._tx != null)
            return this._tx;
        if (this._rawTx != null) {
            this._tx = Transaction_js_1.default.fromBinary(this._rawTx);
            return this._tx;
        }
        return undefined;
    }
    get rawTx() {
        if (this._rawTx != null)
            return this._rawTx;
        if (this._tx != null) {
            this._rawTx = this._tx.toBinary();
            return this._rawTx;
        }
        return undefined;
    }
    /**
     * @param tx If string, must be a valid txid. If `number[]` must be a valid serialized transaction.
     * @param bumpIndex If transaction already has a proof in the beef to which it will be added.
     */
    constructor(tx, bumpIndex) {
        this.inputTxids = [];
        /**
         * true if `hasProof` or all inputs chain to `hasProof`.
         *
         * Typically set by sorting transactions by proven dependency chains.
         */
        this.isValid = undefined;
        if (typeof tx === 'string') {
            this._txid = tx;
        }
        else if (Array.isArray(tx)) {
            this._rawTx = tx;
        }
        else {
            this._tx = tx;
        }
        this.bumpIndex = bumpIndex;
        this.updateInputTxids();
    }
    static fromTx(tx, bumpIndex) {
        return new BeefTx(tx, bumpIndex);
    }
    static fromRawTx(rawTx, bumpIndex) {
        return new BeefTx(rawTx, bumpIndex);
    }
    static fromTxid(txid, bumpIndex) {
        return new BeefTx(txid, bumpIndex);
    }
    updateInputTxids() {
        if (this.hasProof || (this.tx == null)) {
            // If we have a proof, or don't have a parsed transaction
            this.inputTxids = [];
        }
        else {
            const inputTxids = {}; // ✅ Explicit object type
            for (const input of this.tx.inputs) {
                if (input.sourceTXID !== undefined && input.sourceTXID !== null && input.sourceTXID !== '') {
                    // ✅ Ensure sourceTXID is defined
                    inputTxids[input.sourceTXID] = true;
                }
            }
            this.inputTxids = Object.keys(inputTxids);
        }
    }
    toWriter(writer, version) {
        const writeByte = (bb) => {
            writer.writeUInt8(bb);
        };
        const writeTxid = () => {
            if (this._txid == null) {
                throw new Error('Transaction ID (_txid) is undefined');
            }
            writer.writeReverse((0, utils_js_1.toArray)(this._txid, 'hex'));
        };
        const writeTx = () => {
            if (this._rawTx != null) {
                writer.write(this._rawTx);
            }
            else if (this._tx != null) {
                writer.write(this._tx.toBinary());
            }
            else {
                throw new Error('a valid serialized Transaction is expected');
            }
        };
        const writeBumpIndex = () => {
            if (this.bumpIndex === undefined) {
                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX); // 0
            }
            else {
                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX); // 1
                writer.writeVarIntNum(this.bumpIndex); // the index of the associated bump
            }
        };
        if (version === Beef_js_1.BEEF_V2) {
            if (this.isTxidOnly) {
                writeByte(Beef_js_1.TX_DATA_FORMAT.TXID_ONLY);
                writeTxid();
            }
            else if (this.bumpIndex !== undefined) {
                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX);
                writer.writeVarIntNum(this.bumpIndex);
                writeTx();
            }
            else {
                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX);
                writeTx();
            }
        }
        else {
            writeTx();
            writeBumpIndex();
        }
    }
    static fromReader(br, version) {
        let data;
        let bumpIndex;
        let beefTx;
        if (version === Beef_js_1.BEEF_V2) {
            // V2
            const format = br.readUInt8();
            if (format === Beef_js_1.TX_DATA_FORMAT.TXID_ONLY) {
                beefTx = BeefTx.fromTxid((0, utils_js_1.toHex)(br.readReverse(32)));
            }
            else {
                if (format === Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX) {
                    bumpIndex = br.readVarIntNum();
                }
                data = Transaction_js_1.default.fromReader(br);
                beefTx = BeefTx.fromTx(data, bumpIndex);
            }
        }
        else {
            // V1
            data = Transaction_js_1.default.fromReader(br);
            bumpIndex = br.readUInt8() !== 0 ? br.readVarIntNum() : undefined;
            beefTx = BeefTx.fromTx(data, bumpIndex);
        }
        return beefTx;
    }
}
exports.default = BeefTx;

},{"../primitives/Hash.js":46,"../primitives/utils.js":62,"./Beef.js":83,"./Transaction.js":88}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBroadcastFailure = exports.isBroadcastResponse = void 0;
/**
 * Convenience type guard for response from `Broadcaster.broadcast`
 */
function isBroadcastResponse(r) {
    return r.status === 'success';
}
exports.isBroadcastResponse = isBroadcastResponse;
/**
 * Convenience type guard for response from `Broadcaster.broadcast`
 */
function isBroadcastFailure(r) {
    return r.status === 'error';
}
exports.isBroadcastFailure = isBroadcastFailure;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("../primitives/utils.js");
const Hash_js_1 = require("../primitives/Hash.js");
/**
 * Represents a Merkle Path, which is used to provide a compact proof of inclusion for a
 * transaction in a block. This class encapsulates all the details required for creating
 * and verifying Merkle Proofs.
 *
 * @class MerklePath
 * @property {number} blockHeight - The height of the block in which the transaction is included.
 * @property {Array<Array<{offset: number, hash?: string, txid?: boolean, duplicate?: boolean}>>} path -
 *           A tree structure representing the Merkle Path, with each level containing information
 *           about the nodes involved in constructing the proof.
 *
 * @example
 * // Creating and verifying a Merkle Path
 * const merklePath = MerklePath.fromHex('...');
 * const isValid = merklePath.verify(txid, chainTracker);
 *
 * @description
 * The MerklePath class is useful for verifying transactions in a lightweight and efficient manner without
 * needing the entire block data. This class offers functionalities for creating, converting,
 * and verifying these proofs.
 */
class MerklePath {
    /**
     * Creates a MerklePath instance from a hexadecimal string.
     *
     * @static
     * @param {string} hex - The hexadecimal string representation of the Merkle Path.
     * @returns {MerklePath} - A new MerklePath instance.
     */
    static fromHex(hex) {
        return MerklePath.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));
    }
    static fromReader(reader, legalOffsetsOnly = true) {
        const blockHeight = reader.readVarIntNum();
        const treeHeight = reader.readUInt8();
        // Explicitly define the type of path as an array of arrays of leaf objects
        const path = Array(treeHeight)
            .fill(null)
            .map(() => []);
        let flags, offset, nLeavesAtThisHeight;
        for (let level = 0; level < treeHeight; level++) {
            nLeavesAtThisHeight = reader.readVarIntNum();
            while (nLeavesAtThisHeight > 0) {
                offset = reader.readVarIntNum();
                flags = reader.readUInt8();
                const leaf = { offset };
                if ((flags & 1) !== 0) {
                    leaf.duplicate = true;
                }
                else {
                    if ((flags & 2) !== 0) {
                        leaf.txid = true;
                    }
                    leaf.hash = (0, utils_js_1.toHex)(reader.read(32).reverse());
                }
                // Ensure path[level] exists before pushing
                if (!Array.isArray(path[level]) || path[level].length === 0) {
                    path[level] = [];
                }
                path[level].push(leaf);
                nLeavesAtThisHeight--;
            }
            // Sort the array based on the offset property
            path[level].sort((a, b) => a.offset - b.offset);
        }
        return new MerklePath(blockHeight, path, legalOffsetsOnly);
    }
    /**
     * Creates a MerklePath instance from a binary array.
     *
     * @static
     * @param {number[]} bump - The binary array representation of the Merkle Path.
     * @returns {MerklePath} - A new MerklePath instance.
     */
    static fromBinary(bump) {
        const reader = new utils_js_1.Reader(bump);
        return MerklePath.fromReader(reader);
    }
    /**
     *
     * @static fromCoinbaseTxid
     *
     * Creates a MerklePath instance for a coinbase transaction in an empty block.
     * This edge case is difficult to retrieve from standard APIs.
     *
     * @param {string} txid - The coinbase txid.
     * @param {number} height - The height of the block.
     * @returns {MerklePath} - A new MerklePath instance which assumes the tx is in a block with no other transactions.
     */
    static fromCoinbaseTxidAndHeight(txid, height) {
        return new MerklePath(height, [[{ offset: 0, hash: txid, txid: true }]]);
    }
    constructor(blockHeight, path, legalOffsetsOnly = true) {
        this.blockHeight = blockHeight;
        this.path = path;
        // store all of the legal offsets which we expect given the txid indices.
        const legalOffsets = Array(this.path.length)
            .fill(0)
            .map(() => new Set());
        this.path.forEach((leaves, height) => {
            if (leaves.length === 0 && height === 0) {
                throw new Error(`Empty level at height: ${height}`);
            }
            const offsetsAtThisHeight = new Set();
            leaves.forEach((leaf) => {
                if (offsetsAtThisHeight.has(leaf.offset)) {
                    throw new Error(`Duplicate offset: ${leaf.offset}, at height: ${height}`);
                }
                offsetsAtThisHeight.add(leaf.offset);
                if (height === 0) {
                    if (leaf.duplicate !== true) {
                        for (let h = 1; h < this.path.length; h++) {
                            legalOffsets[h].add((leaf.offset >> h) ^ 1);
                        }
                    }
                }
                else {
                    if (legalOffsetsOnly && !legalOffsets[height].has(leaf.offset)) {
                        throw new Error(`Invalid offset: ${leaf.offset}, at height: ${height}, with legal offsets: ${Array.from(legalOffsets[height]).join(', ')}`);
                    }
                }
            });
        });
        // every txid must calculate to the same root.
        let root;
        this.path[0].forEach((leaf, idx) => {
            if (idx === 0)
                root = this.computeRoot(leaf.hash);
            if (root !== this.computeRoot(leaf.hash)) {
                throw new Error('Mismatched roots');
            }
        });
    }
    /**
     * Converts the MerklePath to a binary array format.
     *
     * @returns {number[]} - The binary array representation of the Merkle Path.
     */
    toBinary() {
        const writer = new utils_js_1.Writer();
        writer.writeVarIntNum(this.blockHeight);
        const treeHeight = this.path.length;
        writer.writeUInt8(treeHeight);
        for (let level = 0; level < treeHeight; level++) {
            const nLeaves = Object.keys(this.path[level]).length;
            writer.writeVarIntNum(nLeaves);
            for (const leaf of this.path[level]) {
                writer.writeVarIntNum(leaf.offset);
                let flags = 0;
                if (leaf?.duplicate === true) {
                    flags |= 1;
                }
                if (leaf?.txid !== undefined && leaf.txid !== null) {
                    flags |= 2;
                }
                writer.writeUInt8(flags);
                if ((flags & 1) === 0) {
                    writer.write((0, utils_js_1.toArray)(leaf.hash, 'hex').reverse());
                }
            }
        }
        return writer.toArray();
    }
    /**
     * Converts the MerklePath to a hexadecimal string format.
     *
     * @returns {string} - The hexadecimal string representation of the Merkle Path.
     */
    toHex() {
        return (0, utils_js_1.toHex)(this.toBinary());
    }
    //
    indexOf(txid) {
        const leaf = this.path[0].find((l) => l.hash === txid);
        if (leaf === null || leaf === undefined) {
            throw new Error(`Transaction ID ${txid} not found in the Merkle Path`);
        }
        return leaf.offset;
    }
    /**
     * Computes the Merkle root from the provided transaction ID.
     *
     * @param {string} txid - The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!
     * @returns {string} - The computed Merkle root as a hexadecimal string.
     * @throws {Error} - If the transaction ID is not part of the Merkle Path.
     */
    computeRoot(txid) {
        if (typeof txid !== 'string') {
            const foundLeaf = this.path[0].find((leaf) => Boolean(leaf?.hash));
            if (foundLeaf === null || foundLeaf === undefined) {
                throw new Error('No valid leaf found in the Merkle Path');
            }
            txid = foundLeaf.hash;
        }
        // Find the index of the txid at the lowest level of the Merkle tree
        if (typeof txid !== 'string') {
            throw new Error('Transaction ID is undefined');
        }
        const index = this.indexOf(txid);
        if (typeof index !== 'number') {
            throw new Error(`This proof does not contain the txid: ${txid ?? 'undefined'}`);
        }
        // Calculate the root using the index as a way to determine which direction to concatenate.
        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());
        let workingHash = txid;
        // special case for blocks with only one transaction
        if (this.path.length === 1 && this.path[0].length === 1)
            return workingHash;
        for (let height = 0; height < this.path.length; height++) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const leaves = this.path[height];
            const offset = (index >> height) ^ 1;
            const leaf = this.findOrComputeLeaf(height, offset);
            if (typeof leaf !== 'object') {
                throw new Error(`Missing hash for index ${index} at height ${height}`);
            }
            if (leaf.duplicate === true) {
                workingHash = hash((workingHash ?? '') + (workingHash ?? ''));
            }
            else if (offset % 2 !== 0) {
                workingHash = hash((leaf.hash ?? '') + (workingHash ?? ''));
            }
            else {
                workingHash = hash((workingHash ?? '') + (leaf.hash ?? ''));
            }
        }
        return workingHash;
    }
    /**
     * Find leaf with `offset` at `height` or compute from level below, recursively.
     *
     * Does not add computed leaves to path.
     *
     * @param height
     * @param offset
     */
    findOrComputeLeaf(height, offset) {
        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());
        let leaf = this.path[height].find((l) => l.offset === offset);
        if (leaf != null)
            return leaf;
        if (height === 0)
            return undefined;
        const h = height - 1;
        const l = offset << 1;
        const leaf0 = this.findOrComputeLeaf(h, l);
        if (leaf0 == null || leaf0.hash == null || leaf0.hash === '')
            return undefined;
        const leaf1 = this.findOrComputeLeaf(h, l + 1);
        if (leaf1 == null)
            return undefined;
        let workinghash;
        if (leaf1.duplicate === true) {
            workinghash = hash(leaf0.hash + leaf0.hash);
        }
        else {
            workinghash = hash((leaf1.hash ?? '') + (leaf0.hash ?? ''));
        }
        leaf = {
            offset,
            hash: workinghash
        };
        return leaf;
    }
    /**
     * Verifies if the given transaction ID is part of the Merkle tree at the specified block height.
     *
     * @param {string} txid - The transaction ID to verify.
     * @param {ChainTracker} chainTracker - The ChainTracker instance used to verify the Merkle root.
     * @returns {boolean} - True if the transaction ID is valid within the Merkle Path at the specified block height.
     */
    async verify(txid, chainTracker) {
        const root = this.computeRoot(txid);
        if (this.indexOf(txid) === 0) {
            // Coinbase transaction outputs can only be spent once they're 100 blocks deep.
            const height = await chainTracker.currentHeight();
            if (this.blockHeight + 100 < height) {
                return false;
            }
        }
        // Use the chain tracker to determine whether this is a valid merkle root at the given block height
        return await chainTracker.isValidRootForHeight(root, this.blockHeight);
    }
    /**
     * Combines this MerklePath with another to create a compound proof.
     *
     * @param {MerklePath} other - Another MerklePath to combine with this path.
     * @throws {Error} - If the paths have different block heights or roots.
     */
    combine(other) {
        if (this.blockHeight !== other.blockHeight) {
            throw new Error('You cannot combine paths which do not have the same block height.');
        }
        const root1 = this.computeRoot();
        const root2 = other.computeRoot();
        if (root1 !== root2) {
            throw new Error('You cannot combine paths which do not have the same root.');
        }
        const combinedPath = [];
        for (let h = 0; h < this.path.length; h++) {
            combinedPath.push([]);
            for (let l = 0; l < this.path[h].length; l++) {
                combinedPath[h].push(this.path[h][l]);
            }
            for (let l = 0; l < other.path[h].length; l++) {
                if (combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset) === undefined) {
                    combinedPath[h].push(other.path[h][l]);
                }
                else {
                    // Ensure that any elements which appear in both are not downgraded to a non txid.
                    if (other.path[h][l]?.txid !== undefined && other.path[h][l]?.txid !== null) {
                        const target = combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset);
                        if (target !== null && target !== undefined) {
                            target.txid = true;
                        }
                    }
                }
            }
        }
        this.path = combinedPath;
        this.trim();
    }
    /**
     * Remove all internal nodes that are not required by level zero txid nodes.
     * Assumes that at least all required nodes are present.
     * Leaves all levels sorted by increasing offset.
     */
    trim() {
        const pushIfNew = (v, a) => {
            if (a.length === 0 || a.slice(-1)[0] !== v) {
                a.push(v);
            }
        };
        const dropOffsetsFromLevel = (dropOffsets, level) => {
            for (let i = dropOffsets.length; i >= 0; i--) {
                const l = this.path[level].findIndex((n) => n.offset === dropOffsets[i]);
                if (l >= 0) {
                    this.path[level].splice(l, 1);
                }
            }
        };
        const nextComputedOffsets = (cos) => {
            const ncos = [];
            for (const o of cos) {
                pushIfNew(o >> 1, ncos);
            }
            return ncos;
        };
        let computedOffsets = []; // in next level
        let dropOffsets = [];
        for (let h = 0; h < this.path.length; h++) {
            // Sort each level by increasing offset order
            this.path[h].sort((a, b) => a.offset - b.offset);
        }
        for (let l = 0; l < this.path[0].length; l++) {
            const n = this.path[0][l];
            if (n.txid === true) {
                // level 0 must enable computing level 1 for txid nodes
                pushIfNew(n.offset >> 1, computedOffsets);
            }
            else {
                const isOdd = n.offset % 2 === 1;
                const peer = this.path[0][l + (isOdd ? -1 : 1)];
                if (peer.txid === undefined || peer.txid === null || !peer.txid) {
                    // drop non-txid level 0 nodes without a txid peer
                    pushIfNew(peer.offset, dropOffsets);
                }
            }
        }
        dropOffsetsFromLevel(dropOffsets, 0);
        for (let h = 1; h < this.path.length; h++) {
            dropOffsets = computedOffsets;
            computedOffsets = nextComputedOffsets(computedOffsets);
            dropOffsetsFromLevel(dropOffsets, h);
        }
    }
}
exports.default = MerklePath;

},{"../primitives/Hash.js":46,"../primitives/utils.js":62}],88:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const UnlockingScript_js_1 = __importDefault(require("../script/UnlockingScript.js"));
const LockingScript_js_1 = __importDefault(require("../script/LockingScript.js"));
const utils_js_1 = require("../primitives/utils.js");
const Hash_js_1 = require("../primitives/Hash.js");
const SatoshisPerKilobyte_js_1 = __importDefault(require("./fee-models/SatoshisPerKilobyte.js"));
const Spend_js_1 = __importDefault(require("../script/Spend.js"));
const DefaultBroadcaster_js_1 = require("./broadcasters/DefaultBroadcaster.js");
const DefaultChainTracker_js_1 = require("./chaintrackers/DefaultChainTracker.js");
const Beef_js_1 = require("./Beef.js");
const P2PKH_js_1 = __importDefault(require("../script/templates/P2PKH.js"));
/**
 * Represents a complete Bitcoin transaction. This class encapsulates all the details
 * required for creating, signing, and processing a Bitcoin transaction, including
 * inputs, outputs, and various transaction-related methods.
 *
 * @class Transaction
 * @property {number} version - The version number of the transaction. Used to specify
 *           which set of rules this transaction follows.
 * @property {TransactionInput[]} inputs - An array of TransactionInput objects, representing
 *           the inputs for the transaction. Each input references a previous transaction's output.
 * @property {TransactionOutput[]} outputs - An array of TransactionOutput objects, representing
 *           the outputs for the transaction. Each output specifies the amount of satoshis to be
 *           transferred and the conditions under which they can be spent.
 * @property {number} lockTime - The lock time of the transaction. If non-zero, it specifies the
 *           earliest time or block height at which the transaction can be added to the block chain.
 * @property {Record<string, any>} metadata - A key-value store for attaching additional data to
 *           the transaction object, not included in the transaction itself. Useful for adding descriptions, internal reference numbers, or other information.
 * @property {MerkleProof} [merklePath] - Optional. A merkle proof demonstrating the transaction's
 *           inclusion in a block. Useful for transaction verification using SPV.
 *
 * @example
 * // Creating a new transaction
 * let tx = new Transaction();
 * tx.addInput(...);
 * tx.addOutput(...);
 * await tx.fee();
 * await tx.sign();
 * await tx.broadcast();
 *
 * @description
 * The Transaction class provides comprehensive
 * functionality to handle various aspects of transaction creation, including
 * adding inputs and outputs, computing fees, signing the transaction, and
 * generating its binary or hexadecimal representation.
 */
class Transaction {
    // Recursive function for adding merkle proofs or input transactions
    static addPathOrInputs(obj, transactions, BUMPs) {
        if (typeof obj.pathIndex === 'number') {
            const path = BUMPs[obj.pathIndex];
            if (typeof path !== 'object') {
                throw new Error('Invalid merkle path index found in BEEF!');
            }
            obj.tx.merklePath = path;
        }
        else {
            for (const input of obj.tx.inputs) {
                if (input.sourceTXID === undefined) {
                    throw new Error('Input sourceTXID is undefined');
                }
                const sourceObj = transactions[input.sourceTXID];
                if (typeof sourceObj !== 'object') {
                    throw new Error(`Reference to unknown TXID in BEEF: ${input.sourceTXID ?? 'undefined'}`);
                }
                input.sourceTransaction = sourceObj.tx;
                this.addPathOrInputs(sourceObj, transactions, BUMPs);
            }
        }
    }
    /**
     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF V1, V2 or Atomic.
     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.
     * If the TXID is provided but not found in the BEEF data, an error will be thrown.
     * If no TXID is provided, the last transaction in the BEEF data is returned, or the atomic txid.
     * @param beef A binary representation of transactions in BEEF format.
     * @param txid Optional TXID of the transaction to retrieve from the BEEF data.
     * @returns An anchored transaction, linked to its associated inputs populated with merkle paths.
     */
    static fromBEEF(beef, txid) {
        const { tx } = Transaction.fromAnyBeef(beef, txid);
        return tx;
    }
    /**
     * Creates a new transaction from an Atomic BEEF (BRC-95) structure.
     * Extracts the subject transaction and supporting merkle path and source transactions contained in the BEEF data
     *
     * @param beef A binary representation of an Atomic BEEF structure.
     * @returns The subject transaction, linked to its associated inputs populated with merkle paths.
     */
    static fromAtomicBEEF(beef) {
        const { tx, txid, beef: b } = Transaction.fromAnyBeef(beef);
        if (txid !== b.atomicTxid) {
            if (b.atomicTxid != null) {
                throw new Error(`Transaction with TXID ${b.atomicTxid} not found in BEEF data.`);
            }
            else {
                throw new Error('beef must conform to BRC-95 and must contain the subject txid.');
            }
        }
        return tx;
    }
    static fromAnyBeef(beef, txid) {
        const b = Beef_js_1.Beef.fromBinary(beef);
        if (b.txs.length < 1) {
            throw new Error('beef must include at least one transaction.');
        }
        const target = txid ?? b.atomicTxid ?? b.txs.slice(-1)[0].txid;
        const tx = b.findAtomicTransaction(target);
        if (tx == null) {
            if (txid != null) {
                throw new Error(`Transaction with TXID ${target} not found in BEEF data.`);
            }
            else {
                throw new Error('beef does not contain transaction for atomic txid.');
            }
        }
        return { tx, beef: b, txid: target };
    }
    /**
     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.
     * @param ef A binary representation of a transaction in EF format.
     * @returns An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.
     */
    static fromEF(ef) {
        const br = new utils_js_1.Reader(ef);
        const version = br.readUInt32LE();
        if ((0, utils_js_1.toHex)(br.read(6)) !== '0000000000ef') {
            throw new Error('Invalid EF marker');
        }
        const inputsLength = br.readVarIntNum();
        const inputs = [];
        for (let i = 0; i < inputsLength; i++) {
            const sourceTXID = (0, utils_js_1.toHex)(br.readReverse(32));
            const sourceOutputIndex = br.readUInt32LE();
            const scriptLength = br.readVarIntNum();
            const scriptBin = br.read(scriptLength);
            const unlockingScript = UnlockingScript_js_1.default.fromBinary(scriptBin);
            const sequence = br.readUInt32LE();
            const satoshis = br.readUInt64LEBn().toNumber();
            const lockingScriptLength = br.readVarIntNum();
            const lockingScriptBin = br.read(lockingScriptLength);
            const lockingScript = LockingScript_js_1.default.fromBinary(lockingScriptBin);
            const sourceTransaction = new Transaction(undefined, [], [], undefined);
            sourceTransaction.outputs = Array(sourceOutputIndex + 1).fill(null);
            sourceTransaction.outputs[sourceOutputIndex] = {
                satoshis,
                lockingScript
            };
            inputs.push({
                sourceTransaction,
                sourceTXID,
                sourceOutputIndex,
                unlockingScript,
                sequence
            });
        }
        const outputsLength = br.readVarIntNum();
        const outputs = [];
        for (let i = 0; i < outputsLength; i++) {
            const satoshis = br.readUInt64LEBn().toNumber();
            const scriptLength = br.readVarIntNum();
            const scriptBin = br.read(scriptLength);
            const lockingScript = LockingScript_js_1.default.fromBinary(scriptBin);
            outputs.push({
                satoshis,
                lockingScript
            });
        }
        const lockTime = br.readUInt32LE();
        return new Transaction(version, inputs, outputs, lockTime);
    }
    /**
     * Since the validation of blockchain data is atomically transaction data validation,
     * any application seeking to validate data in output scripts must store the entire transaction as well.
     * Since the transaction data includes the output script data, saving a second copy of potentially
     * large scripts can bloat application storage requirements.
     *
     * This function efficiently parses binary transaction data to determine the offsets and lengths of each script.
     * This supports the efficient retreival of script data from transaction data.
     *
     * @param bin binary transaction data
     * @returns {
     *   inputs: { vin: number, offset: number, length: number }[]
     *   outputs: { vout: number, offset: number, length: number }[]
     * }
     */
    static parseScriptOffsets(bin) {
        const br = new utils_js_1.Reader(bin);
        const inputs = [];
        const outputs = [];
        br.pos += 4; // version
        const inputsLength = br.readVarIntNum();
        for (let i = 0; i < inputsLength; i++) {
            br.pos += 36; // txid and vout
            const scriptLength = br.readVarIntNum();
            inputs.push({ vin: i, offset: br.pos, length: scriptLength });
            br.pos += scriptLength + 4; // script and sequence
        }
        const outputsLength = br.readVarIntNum();
        for (let i = 0; i < outputsLength; i++) {
            br.pos += 8; // satoshis
            const scriptLength = br.readVarIntNum();
            outputs.push({ vout: i, offset: br.pos, length: scriptLength });
            br.pos += scriptLength;
        }
        return { inputs, outputs };
    }
    static fromReader(br) {
        const version = br.readUInt32LE();
        const inputsLength = br.readVarIntNum();
        const inputs = [];
        for (let i = 0; i < inputsLength; i++) {
            const sourceTXID = (0, utils_js_1.toHex)(br.readReverse(32));
            const sourceOutputIndex = br.readUInt32LE();
            const scriptLength = br.readVarIntNum();
            const scriptBin = br.read(scriptLength);
            const unlockingScript = UnlockingScript_js_1.default.fromBinary(scriptBin);
            const sequence = br.readUInt32LE();
            inputs.push({
                sourceTXID,
                sourceOutputIndex,
                unlockingScript,
                sequence
            });
        }
        const outputsLength = br.readVarIntNum();
        const outputs = [];
        for (let i = 0; i < outputsLength; i++) {
            const satoshis = br.readUInt64LEBn().toNumber();
            const scriptLength = br.readVarIntNum();
            const scriptBin = br.read(scriptLength);
            const lockingScript = LockingScript_js_1.default.fromBinary(scriptBin);
            outputs.push({
                satoshis,
                lockingScript
            });
        }
        const lockTime = br.readUInt32LE();
        return new Transaction(version, inputs, outputs, lockTime);
    }
    /**
     * Creates a Transaction instance from a binary array.
     *
     * @static
     * @param {number[]} bin - The binary array representation of the transaction.
     * @returns {Transaction} - A new Transaction instance.
     */
    static fromBinary(bin) {
        const br = new utils_js_1.Reader(bin);
        return Transaction.fromReader(br);
    }
    /**
     * Creates a Transaction instance from a hexadecimal string.
     *
     * @static
     * @param {string} hex - The hexadecimal string representation of the transaction.
     * @returns {Transaction} - A new Transaction instance.
     */
    static fromHex(hex) {
        return Transaction.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));
    }
    /**
     * Creates a Transaction instance from a hexadecimal string encoded EF.
     *
     * @static
     * @param {string} hex - The hexadecimal string representation of the transaction EF.
     * @returns {Transaction} - A new Transaction instance.
     */
    static fromHexEF(hex) {
        return Transaction.fromEF((0, utils_js_1.toArray)(hex, 'hex'));
    }
    /**
     * Creates a Transaction instance from a hexadecimal string encoded BEEF.
     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.
     * If the TXID is provided but not found in the BEEF data, an error will be thrown.
     * If no TXID is provided, the last transaction in the BEEF data is returned.
     *
     * @static
     * @param {string} hex - The hexadecimal string representation of the transaction BEEF.
     * @param {string} [txid] - Optional TXID of the transaction to retrieve from the BEEF data.
     * @returns {Transaction} - A new Transaction instance.
     */
    static fromHexBEEF(hex, txid) {
        return Transaction.fromBEEF((0, utils_js_1.toArray)(hex, 'hex'), txid);
    }
    constructor(version = 1, inputs = [], outputs = [], lockTime = 0, metadata = new Map(), merklePath) {
        this.version = version;
        this.inputs = inputs;
        this.outputs = outputs;
        this.lockTime = lockTime;
        this.metadata = metadata;
        this.merklePath = merklePath;
    }
    /**
     * Adds a new input to the transaction.
     *
     * @param {TransactionInput} input - The TransactionInput object to add to the transaction.
     * @throws {Error} - If the input does not have a sourceTXID or sourceTransaction defined.
     */
    addInput(input) {
        if (typeof input.sourceTXID === 'undefined' &&
            typeof input.sourceTransaction === 'undefined') {
            throw new Error('A reference to an an input transaction is required. If the input transaction itself cannot be referenced, its TXID must still be provided.');
        }
        // If the input sequence number hasn't been set, the expectation is that it is final.
        if (typeof input.sequence === 'undefined') {
            input.sequence = 0xffffffff;
        }
        this.cachedHash = undefined;
        this.inputs.push(input);
    }
    /**
     * Adds a new output to the transaction.
     *
     * @param {TransactionOutput} output - The TransactionOutput object to add to the transaction.
     */
    addOutput(output) {
        this.cachedHash = undefined;
        if (output.change !== true) {
            if (typeof output.satoshis === 'undefined') {
                throw new Error('either satoshis must be defined or change must be set to true');
            }
            if (output.satoshis < 0) {
                throw new Error('satoshis must be a positive integer or zero');
            }
        }
        if (output.lockingScript == null)
            throw new Error('lockingScript must be defined');
        this.outputs.push(output);
    }
    /**
     * Adds a new P2PKH output to the transaction.
     *
     * @param {number[] | string} address - The P2PKH address of the output.
     * @param {number} [satoshis] - The number of satoshis to send to the address - if not provided, the output is considered a change output.
     *
     */
    addP2PKHOutput(address, satoshis) {
        const lockingScript = new P2PKH_js_1.default().lock(address);
        if (typeof satoshis === 'undefined') {
            return this.addOutput({ lockingScript, change: true });
        }
        this.addOutput({
            lockingScript,
            satoshis
        });
    }
    /**
     * Updates the transaction's metadata.
     *
     * @param {Record<string, any>} metadata - The metadata object to merge into the existing metadata.
     */
    updateMetadata(metadata) {
        this.metadata = {
            ...this.metadata,
            ...metadata
        };
    }
    /**
     * Computes fees prior to signing.
     * If no fee model is provided, uses a SatoshisPerKilobyte fee model that pays 1 sat/kb.
     * If fee is a number, the transaction uses that value as fee.
     *
     * @param modelOrFee - The initialized fee model to use or fixed fee for the transaction
     * @param changeDistribution - Specifies how the change should be distributed
     * amongst the change outputs
     *
     */
    async fee(modelOrFee = new SatoshisPerKilobyte_js_1.default(1), changeDistribution = 'equal') {
        this.cachedHash = undefined;
        if (typeof modelOrFee === 'number') {
            const sats = modelOrFee;
            modelOrFee = {
                computeFee: async () => sats
            };
        }
        const fee = await modelOrFee.computeFee(this);
        const change = this.calculateChange(fee);
        if (change <= 0) {
            this.outputs = this.outputs.filter((output) => output.change !== true);
            return;
        }
        this.distributeChange(change, changeDistribution);
    }
    calculateChange(fee) {
        let change = 0;
        for (const input of this.inputs) {
            if (typeof input.sourceTransaction !== 'object') {
                throw new Error('Source transactions are required for all inputs during fee computation');
            }
            change +=
                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;
        }
        change -= fee;
        for (const out of this.outputs) {
            if (out.change !== true) {
                if (out.satoshis !== undefined) {
                    change -= out.satoshis;
                }
            }
        }
        return change;
    }
    distributeChange(change, changeDistribution) {
        let distributedChange = 0;
        const changeOutputs = this.outputs.filter((out) => out.change);
        if (changeDistribution === 'random') {
            distributedChange = this.distributeRandomChange(change, changeOutputs);
        }
        else if (changeDistribution === 'equal') {
            distributedChange = this.distributeEqualChange(change, changeOutputs);
        }
        if (distributedChange < change) {
            const lastOutput = this.outputs[this.outputs.length - 1];
            if (lastOutput.satoshis !== undefined) {
                lastOutput.satoshis += change - distributedChange;
            }
            else {
                lastOutput.satoshis = change - distributedChange;
            }
        }
    }
    distributeRandomChange(change, changeOutputs) {
        let distributedChange = 0;
        let changeToUse = change;
        const benfordNumbers = Array(changeOutputs.length).fill(1);
        changeToUse -= changeOutputs.length;
        distributedChange += changeOutputs.length;
        for (let i = 0; i < changeOutputs.length - 1; i++) {
            const portion = this.benfordNumber(0, changeToUse);
            benfordNumbers[i] = benfordNumbers[i] + portion;
            distributedChange += portion;
            changeToUse -= portion;
        }
        for (const output of this.outputs) {
            if (output.change === true)
                output.satoshis = benfordNumbers.shift();
        }
        return distributedChange;
    }
    distributeEqualChange(change, changeOutputs) {
        let distributedChange = 0;
        const perOutput = Math.floor(change / changeOutputs.length);
        for (const out of changeOutputs) {
            distributedChange += perOutput;
            out.satoshis = perOutput;
        }
        return distributedChange;
    }
    benfordNumber(min, max) {
        const d = Math.floor(Math.random() * 9) + 1;
        return Math.floor(min + ((max - min) * Math.log10(1 + 1 / d)) / Math.log10(10));
    }
    /**
     * Utility method that returns the current fee based on inputs and outputs
     *
     * @returns The current transaction fee
     */
    getFee() {
        let totalIn = 0;
        for (const input of this.inputs) {
            if (typeof input.sourceTransaction !== 'object') {
                throw new Error('Source transactions or sourceSatoshis are required for all inputs to calculate fee');
            }
            totalIn +=
                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;
        }
        let totalOut = 0;
        for (const output of this.outputs) {
            totalOut += output.satoshis ?? 0;
        }
        return totalIn - totalOut;
    }
    /**
     * Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.
     */
    async sign() {
        this.cachedHash = undefined;
        for (const out of this.outputs) {
            if (typeof out.satoshis === 'undefined') {
                if (out.change === true) {
                    throw new Error('There are still change outputs with uncomputed amounts. Use the fee() method to compute the change amounts and transaction fees prior to signing.');
                }
                else {
                    throw new Error('One or more transaction outputs is missing an amount. Ensure all output amounts are provided before signing.');
                }
            }
        }
        const unlockingScripts = await Promise.all(this.inputs.map(async (x, i) => {
            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {
                return await this.inputs[i]?.unlockingScriptTemplate?.sign(this, i);
            }
            else {
                return await Promise.resolve(undefined);
            }
        }));
        for (let i = 0, l = this.inputs.length; i < l; i++) {
            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {
                this.inputs[i].unlockingScript = unlockingScripts[i];
            }
        }
    }
    /**
     * Broadcasts a transaction.
     *
     * @param broadcaster The Broadcaster instance wwhere the transaction will be sent
     * @returns A BroadcastResponse or BroadcastFailure from the Broadcaster
     */
    async broadcast(broadcaster = (0, DefaultBroadcaster_js_1.defaultBroadcaster)()) {
        return await broadcaster.broadcast(this);
    }
    /**
     * Converts the transaction to a binary array format.
     *
     * @returns {number[]} - The binary array representation of the transaction.
     */
    toBinary() {
        const writer = new utils_js_1.Writer();
        writer.writeUInt32LE(this.version);
        writer.writeVarIntNum(this.inputs.length);
        for (const i of this.inputs) {
            if (typeof i.sourceTXID === 'undefined') {
                if (i.sourceTransaction != null) {
                    writer.write(i.sourceTransaction.hash());
                }
                else {
                    throw new Error('sourceTransaction is undefined');
                }
            }
            else {
                writer.writeReverse((0, utils_js_1.toArray)(i.sourceTXID, 'hex'));
            }
            writer.writeUInt32LE(i.sourceOutputIndex);
            if (i.unlockingScript == null) {
                throw new Error('unlockingScript is undefined');
            }
            const scriptBin = i.unlockingScript.toBinary();
            writer.writeVarIntNum(scriptBin.length);
            writer.write(scriptBin);
            writer.writeUInt32LE(i.sequence ?? 0);
        }
        writer.writeVarIntNum(this.outputs.length);
        for (const o of this.outputs) {
            writer.writeUInt64LE(o.satoshis ?? 0);
            const scriptBin = o.lockingScript.toBinary();
            writer.writeVarIntNum(scriptBin.length);
            writer.write(scriptBin);
        }
        writer.writeUInt32LE(this.lockTime);
        return writer.toArray();
    }
    /**
     * Converts the transaction to a BRC-30 EF format.
     *
     * @returns {number[]} - The BRC-30 EF representation of the transaction.
     */
    toEF() {
        const writer = new utils_js_1.Writer();
        writer.writeUInt32LE(this.version);
        writer.write([0, 0, 0, 0, 0, 0xef]);
        writer.writeVarIntNum(this.inputs.length);
        for (const i of this.inputs) {
            if (typeof i.sourceTransaction === 'undefined') {
                throw new Error('All inputs must have source transactions when serializing to EF format');
            }
            if (typeof i.sourceTXID === 'undefined') {
                writer.write(i.sourceTransaction.hash());
            }
            else {
                writer.write((0, utils_js_1.toArray)(i.sourceTXID, 'hex').reverse());
            }
            writer.writeUInt32LE(i.sourceOutputIndex);
            if (i.unlockingScript == null) {
                throw new Error('unlockingScript is undefined');
            }
            const scriptBin = i.unlockingScript.toBinary();
            writer.writeVarIntNum(scriptBin.length);
            writer.write(scriptBin);
            writer.writeUInt32LE(i.sequence ?? 0);
            writer.writeUInt64LE(i.sourceTransaction.outputs[i.sourceOutputIndex].satoshis ?? 0);
            const lockingScriptBin = i.sourceTransaction.outputs[i.sourceOutputIndex].lockingScript.toBinary();
            writer.writeVarIntNum(lockingScriptBin.length);
            writer.write(lockingScriptBin);
        }
        writer.writeVarIntNum(this.outputs.length);
        for (const o of this.outputs) {
            writer.writeUInt64LE(o.satoshis ?? 0);
            const scriptBin = o.lockingScript.toBinary();
            writer.writeVarIntNum(scriptBin.length);
            writer.write(scriptBin);
        }
        writer.writeUInt32LE(this.lockTime);
        return writer.toArray();
    }
    /**
     * Converts the transaction to a hexadecimal string EF.
     *
     * @returns {string} - The hexadecimal string representation of the transaction EF.
     */
    toHexEF() {
        return (0, utils_js_1.toHex)(this.toEF());
    }
    /**
     * Converts the transaction to a hexadecimal string format.
     *
     * @returns {string} - The hexadecimal string representation of the transaction.
     */
    toHex() {
        return (0, utils_js_1.toHex)(this.toBinary());
    }
    /**
     * Converts the transaction to a hexadecimal string BEEF.
     *
     * @returns {string} - The hexadecimal string representation of the transaction BEEF.
     */
    toHexBEEF() {
        return (0, utils_js_1.toHex)(this.toBEEF());
    }
    /**
     * Converts the transaction to a hexadecimal string Atomic BEEF.
     *
     * @returns {string} - The hexadecimal string representation of the transaction Atomic BEEF.
     */
    toHexAtomicBEEF() {
        return (0, utils_js_1.toHex)(this.toAtomicBEEF());
    }
    /**
     * Calculates the transaction's hash.
     *
     * @param {'hex' | undefined} enc - The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.
     * @returns {string | number[]} - The hash of the transaction in the specified format.
     */
    hash(enc) {
        let hash;
        if (this.cachedHash != null) {
            hash = this.cachedHash;
        }
        else {
            hash = (0, Hash_js_1.hash256)(this.toBinary());
            this.cachedHash = hash;
        }
        if (enc === 'hex') {
            return (0, utils_js_1.toHex)(hash);
        }
        return hash;
    }
    /**
     * Calculates the transaction's ID.
     *
     * @param {'hex' | undefined} enc - The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.
     * @returns {string | number[]} - The ID of the transaction in the specified format.
     */
    id(enc) {
        const id = [...this.hash()];
        id.reverse();
        if (enc === 'hex') {
            return (0, utils_js_1.toHex)(id);
        }
        return id;
    }
    /**
     * Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.
     *
     * @param chainTracker - An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.
     * @param feeModel - An instance of FeeModel, a fee model to use for fee calculation. If not provided then the default fee model will be used.
     * @param memoryLimit - The maximum memory in bytes usage allowed for script evaluation. If not provided then the default memory limit will be used.
     *
     * @returns Whether the transaction is valid according to the rules of SPV.
     *
     * @example tx.verify(new WhatsOnChain(), new SatoshisPerKilobyte(1))
     */
    async verify(chainTracker = (0, DefaultChainTracker_js_1.defaultChainTracker)(), feeModel, memoryLimit) {
        const verifiedTxids = new Set();
        const txQueue = [this];
        while (txQueue.length > 0) {
            const tx = txQueue.shift();
            const txid = tx?.id('hex') ?? '';
            if (txid != null && txid !== '' && verifiedTxids.has(txid)) {
                continue;
            }
            // If the transaction has a valid merkle path, verification is complete.
            if (typeof tx?.merklePath === 'object') {
                if (chainTracker === 'scripts only') {
                    if (txid != null) {
                        verifiedTxids.add(txid);
                    }
                    continue;
                }
                else {
                    const proofValid = await tx.merklePath.verify(txid, chainTracker);
                    // If the proof is valid, no need to verify inputs.
                    if (proofValid) {
                        verifiedTxids.add(txid);
                        continue;
                    }
                    else {
                        throw new Error(`Invalid merkle path for transaction ${txid}`);
                    }
                }
            }
            // Verify fee if feeModel is provided
            if (typeof feeModel !== 'undefined') {
                if (tx === undefined) {
                    throw new Error('Transaction is undefined');
                }
                const cpTx = Transaction.fromEF(tx.toEF());
                delete cpTx.outputs[0].satoshis;
                cpTx.outputs[0].change = true;
                await cpTx.fee(feeModel);
                if (tx.getFee() < cpTx.getFee()) {
                    throw new Error(`Verification failed because the transaction ${txid} has an insufficient fee and has not been mined.`);
                }
            }
            // Verify each input transaction and evaluate the spend events.
            // Also, keep a total of the input amounts for later.
            let inputTotal = 0;
            if (tx === undefined) {
                throw new Error('Transaction is undefined');
            }
            for (let i = 0; i < tx.inputs.length; i++) {
                const input = tx.inputs[i];
                if (typeof input.sourceTransaction !== 'object') {
                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated source transaction. This source transaction is required for transaction verification because there is no merkle proof for the transaction spending a UTXO it contains.`);
                }
                if (typeof input.unlockingScript !== 'object') {
                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated unlocking script. This script is required for transaction verification because there is no merkle proof for the transaction spending the UTXO.`);
                }
                const sourceOutput = input.sourceTransaction.outputs[input.sourceOutputIndex];
                inputTotal += sourceOutput.satoshis ?? 0;
                const sourceTxid = input.sourceTransaction.id('hex');
                if (!verifiedTxids.has(sourceTxid)) {
                    txQueue.push(input.sourceTransaction);
                }
                const otherInputs = tx.inputs.filter((_, idx) => idx !== i);
                if (typeof input.sourceTXID === 'undefined') {
                    input.sourceTXID = sourceTxid;
                }
                const spend = new Spend_js_1.default({
                    sourceTXID: input.sourceTXID,
                    sourceOutputIndex: input.sourceOutputIndex,
                    lockingScript: sourceOutput.lockingScript,
                    sourceSatoshis: sourceOutput.satoshis ?? 0,
                    transactionVersion: tx.version,
                    otherInputs,
                    unlockingScript: input.unlockingScript,
                    inputSequence: input.sequence ?? 0,
                    inputIndex: i,
                    outputs: tx.outputs,
                    lockTime: tx.lockTime,
                    memoryLimit
                });
                const spendValid = spend.validate();
                if (!spendValid) {
                    return false;
                }
            }
            // Total the outputs to ensure they don't amount to more than the inputs
            let outputTotal = 0;
            for (const out of tx.outputs) {
                if (typeof out.satoshis !== 'number') {
                    throw new Error('Every output must have a defined amount during transaction verification.');
                }
                outputTotal += out.satoshis;
            }
            if (outputTotal > inputTotal) {
                return false;
            }
            verifiedTxids.add(txid);
        }
        return true;
    }
    /**
     * Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.
     *
     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.
     *
     * @returns The serialized BEEF structure
     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.
     */
    toBEEF(allowPartial) {
        const writer = new utils_js_1.Writer();
        writer.writeUInt32LE(Beef_js_1.BEEF_V1);
        const BUMPs = [];
        const txs = [];
        // Recursive function to add paths and input transactions for a TX
        const addPathsAndInputs = (tx) => {
            const obj = { tx };
            const hasProof = typeof tx.merklePath === 'object';
            if (hasProof) {
                let added = false;
                // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.
                for (let i = 0; i < BUMPs.length; i++) {
                    if (BUMPs[i] === tx.merklePath) {
                        // Literally the same
                        obj.pathIndex = i;
                        added = true;
                        break;
                    }
                    if (tx.merklePath !== null && tx.merklePath !== undefined && BUMPs[i].blockHeight === tx.merklePath.blockHeight) {
                        // Probably the same...
                        const rootA = BUMPs[i].computeRoot();
                        const rootB = tx.merklePath.computeRoot();
                        if (rootA === rootB) {
                            // Definitely the same... combine them to save space
                            BUMPs[i].combine(tx.merklePath);
                            obj.pathIndex = i;
                            added = true;
                            break;
                        }
                    }
                }
                // Finally, if the proof is not yet added, add a new path.
                if (!added) {
                    obj.pathIndex = BUMPs.length;
                    if (tx.merklePath !== null && tx.merklePath !== undefined) {
                        BUMPs.push(tx.merklePath);
                    }
                }
            }
            const duplicate = txs.some((x) => x.tx.id('hex') === tx.id('hex'));
            if (!duplicate) {
                txs.unshift(obj);
            }
            if (!hasProof) {
                for (let i = 0; i < tx.inputs.length; i++) {
                    const input = tx.inputs[i];
                    if (typeof input.sourceTransaction === 'object') {
                        addPathsAndInputs(input.sourceTransaction);
                    }
                    else if (allowPartial === false) {
                        throw new Error('A required source transaction is missing!');
                    }
                }
            }
        };
        addPathsAndInputs(this);
        writer.writeVarIntNum(BUMPs.length);
        for (const b of BUMPs) {
            writer.write(b.toBinary());
        }
        writer.writeVarIntNum(txs.length);
        for (const t of txs) {
            writer.write(t.tx.toBinary());
            if (typeof t.pathIndex === 'number') {
                writer.writeUInt8(1);
                writer.writeVarIntNum(t.pathIndex);
            }
            else {
                writer.writeUInt8(0);
            }
        }
        return writer.toArray();
    }
    /**
     * Serializes this transaction and its inputs into the Atomic BEEF (BRC-95) format.
     * The Atomic BEEF format starts with a 4-byte prefix `0x01010101`, followed by the TXID of the subject transaction,
     * and then the BEEF data containing only the subject transaction and its dependencies.
     * This format ensures that the BEEF structure is atomic and contains no unrelated transactions.
     *
     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.
     *
     * @returns {number[]} - The serialized Atomic BEEF structure.
     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.
     */
    toAtomicBEEF(allowPartial) {
        const writer = new utils_js_1.Writer();
        // Write the Atomic BEEF prefix
        writer.writeUInt32LE(0x01010101);
        // Write the subject TXID (big-endian)
        writer.write(this.hash());
        // Append the BEEF data
        const beefData = this.toBEEF(allowPartial);
        writer.write(beefData);
        return writer.toArray();
    }
}
exports.default = Transaction;

},{"../primitives/Hash.js":46,"../primitives/utils.js":62,"../script/LockingScript.js":66,"../script/Spend.js":70,"../script/UnlockingScript.js":71,"../script/templates/P2PKH.js":73,"./Beef.js":83,"./broadcasters/DefaultBroadcaster.js":90,"./chaintrackers/DefaultChainTracker.js":95,"./fee-models/SatoshisPerKilobyte.js":98}],89:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultHttpClient_js_1 = require("../http/DefaultHttpClient.js");
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
const utils_js_1 = require("../../primitives/utils.js");
function defaultDeploymentId() {
    return `ts-sdk-${(0, utils_js_1.toHex)((0, Random_js_1.default)(16))}`;
}
/**
 * Represents an ARC transaction broadcaster.
 */
class ARC {
    constructor(URL, config) {
        this.URL = URL;
        if (typeof config === 'string') {
            this.apiKey = config;
            this.httpClient = (0, DefaultHttpClient_js_1.defaultHttpClient)();
            this.deploymentId = defaultDeploymentId();
            this.callbackToken = undefined;
            this.callbackUrl = undefined;
        }
        else {
            const configObj = config ?? {};
            const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = configObj;
            this.apiKey = apiKey;
            this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();
            this.deploymentId = deploymentId ?? defaultDeploymentId();
            this.callbackToken = callbackToken;
            this.callbackUrl = callbackUrl;
            this.headers = headers;
        }
    }
    /**
     * Constructs a dictionary of the default & supplied request headers.
     */
    requestHeaders() {
        const headers = {
            'Content-Type': 'application/json',
            'XDeployment-ID': this.deploymentId
        };
        if (this.apiKey != null && this.apiKey !== '') {
            headers.Authorization = `Bearer ${this.apiKey}`;
        }
        if (this.callbackUrl != null && this.callbackUrl !== '') {
            headers['X-CallbackUrl'] = this.callbackUrl;
        }
        if (this.callbackToken != null && this.callbackToken !== '') {
            headers['X-CallbackToken'] = this.callbackToken;
        }
        if (this.headers != null) {
            for (const key in this.headers) {
                headers[key] = this.headers[key];
            }
        }
        return headers;
    }
    /**
     * Broadcasts a transaction via ARC.
     *
     * @param {Transaction} tx - The transaction to be broadcasted.
     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
     */
    async broadcast(tx) {
        let rawTx;
        try {
            rawTx = tx.toHexEF();
        }
        catch (error) {
            if (error.message ===
                'All inputs must have source transactions when serializing to EF format') {
                rawTx = tx.toHex();
            }
            else {
                throw error;
            }
        }
        const requestOptions = {
            method: 'POST',
            headers: this.requestHeaders(),
            data: { rawTx }
        };
        try {
            const response = await this.httpClient.request(`${this.URL}/v1/tx`, requestOptions);
            if (response.ok) {
                const { txid, extraInfo, txStatus, competingTxs } = response.data;
                const broadcastRes = {
                    status: 'success',
                    txid,
                    message: `${txStatus} ${extraInfo}`
                };
                if (competingTxs != null) {
                    broadcastRes.competingTxs = competingTxs;
                }
                return broadcastRes;
            }
            else {
                const st = typeof response.status;
                const r = {
                    status: 'error',
                    code: st === 'number' || st === 'string'
                        ? response.status.toString()
                        : 'ERR_UNKNOWN',
                    description: 'Unknown error'
                };
                let d = response.data;
                if (typeof d === 'string') {
                    try {
                        d = JSON.parse(response.data);
                    }
                    catch {
                        // Intentionally left empty
                    }
                }
                if (typeof d === 'object') {
                    if (d !== null) {
                        r.more = d;
                    }
                    if ((d != null) && typeof d.txid === 'string') {
                        r.txid = d.txid;
                    }
                    if ((d != null) && 'detail' in d && typeof d.detail === 'string') {
                        r.description = d.detail;
                    }
                }
                return r;
            }
        }
        catch (error) {
            return {
                status: 'error',
                code: '500',
                description: typeof error.message === 'string'
                    ? error.message
                    : 'Internal Server Error'
            };
        }
    }
    /**
     * Broadcasts multiple transactions via ARC.
     * Handles mixed responses where some transactions succeed and others fail.
     *
     * @param {Transaction[]} txs - Array of transactions to be broadcasted.
     * @returns {Promise<Array<object>>} A promise that resolves to an array of objects.
     */
    async broadcastMany(txs) {
        const rawTxs = txs.map((tx) => {
            try {
                return { rawTx: tx.toHexEF() };
            }
            catch (error) {
                if (error.message ===
                    'All inputs must have source transactions when serializing to EF format') {
                    return { rawTx: tx.toHex() };
                }
                throw error;
            }
        });
        const requestOptions = {
            method: 'POST',
            headers: this.requestHeaders(),
            data: rawTxs
        };
        try {
            const response = await this.httpClient.request(`${this.URL}/v1/txs`, requestOptions);
            return response.data;
        }
        catch (error) {
            const errorResponse = {
                status: 'error',
                code: '500',
                description: typeof error.message === 'string' ? error.message : 'Internal Server Error'
            };
            return txs.map(() => errorResponse);
        }
    }
}
exports.default = ARC;

},{"../../primitives/Random.js":55,"../../primitives/utils.js":62,"../http/DefaultHttpClient.js":101}],90:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBroadcaster = void 0;
const ARC_js_1 = __importDefault(require("./ARC.js"));
function defaultBroadcaster(isTestnet = false, config = {}) {
    return new ARC_js_1.default(isTestnet ? 'https://testnet.arc.gorillapool.io' : 'https://arc.gorillapool.io', config);
}
exports.defaultBroadcaster = defaultBroadcaster;

},{"./ARC.js":89}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("../http/index.js");
/**
 * Represents an Teranode transaction broadcaster.
 */
class Teranode {
    /**
     * Constructs an instance of the Teranode broadcaster.
     *
     * @param {string} URL - The URL endpoint for the Teranode API.
     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API, binaryHttpClient by default.
     */
    constructor(URL, httpClient = (0, index_js_1.binaryHttpClient)()) {
        this.URL = URL;
        this.httpClient = httpClient;
    }
    /**
     * Broadcasts a transaction via Teranode.
     *
     * @param {Transaction} tx - The transaction to be broadcasted.
     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
     */
    async broadcast(tx) {
        const rawTx = tx.toEF();
        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream'
            },
            data: new Blob([new Uint8Array(rawTx)])
        };
        try {
            const response = await this.httpClient.request(this.URL, requestOptions);
            if (response.ok) {
                const txid = tx.id('hex');
                return {
                    status: 'success',
                    txid,
                    message: 'broadcast successful'
                };
            }
            else {
                return {
                    status: 'error',
                    code: response.status.toString() ?? 'ERR_UNKNOWN',
                    description: response.data ?? 'Unknown error'
                };
            }
        }
        catch (error) {
            return {
                status: 'error',
                code: '500',
                description: typeof error.message === 'string'
                    ? error.message
                    : 'Internal Server Error'
            };
        }
    }
}
exports.default = Teranode;

},{"../http/index.js":104}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultHttpClient_js_1 = require("../http/DefaultHttpClient.js");
/**
 * Represents an WhatsOnChain transaction broadcaster.
 */
class WhatsOnChainBroadcaster {
    /**
     * Constructs an instance of the WhatsOnChain broadcaster.
     *
     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.
     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API.
     */
    constructor(network = 'main', httpClient = (0, DefaultHttpClient_js_1.defaultHttpClient)()) {
        this.network = network;
        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}/tx/raw`;
        this.httpClient = httpClient;
    }
    /**
     * Broadcasts a transaction via WhatsOnChain.
     *
     * @param {Transaction} tx - The transaction to be broadcasted.
     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.
     */
    async broadcast(tx) {
        const rawTx = tx.toHex();
        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Accept: 'text/plain'
            },
            data: { txhex: rawTx }
        };
        try {
            const response = await this.httpClient.request(this.URL, requestOptions);
            if (response.ok) {
                const txid = response.data;
                return {
                    status: 'success',
                    txid,
                    message: 'broadcast successful'
                };
            }
            else {
                return {
                    status: 'error',
                    code: response.status.toString() ?? 'ERR_UNKNOWN',
                    description: response.data ?? 'Unknown error'
                };
            }
        }
        catch (error) {
            return {
                status: 'error',
                code: '500',
                description: typeof error.message === 'string'
                    ? error.message
                    : 'Internal Server Error'
            };
        }
    }
}
exports.default = WhatsOnChainBroadcaster;

},{"../http/DefaultHttpClient.js":101}],93:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBroadcaster = exports.Teranode = exports.WhatsOnChainBroadcaster = exports.ARC = void 0;
var ARC_js_1 = require("./ARC.js");
Object.defineProperty(exports, "ARC", { enumerable: true, get: function () { return __importDefault(ARC_js_1).default; } });
var WhatsOnChainBroadcaster_js_1 = require("./WhatsOnChainBroadcaster.js");
Object.defineProperty(exports, "WhatsOnChainBroadcaster", { enumerable: true, get: function () { return __importDefault(WhatsOnChainBroadcaster_js_1).default; } });
var Teranode_js_1 = require("./Teranode.js");
Object.defineProperty(exports, "Teranode", { enumerable: true, get: function () { return __importDefault(Teranode_js_1).default; } });
var DefaultBroadcaster_js_1 = require("./DefaultBroadcaster.js");
Object.defineProperty(exports, "defaultBroadcaster", { enumerable: true, get: function () { return DefaultBroadcaster_js_1.defaultBroadcaster; } });

},{"./ARC.js":89,"./DefaultBroadcaster.js":90,"./Teranode.js":91,"./WhatsOnChainBroadcaster.js":92}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockHeadersService = void 0;
const DefaultHttpClient_js_1 = require("../http/DefaultHttpClient.js");
/**
 * Represents a chain tracker based on a BlockHeadersService API.
 *
 * @example
 * ```typescript
 * const chainTracker = new BlockHeadersService('https://headers.spv.money', {
 *   apiKey: '17JxRHcJerGBEbusx56W8o1m8Js73TFGo'
 * })
 * ```
 */
class BlockHeadersService {
    /**
     * Constructs an instance of the BlockHeadersService ChainTracker.
     *
     * @param {string} baseUrl - The base URL for the BlockHeadersService API (e.g. https://headers.spv.money)
     * @param {BlockHeadersServiceConfig} config - Configuration options for the BlockHeadersService ChainTracker.
     */
    constructor(baseUrl, config = {}) {
        const { httpClient, apiKey } = config;
        this.baseUrl = baseUrl;
        this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();
        this.apiKey = apiKey ?? '';
    }
    /**
     * Verifies if a given merkle root is valid for a specific block height.
     *
     * @param {string} root - The merkle root to verify.
     * @param {number} height - The block height to check against.
     * @returns {Promise<boolean>} - A promise that resolves to true if the merkle root is valid for the specified block height, false otherwise.
     */
    async isValidRootForHeight(root, height) {
        const requestOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            },
            data: [
                {
                    blockHeight: height,
                    merkleRoot: root
                }
            ]
        };
        try {
            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/merkleroot/verify`, requestOptions);
            if (response.ok) {
                return response.data.confirmationState === 'CONFIRMED';
            }
            else {
                throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)}`);
            }
        }
        catch (error) {
            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Gets the current block height from the BlockHeadersService API.
     *
     * @returns {Promise<number>} - A promise that resolves to the current block height.
     */
    async currentHeight() {
        const requestOptions = {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            }
        };
        try {
            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/tip/longest`, requestOptions);
            if (response.ok && response.data && typeof response.data.height === 'number') {
                return response.data.height;
            }
            else {
                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)}`);
            }
        }
        catch (error) {
            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
exports.BlockHeadersService = BlockHeadersService;

},{"../http/DefaultHttpClient.js":101}],95:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultChainTracker = void 0;
const WhatsOnChain_js_1 = __importDefault(require("./WhatsOnChain.js"));
function defaultChainTracker() {
    return new WhatsOnChain_js_1.default();
}
exports.defaultChainTracker = defaultChainTracker;

},{"./WhatsOnChain.js":96}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultHttpClient_js_1 = require("../http/DefaultHttpClient.js");
/**
 * Represents a chain tracker based on What's On Chain .
 */
class WhatsOnChain {
    /**
     * Constructs an instance of the WhatsOnChain ChainTracker.
     *
     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.
     * @param {WhatsOnChainConfig} config - Configuration options for the WhatsOnChain ChainTracker.
     */
    constructor(network = 'main', config = {}) {
        const { apiKey, httpClient } = config;
        this.network = network;
        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}`;
        this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();
        this.apiKey = apiKey ?? '';
    }
    async isValidRootForHeight(root, height) {
        const requestOptions = {
            method: 'GET',
            headers: this.getHttpHeaders()
        };
        const response = await this.httpClient.request(`${this.URL}/block/${height}/header`, requestOptions);
        if (response.ok) {
            const { merkleroot } = response.data;
            return merkleroot === root;
        }
        else if (response.status === 404) {
            return false;
        }
        else {
            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)} `);
        }
    }
    async currentHeight() {
        try {
            const requestOptions = {
                method: 'GET',
                headers: this.getHttpHeaders()
            };
            const response = await this.httpClient.request(`${this.URL}/block/headers`, requestOptions);
            if (response.ok) {
                return response.data[0].height;
            }
            else {
                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)} `);
            }
        }
        catch (error) {
            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    getHttpHeaders() {
        const headers = {
            Accept: 'application/json'
        };
        if (typeof this.apiKey === 'string' && this.apiKey.trim() !== '') {
            headers.Authorization = this.apiKey;
        }
        return headers;
    }
}
exports.default = WhatsOnChain;

},{"../http/DefaultHttpClient.js":101}],97:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultChainTracker = exports.BlockHeadersService = exports.WhatsOnChain = void 0;
var WhatsOnChain_js_1 = require("./WhatsOnChain.js");
Object.defineProperty(exports, "WhatsOnChain", { enumerable: true, get: function () { return __importDefault(WhatsOnChain_js_1).default; } });
var BlockHeadersService_js_1 = require("./BlockHeadersService.js");
Object.defineProperty(exports, "BlockHeadersService", { enumerable: true, get: function () { return BlockHeadersService_js_1.BlockHeadersService; } });
var DefaultChainTracker_js_1 = require("./DefaultChainTracker.js");
Object.defineProperty(exports, "defaultChainTracker", { enumerable: true, get: function () { return DefaultChainTracker_js_1.defaultChainTracker; } });

},{"./BlockHeadersService.js":94,"./DefaultChainTracker.js":95,"./WhatsOnChain.js":96}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the "satoshis per kilobyte" transaction fee model.
 */
class SatoshisPerKilobyte {
    /**
     * Constructs an instance of the sat/kb fee model.
     *
     * @param {number} value - The number of satoshis per kilobyte to charge as a fee.
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * Computes the fee for a given transaction.
     *
     * @param tx The transaction for which a fee is to be computed.
     * @returns The fee in satoshis for the transaction, as a BigNumber.
     */
    async computeFee(tx) {
        const getVarIntSize = (i) => {
            if (i > 2 ** 32) {
                return 9;
            }
            else if (i > 2 ** 16) {
                return 5;
            }
            else if (i > 253) {
                return 3;
            }
            else {
                return 1;
            }
        };
        // Compute the (potentially estimated) size of the transaction
        let size = 4; // version
        size += getVarIntSize(tx.inputs.length); // number of inputs
        for (let i = 0; i < tx.inputs.length; i++) {
            const input = tx.inputs[i];
            size += 40; // txid, output index, sequence number
            let scriptLength;
            if (typeof input.unlockingScript === 'object') {
                scriptLength = input.unlockingScript.toBinary().length;
            }
            else if (typeof input.unlockingScriptTemplate === 'object') {
                scriptLength = await input.unlockingScriptTemplate.estimateLength(tx, i);
            }
            else {
                throw new Error('All inputs must have an unlocking script or an unlocking script template for sat/kb fee computation.');
            }
            size += getVarIntSize(scriptLength); // unlocking script length
            size += scriptLength; // unlocking script
        }
        size += getVarIntSize(tx.outputs.length); // number of outputs
        for (const out of tx.outputs) {
            size += 8; // satoshis
            const length = out.lockingScript.toBinary().length;
            size += getVarIntSize(length); // script length
            size += length; // script
        }
        size += 4; // lock time
        // We'll use Math.ceil to ensure the miners get the extra satoshi.
        const fee = Math.ceil((size / 1000) * this.value);
        return fee;
    }
}
exports.default = SatoshisPerKilobyte;

},{}],99:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SatoshisPerKilobyte = void 0;
var SatoshisPerKilobyte_js_1 = require("./SatoshisPerKilobyte.js");
Object.defineProperty(exports, "SatoshisPerKilobyte", { enumerable: true, get: function () { return __importDefault(SatoshisPerKilobyte_js_1).default; } });

},{"./SatoshisPerKilobyte.js":98}],100:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binaryHttpClient = exports.BinaryFetchClient = exports.BinaryNodejsHttpClient = void 0;
/**
 * Adapter for Node Https module to be used as HttpClient
 */
class BinaryNodejsHttpClient {
    constructor(https) {
        this.https = https;
    }
    async request(url, requestOptions) {
        return await new Promise((resolve, reject) => {
            const req = this.https.request(url, requestOptions, (res) => {
                let body = '';
                res.on('data', (chunk) => {
                    body += chunk;
                });
                res.on('end', () => {
                    const ok = res.statusCode >= 200 && res.statusCode <= 299;
                    const mediaType = res.headers['content-type'];
                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')
                        ? JSON.parse(body)
                        : body;
                    resolve({
                        status: res.statusCode,
                        statusText: res.statusMessage,
                        ok,
                        data
                    });
                });
            });
            req.on('error', (error) => {
                reject(error);
            });
            if (requestOptions.data !== null && requestOptions.data !== undefined) {
                req.write(Buffer.from(requestOptions.data));
            }
            req.end();
        });
    }
}
exports.BinaryNodejsHttpClient = BinaryNodejsHttpClient;
/**
 * Adapter for Node Https module to be used as HttpClient
 */
class BinaryFetchClient {
    constructor(fetch) {
        this.fetch = fetch;
    }
    async request(url, options) {
        const fetchOptions = {
            method: options.method,
            headers: options.headers,
            body: options.data
        };
        const res = await this.fetch(url, fetchOptions);
        const data = await res.text();
        return {
            ok: res.ok,
            status: res.status,
            statusText: res.statusText,
            data: data
        };
    }
}
exports.BinaryFetchClient = BinaryFetchClient;
function binaryHttpClient() {
    const noHttpClient = {
        async request(..._) {
            throw new Error('No method available to perform HTTP request');
        }
    };
    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {
        // Use fetch in a browser environment
        return new BinaryFetchClient(window.fetch.bind(window));
    }
    else if (typeof require !== 'undefined') {
        // Use Node https module
        // eslint-disable-next-line
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const https = require('https');
            return new BinaryNodejsHttpClient(https);
        }
        catch (e) {
            return noHttpClient;
        }
    }
    else {
        return noHttpClient;
    }
}
exports.binaryHttpClient = binaryHttpClient;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"https":322}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultHttpClient = void 0;
const NodejsHttpClient_js_1 = require("./NodejsHttpClient.js");
const FetchHttpClient_js_1 = require("./FetchHttpClient.js");
/**
 * Returns a default HttpClient implementation based on the environment that it is run on.
 * This method will attempt to use `window.fetch` if available (in browser environments).
 * If running in a Node environment, it falls back to using the Node `https` module
 */
function defaultHttpClient() {
    const noHttpClient = {
        async request(..._) {
            throw new Error('No method available to perform HTTP request');
        }
    };
    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {
        // Use fetch in a browser environment
        return new FetchHttpClient_js_1.FetchHttpClient(window.fetch.bind(window));
    }
    else if (typeof require !== 'undefined') {
        // Use Node https module
        // eslint-disable-next-line
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const https = require('https');
            return new NodejsHttpClient_js_1.NodejsHttpClient(https);
        }
        catch (e) {
            return noHttpClient;
        }
    }
    else {
        return noHttpClient;
    }
}
exports.defaultHttpClient = defaultHttpClient;

},{"./FetchHttpClient.js":102,"./NodejsHttpClient.js":103,"https":322}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpClient = void 0;
/**
 * Adapter for Node Https module to be used as HttpClient
 */
class FetchHttpClient {
    constructor(fetch) {
        this.fetch = fetch;
    }
    async request(url, options) {
        const fetchOptions = {
            method: options.method,
            headers: options.headers,
            body: JSON.stringify(options.data)
        };
        const res = await this.fetch(url, fetchOptions);
        const mediaType = res.headers.get('Content-Type');
        const data = mediaType?.startsWith('application/json') ?? false
            ? await res.json()
            : await res.text();
        return {
            ok: res.ok,
            status: res.status,
            statusText: res.statusText,
            data: data
        };
    }
}
exports.FetchHttpClient = FetchHttpClient;

},{}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodejsHttpClient = void 0;
/**
 * Adapter for Node Https module to be used as HttpClient
 */
class NodejsHttpClient {
    constructor(https) {
        this.https = https;
    }
    async request(url, requestOptions) {
        return await new Promise((resolve, reject) => {
            const req = this.https.request(url, requestOptions, (res) => {
                let body = '';
                res.on('data', (chunk) => {
                    body += chunk;
                });
                res.on('end', () => {
                    const ok = res.statusCode >= 200 && res.statusCode <= 299;
                    const mediaType = res.headers['content-type'];
                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')
                        ? JSON.parse(body)
                        : body;
                    resolve({
                        status: res.statusCode,
                        statusText: res.statusMessage,
                        ok,
                        data
                    });
                });
            });
            req.on('error', (error) => {
                reject(error);
            });
            if (requestOptions.data !== null && requestOptions.data !== undefined) {
                req.write(JSON.stringify(requestOptions.data));
            }
            req.end();
        });
    }
}
exports.NodejsHttpClient = NodejsHttpClient;

},{}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpClient = exports.NodejsHttpClient = exports.binaryHttpClient = exports.defaultHttpClient = void 0;
var DefaultHttpClient_js_1 = require("./DefaultHttpClient.js");
Object.defineProperty(exports, "defaultHttpClient", { enumerable: true, get: function () { return DefaultHttpClient_js_1.defaultHttpClient; } });
var BinaryFetchClient_js_1 = require("./BinaryFetchClient.js");
Object.defineProperty(exports, "binaryHttpClient", { enumerable: true, get: function () { return BinaryFetchClient_js_1.binaryHttpClient; } });
var NodejsHttpClient_js_1 = require("./NodejsHttpClient.js");
Object.defineProperty(exports, "NodejsHttpClient", { enumerable: true, get: function () { return NodejsHttpClient_js_1.NodejsHttpClient; } });
var FetchHttpClient_js_1 = require("./FetchHttpClient.js");
Object.defineProperty(exports, "FetchHttpClient", { enumerable: true, get: function () { return FetchHttpClient_js_1.FetchHttpClient; } });

},{"./BinaryFetchClient.js":100,"./DefaultHttpClient.js":101,"./FetchHttpClient.js":102,"./NodejsHttpClient.js":103}],105:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeefParty = exports.BeefTx = exports.isBroadcastFailure = exports.isBroadcastResponse = exports.MerklePath = exports.Transaction = void 0;
var Transaction_js_1 = require("./Transaction.js");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return __importDefault(Transaction_js_1).default; } });
var MerklePath_js_1 = require("./MerklePath.js");
Object.defineProperty(exports, "MerklePath", { enumerable: true, get: function () { return __importDefault(MerklePath_js_1).default; } });
var Broadcaster_js_1 = require("./Broadcaster.js");
Object.defineProperty(exports, "isBroadcastResponse", { enumerable: true, get: function () { return Broadcaster_js_1.isBroadcastResponse; } });
Object.defineProperty(exports, "isBroadcastFailure", { enumerable: true, get: function () { return Broadcaster_js_1.isBroadcastFailure; } });
var BeefTx_js_1 = require("./BeefTx.js");
Object.defineProperty(exports, "BeefTx", { enumerable: true, get: function () { return __importDefault(BeefTx_js_1).default; } });
__exportStar(require("./Beef.js"), exports);
var BeefParty_js_1 = require("./BeefParty.js");
Object.defineProperty(exports, "BeefParty", { enumerable: true, get: function () { return __importDefault(BeefParty_js_1).default; } });

},{"./Beef.js":83,"./BeefParty.js":84,"./BeefTx.js":85,"./Broadcaster.js":86,"./MerklePath.js":87,"./Transaction.js":88}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("../primitives/index.js");
const KeyDeriver_js_1 = require("./KeyDeriver.js");
/**
 * A cached version of KeyDeriver that caches the results of key derivation methods.
 * This is useful for optimizing performance when the same keys are derived multiple times.
 * It supports configurable cache size with sane defaults and maintains cache entries using LRU (Least Recently Used) eviction policy.
 */
class CachedKeyDeriver {
    /**
     * Initializes the CachedKeyDeriver instance with a root private key and optional cache settings.
     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.
     * @param {Object} [options] - Optional settings for the cache.
     * @param {number} [options.maxCacheSize=1000] - The maximum number of entries to store in the cache.
     */
    constructor(rootKey, options) {
        if (rootKey === 'anyone') {
            this.rootKey = new index_js_1.PrivateKey(1);
        }
        else {
            this.rootKey = rootKey;
        }
        this.keyDeriver = new KeyDeriver_js_1.KeyDeriver(this.rootKey, (priv, pub, point) => {
            this.cacheSet(`${priv.toString()}-${pub.toString()}`, point);
        }, (priv, pub) => {
            return this.cacheGet(`${priv.toString()}-${pub.toString()}`);
        });
        this.identityKey = this.rootKey.toPublicKey().toString();
        this.cache = new Map();
        const maxCacheSize = options?.maxCacheSize;
        this.maxCacheSize = (maxCacheSize != null && !isNaN(maxCacheSize) && maxCacheSize > 0) ? maxCacheSize : 1000;
    }
    /**
     * Derives a public key based on protocol ID, key ID, and counterparty.
     * Caches the result for future calls with the same parameters.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @param {boolean} [forSelf=false] - Whether deriving for self.
     * @returns {PublicKey} - The derived public key.
     */
    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {
        const cacheKey = this.generateCacheKey('derivePublicKey', protocolID, keyID, counterparty, forSelf);
        if (this.cache.has(cacheKey)) {
            const cachedValue = this.cacheGet(cacheKey);
            if (cachedValue === undefined) {
                throw new Error('Cached value is undefined');
            }
            return cachedValue;
        }
        else {
            const result = this.keyDeriver.derivePublicKey(protocolID, keyID, counterparty, forSelf);
            this.cacheSet(cacheKey, result);
            return result;
        }
    }
    /**
     * Derives a private key based on protocol ID, key ID, and counterparty.
     * Caches the result for future calls with the same parameters.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {PrivateKey} - The derived private key.
     */
    derivePrivateKey(protocolID, keyID, counterparty) {
        const cacheKey = this.generateCacheKey('derivePrivateKey', protocolID, keyID, counterparty);
        if (this.cache.has(cacheKey)) {
            const cachedValue = this.cacheGet(cacheKey);
            if (cachedValue === undefined) {
                throw new Error('Cached value is undefined');
            }
            return cachedValue;
        }
        else {
            const result = this.keyDeriver.derivePrivateKey(protocolID, keyID, counterparty);
            this.cacheSet(cacheKey, result);
            return result;
        }
    }
    /**
     * Derives a symmetric key based on protocol ID, key ID, and counterparty.
     * Caches the result for future calls with the same parameters.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {SymmetricKey} - The derived symmetric key.
     * @throws {Error} - Throws an error if attempting to derive a symmetric key for 'anyone'.
     */
    deriveSymmetricKey(protocolID, keyID, counterparty) {
        const cacheKey = this.generateCacheKey('deriveSymmetricKey', protocolID, keyID, counterparty);
        if (this.cache.has(cacheKey)) {
            const cachedValue = this.cacheGet(cacheKey);
            if (cachedValue === undefined) {
                throw new Error('Cached value is undefined');
            }
            return cachedValue;
        }
        else {
            const result = this.keyDeriver.deriveSymmetricKey(protocolID, keyID, counterparty);
            this.cacheSet(cacheKey, result);
            return result;
        }
    }
    /**
     * Reveals the shared secret between the root key and the counterparty.
     * Caches the result for future calls with the same parameters.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {number[]} - The shared secret as a number array.
     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.
     */
    revealCounterpartySecret(counterparty) {
        const cacheKey = this.generateCacheKey('revealCounterpartySecret', counterparty);
        if (this.cache.has(cacheKey)) {
            const cachedValue = this.cacheGet(cacheKey);
            if (cachedValue === undefined) {
                throw new Error('Cached value is undefined');
            }
            return cachedValue;
        }
        else {
            const result = this.keyDeriver.revealCounterpartySecret(counterparty);
            this.cacheSet(cacheKey, result);
            return result;
        }
    }
    /**
     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.
     * Caches the result for future calls with the same parameters.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @returns {number[]} - The specific key association as a number array.
     */
    revealSpecificSecret(counterparty, protocolID, keyID) {
        const cacheKey = this.generateCacheKey('revealSpecificSecret', counterparty, protocolID, keyID);
        if (this.cache.has(cacheKey)) {
            const cachedValue = this.cacheGet(cacheKey);
            if (cachedValue === undefined) {
                throw new Error('Cached value is undefined');
            }
            return cachedValue;
        }
        else {
            const result = this.keyDeriver.revealSpecificSecret(counterparty, protocolID, keyID);
            this.cacheSet(cacheKey, result);
            return result;
        }
    }
    /**
     * Generates a unique cache key based on the method name and input parameters.
     * @param {string} methodName - The name of the method.
     * @param {...any} args - The arguments passed to the method.
     * @returns {string} - The generated cache key.
     */
    generateCacheKey(methodName, ...args) {
        const serializedArgs = args
            .map((arg) => this.serializeArgument(arg))
            .join('|');
        return `${methodName}|${serializedArgs}`;
    }
    /**
     * Serializes an argument to a string for use in a cache key.
     * @param {any} arg - The argument to serialize.
     * @returns {string} - The serialized argument.
     */
    serializeArgument(arg) {
        if (arg instanceof index_js_1.PublicKey || arg instanceof index_js_1.PrivateKey) {
            return arg.toString();
        }
        else if (Array.isArray(arg)) {
            return arg.map((item) => this.serializeArgument(item)).join(',');
        }
        else if (typeof arg === 'object' && arg !== null) {
            return JSON.stringify(arg);
        }
        else {
            return String(arg);
        }
    }
    /**
     * Retrieves an item from the cache and updates its position to reflect recent use.
     * @param {string} cacheKey - The key of the cached item.
     * @returns {any} - The cached value.
     */
    cacheGet(cacheKey) {
        const value = this.cache.get(cacheKey);
        // Update the entry to reflect recent use
        this.cache.delete(cacheKey);
        if (value !== undefined) {
            this.cache.set(cacheKey, value);
        }
        return value;
    }
    /**
     * Adds an item to the cache and evicts the least recently used item if necessary.
     * @param {string} cacheKey - The key of the item to cache.
     * @param {any} value - The value to cache.
     */
    cacheSet(cacheKey, value) {
        if (this.cache.size >= this.maxCacheSize) {
            // Evict the least recently used item (first item in Map)
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(cacheKey, value);
    }
}
exports.default = CachedKeyDeriver;

},{"../primitives/index.js":61,"./KeyDeriver.js":107}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyDeriver = void 0;
const index_js_1 = require("../primitives/index.js");
/**
 * Class responsible for deriving various types of keys using a root private key.
 * It supports deriving public and private keys, symmetric keys, and revealing key linkages.
 */
class KeyDeriver {
    /**
     * Initializes the KeyDeriver instance with a root private key.
     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.
     */
    constructor(rootKey, cacheSharedSecret, retrieveCachedSharedSecret) {
        this.cacheSharedSecret = cacheSharedSecret;
        this.retrieveCachedSharedSecret = retrieveCachedSharedSecret;
        this.anyone = new index_js_1.PrivateKey(1).toPublicKey();
        if (rootKey === 'anyone') {
            this.rootKey = new index_js_1.PrivateKey(1);
        }
        else {
            this.rootKey = rootKey;
        }
        this.identityKey = this.rootKey.toPublicKey().toString();
    }
    /**
     * Derives a public key based on protocol ID, key ID, and counterparty.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @param {boolean} [forSelf=false] - Whether deriving for self.
     * @returns {PublicKey} - The derived public key.
     */
    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {
        counterparty = this.normalizeCounterparty(counterparty);
        if (forSelf) {
            return this.rootKey
                .deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret)
                .toPublicKey();
        }
        else {
            return counterparty.deriveChild(this.rootKey, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);
        }
    }
    /**
     * Derives a private key based on protocol ID, key ID, and counterparty.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {PrivateKey} - The derived private key.
     */
    derivePrivateKey(protocolID, keyID, counterparty) {
        counterparty = this.normalizeCounterparty(counterparty);
        return this.rootKey.deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);
    }
    /**
     * Derives a symmetric key based on protocol ID, key ID, and counterparty.
     * Note: Symmetric keys should not be derivable by everyone due to security risks.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {SymmetricKey} - The derived symmetric key.
     */
    deriveSymmetricKey(protocolID, keyID, counterparty) {
        // If counterparty is 'anyone', we use 1*G as the public key.
        // This is a publicly derivable key and should only be used in scenarios where public disclosure is intended.
        if (counterparty === 'anyone') {
            counterparty = this.anyone;
        }
        else {
            counterparty = this.normalizeCounterparty(counterparty);
        }
        const derivedPublicKey = this.derivePublicKey(protocolID, keyID, counterparty);
        const derivedPrivateKey = this.derivePrivateKey(protocolID, keyID, counterparty);
        return new index_js_1.SymmetricKey(derivedPrivateKey.deriveSharedSecret(derivedPublicKey)?.x?.toArray() ?? []);
    }
    /**
     * Reveals the shared secret between the root key and the counterparty.
     * Note: This should not be used for 'self'.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {number[]} - The shared secret as a number array.
     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.
     */
    revealCounterpartySecret(counterparty) {
        if (counterparty === 'self') {
            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');
        }
        counterparty = this.normalizeCounterparty(counterparty);
        // Double-check to ensure not revealing the secret for 'self'
        const self = this.rootKey.toPublicKey();
        const keyDerivedBySelf = this.rootKey.deriveChild(self, 'test').toHex();
        const keyDerivedByCounterparty = this.rootKey
            .deriveChild(counterparty, 'test')
            .toHex();
        if (keyDerivedBySelf === keyDerivedByCounterparty) {
            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');
        }
        return this.rootKey
            .deriveSharedSecret(counterparty)
            .encode(true);
    }
    /**
     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @returns {number[]} - The specific key association as a number array.
     */
    revealSpecificSecret(counterparty, protocolID, keyID) {
        counterparty = this.normalizeCounterparty(counterparty);
        const sharedSecret = this.rootKey.deriveSharedSecret(counterparty);
        const invoiceNumberBin = index_js_1.Utils.toArray(this.computeInvoiceNumber(protocolID, keyID), 'utf8');
        return index_js_1.Hash.sha256hmac(sharedSecret.encode(true), invoiceNumberBin);
    }
    /**
     * Normalizes the counterparty to a public key.
     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').
     * @returns {PublicKey} - The normalized counterparty public key.
     * @throws {Error} - Throws an error if the counterparty is invalid.
     */
    normalizeCounterparty(counterparty) {
        if (counterparty === null || counterparty === undefined) {
            throw new Error('counterparty must be self, anyone or a public key!');
        }
        else if (counterparty === 'self') {
            return this.rootKey.toPublicKey();
        }
        else if (counterparty === 'anyone') {
            return new index_js_1.PrivateKey(1).toPublicKey();
        }
        else if (typeof counterparty === 'string') {
            return index_js_1.PublicKey.fromString(counterparty);
        }
        else {
            return counterparty;
        }
    }
    /**
     * Computes the invoice number based on the protocol ID and key ID.
     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.
     * @param {string} keyID - The key identifier.
     * @returns {string} - The computed invoice number.
     * @throws {Error} - Throws an error if protocol ID or key ID are invalid.
     */
    computeInvoiceNumber(protocolID, keyID) {
        const securityLevel = protocolID[0];
        if (!Number.isInteger(securityLevel) ||
            securityLevel < 0 ||
            securityLevel > 2) {
            throw new Error('Protocol security level must be 0, 1, or 2');
        }
        const protocolName = protocolID[1].toLowerCase().trim();
        if (keyID.length > 800) {
            throw new Error('Key IDs must be 800 characters or less');
        }
        if (keyID.length < 1) {
            throw new Error('Key IDs must be 1 character or more');
        }
        if (protocolName.length > 400) {
            // Specific linkage revelation is the only protocol ID that can contain another protocol ID.
            // Therefore, we allow it to be long enough to encapsulate the target protocol
            if (protocolName.startsWith('specific linkage revelation ')) {
                // The format is: 'specific linkage revelation x YYYYY'
                // Where: x is the security level and YYYYY is the target protocol
                // Thus, the max acceptable length is 30 + 400 = 430 bytes
                if (protocolName.length > 430) {
                    throw new Error('Specific linkage revelation protocol names must be 430 characters or less');
                }
            }
            else {
                throw new Error('Protocol names must be 400 characters or less');
            }
        }
        if (protocolName.length < 5) {
            throw new Error('Protocol names must be 5 characters or more');
        }
        if (protocolName.includes('  ')) {
            throw new Error('Protocol names cannot contain multiple consecutive spaces ("  ")');
        }
        if (!/^[a-z0-9 ]+$/g.test(protocolName)) {
            throw new Error('Protocol names can only contain letters, numbers and spaces');
        }
        if (protocolName.endsWith(' protocol')) {
            throw new Error('No need to end your protocol name with " protocol"');
        }
        return `${securityLevel}-${protocolName}-${keyID}`;
    }
}
exports.KeyDeriver = KeyDeriver;
exports.default = KeyDeriver;

},{"../primitives/index.js":61}],108:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtoWallet = void 0;
const CachedKeyDeriver_js_1 = __importDefault(require("./CachedKeyDeriver.js"));
const index_js_1 = require("../primitives/index.js");
/**
 * A ProtoWallet is precursor to a full wallet, capable of performing all foundational cryptographic operations.
 * It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages.
 *
 * However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain,
 * enable the management of identity certificates, or store any data. It is also not concerned with privileged keys.
 */
class ProtoWallet {
    constructor(rootKeyOrKeyDeriver) {
        if (typeof rootKeyOrKeyDeriver.identityKey !== 'string') {
            rootKeyOrKeyDeriver = new CachedKeyDeriver_js_1.default(rootKeyOrKeyDeriver);
        }
        this.keyDeriver = rootKeyOrKeyDeriver;
    }
    async getPublicKey(args) {
        if (args.identityKey) {
            if (this.keyDeriver == null) {
                throw new Error('keyDeriver is undefined');
            }
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            if (args.protocolID == null || args.keyID == null || args.keyID === '') {
                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');
            }
            const keyDeriver = this.keyDeriver ??
                (() => {
                    throw new Error('keyDeriver is undefined');
                })();
            return {
                publicKey: keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf)
                    .toString()
            };
        }
    }
    async revealCounterpartyKeyLinkage(args) {
        const { publicKey: identityKey } = await this.getPublicKey({
            identityKey: true
        });
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);
        const linkageProof = new index_js_1.Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), index_js_1.PublicKey.fromString(args.counterparty), index_js_1.Point.fromDER(linkage));
        const linkageProofBin = [
            ...linkageProof.R.encode(true),
            ...linkageProof.SPrime.encode(true),
            ...linkageProof.z.toArray()
        ];
        const revelationTime = new Date().toISOString();
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: linkageProofBin,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            revelationTime,
            encryptedLinkage,
            encryptedLinkageProof
        };
    }
    async revealSpecificKeyLinkage(args) {
        const { publicKey: identityKey } = await this.getPublicKey({
            identityKey: true
        });
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [
                2,
                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`
            ],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: [0],
            protocolID: [
                2,
                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`
            ],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            protocolID: args.protocolID,
            keyID: args.keyID,
            encryptedLinkage,
            encryptedLinkageProof,
            proofType: 0
        };
    }
    async encrypt(args) {
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');
        return { ciphertext: key.encrypt(args.plaintext) };
    }
    async decrypt(args, originator) {
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');
        return { plaintext: key.decrypt(args.ciphertext) };
    }
    async createHmac(args) {
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');
        return { hmac: index_js_1.Hash.sha256hmac(key.toArray(), args.data) };
    }
    async verifyHmac(args) {
        if (this.keyDeriver == null) {
            throw new Error('keyDeriver is undefined');
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');
        const valid = index_js_1.Hash.sha256hmac(key.toArray(), args.data).toString() ===
            args.hmac.toString();
        if (!valid) {
            const e = new Error('HMAC is not valid');
            e.code = 'ERR_INVALID_HMAC';
            throw e;
        }
        return { valid };
    }
    async createSignature(args) {
        if ((args.hashToDirectlySign == null) && (args.data == null)) {
            throw new Error('args.data or args.hashToDirectlySign must be valid');
        }
        const hash = args.hashToDirectlySign ?? index_js_1.Hash.sha256(args.data ?? []);
        const keyDeriver = this.keyDeriver ??
            (() => {
                throw new Error('keyDeriver is undefined');
            })();
        const key = keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty ?? 'anyone');
        return {
            signature: index_js_1.ECDSA.sign(new index_js_1.BigNumber(hash), key, true).toDER()
        };
    }
    async verifySignature(args) {
        if ((args.hashToDirectlyVerify == null) && (args.data == null)) {
            throw new Error('args.data or args.hashToDirectlyVerify must be valid');
        }
        const hash = args.hashToDirectlyVerify ?? index_js_1.Hash.sha256(args.data ?? []);
        const keyDeriver = this.keyDeriver ??
            (() => {
                throw new Error('keyDeriver is undefined');
            })();
        const key = keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf);
        const valid = index_js_1.ECDSA.verify(new index_js_1.BigNumber(hash), index_js_1.Signature.fromDER(args.signature), key);
        if (!valid) {
            const e = new Error('Signature is not valid');
            e.code = 'ERR_INVALID_SIGNATURE';
            throw e;
        }
        return { valid };
    }
}
exports.ProtoWallet = ProtoWallet;
exports.default = ProtoWallet;

},{"../primitives/index.js":61,"./CachedKeyDeriver.js":106}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WERR_REVIEW_ACTIONS = void 0;
/**
 * When a `createAction` or `signAction` is completed in undelayed mode (`acceptDelayedBroadcast`: false),
 * any unsucccessful result will return the results by way of this exception to ensure attention is
 * paid to processing errors.
 */
class WERR_REVIEW_ACTIONS extends Error {
    /**
     * All parameters correspond to their comparable `createAction` or `signSction` results
     * with the exception of `reviewActionResults`;
     * which contains more details, particularly for double spend results.
     */
    constructor(reviewActionResults, sendWithResults, txid, tx, noSendChange) {
        super('Undelayed createAction or signAction results require review.');
        this.reviewActionResults = reviewActionResults;
        this.sendWithResults = sendWithResults;
        this.txid = txid;
        this.tx = tx;
        this.noSendChange = noSendChange;
        this.isError = true;
        this.code = 5;
        this.name = this.constructor.name;
    }
}
exports.WERR_REVIEW_ACTIONS = WERR_REVIEW_ACTIONS;
exports.default = WERR_REVIEW_ACTIONS;

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecurityLevels = void 0;
/**
 * @enum {number} SecurityLevels
 *
 * Silent = 0 Silently grants the request with no user interation.
 * App = 1 Requires user approval for every application.
 * Counterparty = 2 Requires user approval per counterparty per application.
 */
var SecurityLevels;
(function (SecurityLevels) {
    SecurityLevels[SecurityLevels["Silent"] = 0] = "Silent";
    SecurityLevels[SecurityLevels["App"] = 1] = "App";
    SecurityLevels[SecurityLevels["Counterparty"] = 2] = "Counterparty";
})(SecurityLevels || (exports.SecurityLevels = SecurityLevels = {}));

},{}],111:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const window_CWI_js_1 = __importDefault(require("./substrates/window.CWI.js"));
const XDM_js_1 = __importDefault(require("./substrates/XDM.js"));
const WalletWireTransceiver_js_1 = __importDefault(require("./substrates/WalletWireTransceiver.js"));
const HTTPWalletWire_js_1 = __importDefault(require("./substrates/HTTPWalletWire.js"));
const HTTPWalletJSON_js_1 = __importDefault(require("./substrates/HTTPWalletJSON.js"));
const ReactNativeWebView_js_1 = __importDefault(require("./substrates/ReactNativeWebView.js"));
const MAX_XDM_RESPONSE_WAIT = 200;
/**
 * The SDK is how applications communicate with wallets over a communications substrate.
 */
class WalletClient {
    constructor(substrate = 'auto', originator) {
        if (substrate === 'Cicada') {
            substrate = new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(originator));
        }
        if (substrate === 'window.CWI')
            substrate = new window_CWI_js_1.default();
        if (substrate === 'XDM')
            substrate = new XDM_js_1.default();
        if (substrate === 'json-api')
            substrate = new HTTPWalletJSON_js_1.default(originator);
        if (substrate === 'react-native')
            substrate = new ReactNativeWebView_js_1.default(originator);
        this.substrate = substrate;
        this.originator = originator;
    }
    async connectToSubstrate() {
        if (typeof this.substrate === 'object') {
            return; // substrate is already connected
        }
        let sub;
        const checkSub = async (timeout) => {
            let result;
            if (typeof timeout === 'number') {
                result = await Promise.race([
                    sub.getVersion({}),
                    new Promise((_resolve, reject) => setTimeout(() => reject(new Error('Timed out.')), timeout))
                ]);
            }
            else {
                result = await sub.getVersion({});
            }
            if (typeof result !== 'object' || typeof result.version !== 'string') {
                throw new Error('Failed to use substrate.');
            }
        };
        try {
            sub = new window_CWI_js_1.default();
            await checkSub();
            this.substrate = sub;
        }
        catch (e) {
            // XDM failed, try the next one...
            try {
                sub = new XDM_js_1.default();
                await checkSub(MAX_XDM_RESPONSE_WAIT);
                this.substrate = sub;
            }
            catch (e) {
                // HTTP wire failed, move on...
                try {
                    sub = new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(this.originator));
                    await checkSub();
                    this.substrate = sub;
                }
                catch (e) {
                    // HTTP Wire failed, attempt the next...
                    try {
                        sub = new HTTPWalletJSON_js_1.default(this.originator);
                        await checkSub();
                        this.substrate = sub;
                    }
                    catch (e) {
                        // HTTP JSON failed, attempt the next...
                        try {
                            sub = new ReactNativeWebView_js_1.default(this.originator);
                            await checkSub();
                            this.substrate = sub;
                        }
                        catch (e) {
                            // No comms. Tell the user to install a BSV wallet.
                            throw new Error('No wallet available over any communication substrate. Install a BSV wallet today!');
                        }
                    }
                }
            }
        }
    }
    async createAction(args) {
        await this.connectToSubstrate();
        return await this.substrate.createAction(args, this.originator);
    }
    async signAction(args) {
        await this.connectToSubstrate();
        return await this.substrate.signAction(args, this.originator);
    }
    async abortAction(args) {
        await this.connectToSubstrate();
        return await this.substrate.abortAction(args, this.originator);
    }
    async listActions(args) {
        await this.connectToSubstrate();
        return await this.substrate.listActions(args, this.originator);
    }
    async internalizeAction(args) {
        await this.connectToSubstrate();
        return await this.substrate.internalizeAction(args, this.originator);
    }
    async listOutputs(args) {
        await this.connectToSubstrate();
        return await this.substrate.listOutputs(args, this.originator);
    }
    async relinquishOutput(args) {
        await this.connectToSubstrate();
        return await this.substrate.relinquishOutput(args, this.originator);
    }
    async getPublicKey(args) {
        await this.connectToSubstrate();
        return await this.substrate.getPublicKey(args, this.originator);
    }
    async revealCounterpartyKeyLinkage(args) {
        await this.connectToSubstrate();
        return await this.substrate.revealCounterpartyKeyLinkage(args, this.originator);
    }
    async revealSpecificKeyLinkage(args) {
        await this.connectToSubstrate();
        return await this.substrate.revealSpecificKeyLinkage(args, this.originator);
    }
    async encrypt(args) {
        await this.connectToSubstrate();
        return await this.substrate.encrypt(args, this.originator);
    }
    async decrypt(args) {
        await this.connectToSubstrate();
        return await this.substrate.decrypt(args, this.originator);
    }
    async createHmac(args) {
        await this.connectToSubstrate();
        return await this.substrate.createHmac(args, this.originator);
    }
    async verifyHmac(args) {
        await this.connectToSubstrate();
        return await this.substrate.verifyHmac(args, this.originator);
    }
    async createSignature(args) {
        await this.connectToSubstrate();
        return await this.substrate.createSignature(args, this.originator);
    }
    async verifySignature(args) {
        await this.connectToSubstrate();
        return await this.substrate.verifySignature(args, this.originator);
    }
    async acquireCertificate(args) {
        await this.connectToSubstrate();
        return await this.substrate.acquireCertificate(args, this.originator);
    }
    async listCertificates(args) {
        await this.connectToSubstrate();
        return await this.substrate.listCertificates(args, this.originator);
    }
    async proveCertificate(args) {
        await this.connectToSubstrate();
        return await this.substrate.proveCertificate(args, this.originator);
    }
    async relinquishCertificate(args) {
        await this.connectToSubstrate();
        return await this.substrate.relinquishCertificate(args, this.originator);
    }
    async discoverByIdentityKey(args) {
        await this.connectToSubstrate();
        return await this.substrate.discoverByIdentityKey(args, this.originator);
    }
    async discoverByAttributes(args) {
        await this.connectToSubstrate();
        return await this.substrate.discoverByAttributes(args, this.originator);
    }
    async isAuthenticated(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.isAuthenticated(args, this.originator);
    }
    async waitForAuthentication(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.waitForAuthentication(args, this.originator);
    }
    async getHeight(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getHeight(args, this.originator);
    }
    async getHeaderForHeight(args) {
        await this.connectToSubstrate();
        return await this.substrate.getHeaderForHeight(args, this.originator);
    }
    async getNetwork(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getNetwork(args, this.originator);
    }
    async getVersion(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getVersion(args, this.originator);
    }
}
exports.default = WalletClient;

},{"./substrates/HTTPWalletJSON.js":114,"./substrates/HTTPWalletWire.js":115,"./substrates/ReactNativeWebView.js":116,"./substrates/WalletWireTransceiver.js":120,"./substrates/XDM.js":121,"./substrates/window.CWI.js":124}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walletErrors = exports.WalletError = void 0;
class WalletError extends Error {
    constructor(message, code = 1, stack) {
        super(message);
        this.isError = true;
        this.code = code;
        this.name = this.constructor.name;
        if (stack !== undefined && stack !== null && stack !== '') {
            this.stack = stack;
        }
        else {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.WalletError = WalletError;
// NOTE: Enum values must not exceed the UInt8 range (0–255)
var walletErrors;
(function (walletErrors) {
    walletErrors[walletErrors["unknownError"] = 1] = "unknownError";
    walletErrors[walletErrors["unsupportedAction"] = 2] = "unsupportedAction";
    walletErrors[walletErrors["invalidHmac"] = 3] = "invalidHmac";
    walletErrors[walletErrors["invalidSignature"] = 4] = "invalidSignature";
    walletErrors[walletErrors["reviewActions"] = 5] = "reviewActions";
})(walletErrors || (exports.walletErrors = walletErrors = {}));
exports.default = WalletError;

},{}],113:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WERR_REVIEW_ACTIONS = exports.WalletErrors = exports.WalletClient = exports.ProtoWallet = exports.CachedKeyDeriver = void 0;
__exportStar(require("./Wallet.interfaces.js"), exports);
__exportStar(require("./KeyDeriver.js"), exports);
var CachedKeyDeriver_js_1 = require("./CachedKeyDeriver.js");
Object.defineProperty(exports, "CachedKeyDeriver", { enumerable: true, get: function () { return __importDefault(CachedKeyDeriver_js_1).default; } });
var ProtoWallet_js_1 = require("./ProtoWallet.js");
Object.defineProperty(exports, "ProtoWallet", { enumerable: true, get: function () { return __importDefault(ProtoWallet_js_1).default; } });
var WalletClient_js_1 = require("./WalletClient.js");
Object.defineProperty(exports, "WalletClient", { enumerable: true, get: function () { return __importDefault(WalletClient_js_1).default; } });
// Is this an error? should it be 'walletErrors', the enum not the class?
var WalletError_js_1 = require("./WalletError.js");
Object.defineProperty(exports, "WalletErrors", { enumerable: true, get: function () { return __importDefault(WalletError_js_1).default; } });
var WERR_REVIEW_ACTIONS_js_1 = require("./WERR_REVIEW_ACTIONS.js");
Object.defineProperty(exports, "WERR_REVIEW_ACTIONS", { enumerable: true, get: function () { return __importDefault(WERR_REVIEW_ACTIONS_js_1).default; } });
__exportStar(require("./WalletError.js"), exports);
__exportStar(require("./substrates/index.js"), exports);

},{"./CachedKeyDeriver.js":106,"./KeyDeriver.js":107,"./ProtoWallet.js":108,"./WERR_REVIEW_ACTIONS.js":109,"./Wallet.interfaces.js":110,"./WalletClient.js":111,"./WalletError.js":112,"./substrates/index.js":122}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WERR_REVIEW_ACTIONS_js_1 = require("../WERR_REVIEW_ACTIONS.js");
const toOriginHeader_js_1 = require("./utils/toOriginHeader.js");
class HTTPWalletJSON {
    constructor(originator, baseUrl = 'http://localhost:3321', httpClient = fetch) {
        this.baseUrl = baseUrl;
        this.originator = originator;
        this.httpClient = httpClient;
        // Detect if we're in a browser environment
        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window?.origin !== 'file://';
        this.api = async (call, args) => {
            // In browser environments, let the browser handle Origin header automatically
            // In Node.js environments, we need to set it manually if originator is provided
            const origin = !isBrowser && this.originator
                ? (0, toOriginHeader_js_1.toOriginHeader)(this.originator, 'http')
                : undefined;
            if (!isBrowser && origin === undefined) {
                console.error('Originator is required in Node.js environments');
            }
            const res = await (await httpClient(`${this.baseUrl}/${call}`, {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                    ...(origin ? { Origin: origin } : {}),
                    ...(origin ? { Originator: origin } : {}),
                },
                body: JSON.stringify(args)
            }));
            const data = await res.json();
            // Check the HTTP status on the original response
            if (!res.ok) {
                if (res.status === 400 && data.isError && data.code === 5) {
                    const err = new WERR_REVIEW_ACTIONS_js_1.WERR_REVIEW_ACTIONS(data.reviewActionResults, data.sendWithResults, data.txid, data.tx, data.noSendChange);
                    throw err;
                }
                else {
                    const err = {
                        call,
                        args,
                        message: data.message ?? `HTTP Client error ${res.status}`
                    };
                    throw new Error(JSON.stringify(err));
                }
            }
            return data;
        };
    }
    async createAction(args) {
        return await this.api('createAction', args);
    }
    async signAction(args) {
        return await this.api('signAction', args);
    }
    async abortAction(args) {
        return await this.api('abortAction', args);
    }
    async listActions(args) {
        return await this.api('listActions', args);
    }
    async internalizeAction(args) {
        return await this.api('internalizeAction', args);
    }
    async listOutputs(args) {
        return await this.api('listOutputs', args);
    }
    async relinquishOutput(args) {
        return await this.api('relinquishOutput', args);
    }
    async getPublicKey(args) {
        return await this.api('getPublicKey', args);
    }
    async revealCounterpartyKeyLinkage(args) {
        return await this.api('revealCounterpartyKeyLinkage', args);
    }
    async revealSpecificKeyLinkage(args) {
        return await this.api('revealSpecificKeyLinkage', args);
    }
    async encrypt(args) {
        return await this.api('encrypt', args);
    }
    async decrypt(args) {
        return await this.api('decrypt', args);
    }
    async createHmac(args) {
        return await this.api('createHmac', args);
    }
    async verifyHmac(args) {
        return await this.api('verifyHmac', args);
    }
    async createSignature(args) {
        return await this.api('createSignature', args);
    }
    async verifySignature(args) {
        return await this.api('verifySignature', args);
    }
    async acquireCertificate(args) {
        return await this.api('acquireCertificate', args);
    }
    async listCertificates(args) {
        return await this.api('listCertificates', args);
    }
    async proveCertificate(args) {
        return await this.api('proveCertificate', args);
    }
    async relinquishCertificate(args) {
        return await this.api('relinquishCertificate', args);
    }
    async discoverByIdentityKey(args) {
        return await this.api('discoverByIdentityKey', args);
    }
    async discoverByAttributes(args) {
        return await this.api('discoverByAttributes', args);
    }
    async isAuthenticated(args) {
        return await this.api('isAuthenticated', args);
    }
    async waitForAuthentication(args) {
        return await this.api('waitForAuthentication', args);
    }
    async getHeight(args) {
        return await this.api('getHeight', args);
    }
    async getHeaderForHeight(args) {
        return await this.api('getHeaderForHeight', args);
    }
    async getNetwork(args) {
        return await this.api('getNetwork', args);
    }
    async getVersion(args) {
        return await this.api('getVersion', args);
    }
}
exports.default = HTTPWalletJSON;

},{"../WERR_REVIEW_ACTIONS.js":109,"./utils/toOriginHeader.js":123}],115:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const WalletWireCalls_js_1 = __importDefault(require("./WalletWireCalls.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
class HTTPWalletWire {
    constructor(originator, baseUrl = 'http://localhost:3301', httpClient = fetch) {
        this.baseUrl = baseUrl;
        this.httpClient = httpClient;
        this.originator = originator;
    }
    async transmitToWallet(message) {
        const messageReader = new Utils.Reader(message);
        // Read call code
        const callCode = messageReader.readUInt8();
        // Map call code to call name
        const callName = WalletWireCalls_js_1.default[callCode]; // calls is enum
        if (callName === undefined || callName === '') {
            // Invalid call code
            throw new Error(`Invalid call code: ${callCode}`);
        }
        // Read originator length
        const originatorLength = messageReader.readUInt8();
        let originator;
        if (originatorLength > 0) {
            const originatorBytes = messageReader.read(originatorLength);
            originator = Utils.toUTF8(originatorBytes);
        }
        const payload = messageReader.read();
        const response = await fetch(`${this.baseUrl}/${callName}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream',
                Origin: originator ?? '' // ✅ Explicitly handle null/undefined cases
            },
            body: new Uint8Array(payload)
        });
        const responseBuffer = await response.arrayBuffer();
        return Array.from(new Uint8Array(responseBuffer));
    }
}
exports.default = HTTPWalletWire;

},{"../../primitives/utils.js":62,"./WalletWireCalls.js":118}],116:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
const WalletError_js_1 = require("../WalletError.js");
/**
 * Facilitates wallet operations over cross-document messaging.
 */
class ReactNativeWebView {
    constructor(domain = '*') {
        if (typeof window !== 'object') {
            throw new Error('The XDM substrate requires a global window object.');
        }
        if (!window.hasOwnProperty("ReactNativeWebView")) {
            throw new Error('The window object does not have a ReactNativeWebView property.');
        }
        if (typeof window.ReactNativeWebView.postMessage !== 'function') {
            throw new Error('The window.ReactNativeWebView property does not seem to support postMessage calls.');
        }
        this.domain = domain;
    }
    async invoke(call, args) {
        return await new Promise((resolve, reject) => {
            const id = Utils.toBase64((0, Random_js_1.default)(12));
            const listener = (e) => {
                const data = JSON.parse(e.data);
                if (data.type !== 'CWI' ||
                    data.id !== id ||
                    data.isInvocation === true) {
                    return;
                }
                if (typeof window.removeEventListener === 'function') {
                    window.removeEventListener('message', listener);
                }
                if (data.status === 'error') {
                    const err = new WalletError_js_1.WalletError(data.description, data.code);
                    reject(err);
                }
                else {
                    resolve(data.result);
                }
            };
            window.addEventListener('message', listener);
            window.ReactNativeWebView.postMessage(JSON.stringify({
                type: 'CWI',
                isInvocation: true,
                id,
                call,
                args
            }));
        });
    }
    async createAction(args) {
        return await this.invoke('createAction', args);
    }
    async signAction(args) {
        return await this.invoke('signAction', args);
    }
    async abortAction(args) {
        return await this.invoke('abortAction', args);
    }
    async listActions(args) {
        return await this.invoke('listActions', args);
    }
    async internalizeAction(args) {
        return await this.invoke('internalizeAction', args);
    }
    async listOutputs(args) {
        return await this.invoke('listOutputs', args);
    }
    async relinquishOutput(args) {
        return await this.invoke('relinquishOutput', args);
    }
    async getPublicKey(args) {
        return await this.invoke('getPublicKey', args);
    }
    async revealCounterpartyKeyLinkage(args) {
        return await this.invoke('revealCounterpartyKeyLinkage', args);
    }
    async revealSpecificKeyLinkage(args) {
        return await this.invoke('revealSpecificKeyLinkage', args);
    }
    async encrypt(args) {
        return await this.invoke('encrypt', args);
    }
    async decrypt(args) {
        return await this.invoke('decrypt', args);
    }
    async createHmac(args) {
        return await this.invoke('createHmac', args);
    }
    async verifyHmac(args) {
        return await this.invoke('verifyHmac', args);
    }
    async createSignature(args) {
        return await this.invoke('createSignature', args);
    }
    async verifySignature(args) {
        return await this.invoke('verifySignature', args);
    }
    async acquireCertificate(args) {
        return await this.invoke('acquireCertificate', args);
    }
    async listCertificates(args) {
        return await this.invoke('listCertificates', args);
    }
    async proveCertificate(args) {
        return await this.invoke('proveCertificate', args);
    }
    async relinquishCertificate(args) {
        return await this.invoke('relinquishCertificate', args);
    }
    async discoverByIdentityKey(args) {
        return await this.invoke('discoverByIdentityKey', args);
    }
    async discoverByAttributes(args) {
        return await this.invoke('discoverByAttributes', args);
    }
    async isAuthenticated(args) {
        return await this.invoke('isAuthenticated', args);
    }
    async waitForAuthentication(args) {
        return await this.invoke('waitForAuthentication', args);
    }
    async getHeight(args) {
        return await this.invoke('getHeight', args);
    }
    async getHeaderForHeight(args) {
        return await this.invoke('getHeaderForHeight', args);
    }
    async getNetwork(args) {
        return await this.invoke('getNetwork', args);
    }
    async getVersion(args) {
        return await this.invoke('getVersion', args);
    }
}
exports.default = ReactNativeWebView;

},{"../../primitives/Random.js":55,"../../primitives/utils.js":62,"../WalletError.js":112}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// NOTE: Enum values must not exceed the UInt8 range (0–255)
var calls;
(function (calls) {
    calls[calls["createAction"] = 1] = "createAction";
    calls[calls["signAction"] = 2] = "signAction";
    calls[calls["abortAction"] = 3] = "abortAction";
    calls[calls["listActions"] = 4] = "listActions";
    calls[calls["internalizeAction"] = 5] = "internalizeAction";
    calls[calls["listOutputs"] = 6] = "listOutputs";
    calls[calls["relinquishOutput"] = 7] = "relinquishOutput";
    calls[calls["getPublicKey"] = 8] = "getPublicKey";
    calls[calls["revealCounterpartyKeyLinkage"] = 9] = "revealCounterpartyKeyLinkage";
    calls[calls["revealSpecificKeyLinkage"] = 10] = "revealSpecificKeyLinkage";
    calls[calls["encrypt"] = 11] = "encrypt";
    calls[calls["decrypt"] = 12] = "decrypt";
    calls[calls["createHmac"] = 13] = "createHmac";
    calls[calls["verifyHmac"] = 14] = "verifyHmac";
    calls[calls["createSignature"] = 15] = "createSignature";
    calls[calls["verifySignature"] = 16] = "verifySignature";
    calls[calls["acquireCertificate"] = 17] = "acquireCertificate";
    calls[calls["listCertificates"] = 18] = "listCertificates";
    calls[calls["proveCertificate"] = 19] = "proveCertificate";
    calls[calls["relinquishCertificate"] = 20] = "relinquishCertificate";
    calls[calls["discoverByIdentityKey"] = 21] = "discoverByIdentityKey";
    calls[calls["discoverByAttributes"] = 22] = "discoverByAttributes";
    calls[calls["isAuthenticated"] = 23] = "isAuthenticated";
    calls[calls["waitForAuthentication"] = 24] = "waitForAuthentication";
    calls[calls["getHeight"] = 25] = "getHeight";
    calls[calls["getHeaderForHeight"] = 26] = "getHeaderForHeight";
    calls[calls["getNetwork"] = 27] = "getNetwork";
    calls[calls["getVersion"] = 28] = "getVersion";
})(calls || (calls = {}));
exports.default = calls;

},{}],119:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils = __importStar(require("../../primitives/utils.js"));
const WalletWireCalls_js_1 = __importDefault(require("./WalletWireCalls.js"));
const Certificate_js_1 = __importDefault(require("../../auth/certificates/Certificate.js"));
/**
 * Processes incoming wallet calls received over a wallet wire, with a given wallet.
 */
class WalletWireProcessor {
    constructor(wallet) {
        this.wallet = wallet;
    }
    decodeOutpoint(reader) {
        const txidBytes = reader.read(32);
        const txid = Utils.toHex(txidBytes);
        const index = reader.readVarIntNum();
        return `${txid}.${index}`;
    }
    encodeOutpoint(outpoint) {
        const writer = new Utils.Writer();
        const [txid, index] = outpoint.split('.');
        writer.write(Utils.toArray(txid, 'hex'));
        writer.writeVarIntNum(Number(index));
        return writer.toArray();
    }
    async transmitToWallet(message) {
        const messageReader = new Utils.Reader(message);
        try {
            // Read call code
            const callCode = messageReader.readUInt8();
            // Map call code to call name
            const callName = WalletWireCalls_js_1.default[callCode]; // calls is enum
            if (callName === undefined || callName === '') {
                // Invalid call code
                throw new Error(`Invalid call code: ${callCode}`);
            }
            // Read originator length
            const originatorLength = messageReader.readUInt8();
            const originatorBytes = messageReader.read(originatorLength);
            const originator = Utils.toUTF8(originatorBytes);
            // Read parameters
            const paramsReader = messageReader; // Remaining bytes
            switch (callName) {
                case 'createAction': {
                    // Deserialize parameters from paramsReader
                    const args = {};
                    // Read description
                    const descriptionLength = paramsReader.readVarIntNum();
                    const descriptionBytes = paramsReader.read(descriptionLength);
                    args.description = Utils.toUTF8(descriptionBytes);
                    // tx
                    const inputBeefLength = paramsReader.readVarIntNum();
                    if (inputBeefLength >= 0) {
                        args.inputBEEF = paramsReader.read(inputBeefLength); // BEEF (Byte[])
                    }
                    else {
                        args.inputBEEF = undefined;
                    }
                    // Read inputs
                    const inputsLength = paramsReader.readVarIntNum();
                    if (inputsLength >= 0) {
                        args.inputs = [];
                        for (let i = 0; i < inputsLength; i++) {
                            const input = {};
                            // outpoint
                            input.outpoint = this.decodeOutpoint(paramsReader);
                            // unlockingScript / unlockingScriptLength
                            const unlockingScriptLength = paramsReader.readVarIntNum();
                            if (unlockingScriptLength >= 0) {
                                const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);
                                input.unlockingScript = Utils.toHex(unlockingScriptBytes);
                            }
                            else {
                                input.unlockingScript = undefined;
                                const unlockingScriptLengthValue = paramsReader.readVarIntNum();
                                input.unlockingScriptLength = unlockingScriptLengthValue;
                            }
                            // inputDescription
                            const inputDescriptionLength = paramsReader.readVarIntNum();
                            const inputDescriptionBytes = paramsReader.read(inputDescriptionLength);
                            input.inputDescription = Utils.toUTF8(inputDescriptionBytes);
                            // sequenceNumber
                            const sequenceNumber = paramsReader.readVarIntNum();
                            if (sequenceNumber >= 0) {
                                input.sequenceNumber = sequenceNumber;
                            }
                            else {
                                input.sequenceNumber = undefined;
                            }
                            args.inputs.push(input);
                        }
                    }
                    else {
                        args.inputs = undefined;
                    }
                    // Read outputs
                    const outputsLength = paramsReader.readVarIntNum();
                    if (outputsLength >= 0) {
                        args.outputs = [];
                        for (let i = 0; i < outputsLength; i++) {
                            const output = {};
                            // lockingScript
                            const lockingScriptLength = paramsReader.readVarIntNum();
                            const lockingScriptBytes = paramsReader.read(lockingScriptLength);
                            output.lockingScript = Utils.toHex(lockingScriptBytes);
                            // satoshis
                            output.satoshis = paramsReader.readVarIntNum();
                            // outputDescription
                            const outputDescriptionLength = paramsReader.readVarIntNum();
                            const outputDescriptionBytes = paramsReader.read(outputDescriptionLength);
                            output.outputDescription = Utils.toUTF8(outputDescriptionBytes);
                            // basket
                            const basketLength = paramsReader.readVarIntNum();
                            if (basketLength >= 0) {
                                const basketBytes = paramsReader.read(basketLength);
                                output.basket = Utils.toUTF8(basketBytes);
                            }
                            else {
                                output.basket = undefined;
                            }
                            // customInstructions
                            const customInstructionsLength = paramsReader.readVarIntNum();
                            if (customInstructionsLength >= 0) {
                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);
                                output.customInstructions = Utils.toUTF8(customInstructionsBytes);
                            }
                            else {
                                output.customInstructions = undefined;
                            }
                            // tags
                            const tagsLength = paramsReader.readVarIntNum();
                            if (tagsLength >= 0) {
                                output.tags = [];
                                for (let j = 0; j < tagsLength; j++) {
                                    const tagLength = paramsReader.readVarIntNum();
                                    const tagBytes = paramsReader.read(tagLength);
                                    const tag = Utils.toUTF8(tagBytes);
                                    output.tags.push(tag);
                                }
                            }
                            else {
                                output.tags = undefined;
                            }
                            args.outputs.push(output);
                        }
                    }
                    else {
                        args.outputs = undefined;
                    }
                    // lockTime
                    const lockTime = paramsReader.readVarIntNum();
                    if (lockTime >= 0) {
                        args.lockTime = lockTime;
                    }
                    else {
                        args.lockTime = undefined;
                    }
                    // version
                    const version = paramsReader.readVarIntNum();
                    if (version >= 0) {
                        args.version = version;
                    }
                    else {
                        args.version = undefined;
                    }
                    // labels
                    const labelsLength = paramsReader.readVarIntNum();
                    if (labelsLength >= 0) {
                        args.labels = [];
                        for (let i = 0; i < labelsLength; i++) {
                            const labelLength = paramsReader.readVarIntNum();
                            const labelBytes = paramsReader.read(labelLength);
                            const label = Utils.toUTF8(labelBytes);
                            args.labels.push(label);
                        }
                    }
                    else {
                        args.labels = undefined;
                    }
                    // options
                    const optionsPresent = paramsReader.readInt8();
                    if (optionsPresent === 1) {
                        args.options = {};
                        // signAndProcess
                        const signAndProcessFlag = paramsReader.readInt8();
                        if (signAndProcessFlag === -1) {
                            args.options.signAndProcess = undefined;
                        }
                        else {
                            args.options.signAndProcess = signAndProcessFlag === 1;
                        }
                        // acceptDelayedBroadcast
                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();
                        if (acceptDelayedBroadcastFlag === -1) {
                            args.options.acceptDelayedBroadcast = undefined;
                        }
                        else {
                            args.options.acceptDelayedBroadcast =
                                acceptDelayedBroadcastFlag === 1;
                        }
                        // trustSelf
                        const trustSelfFlag = paramsReader.readInt8();
                        if (trustSelfFlag === -1) {
                            args.options.trustSelf = undefined;
                        }
                        else if (trustSelfFlag === 1) {
                            args.options.trustSelf = 'known';
                        }
                        // knownTxids
                        const knownTxidsLength = paramsReader.readVarIntNum();
                        if (knownTxidsLength >= 0) {
                            args.options.knownTxids = [];
                            for (let i = 0; i < knownTxidsLength; i++) {
                                const txidBytes = paramsReader.read(32);
                                const txid = Utils.toHex(txidBytes);
                                args.options.knownTxids.push(txid);
                            }
                        }
                        else {
                            args.options.knownTxids = undefined;
                        }
                        // returnTXIDOnly
                        const returnTXIDOnlyFlag = paramsReader.readInt8();
                        if (returnTXIDOnlyFlag === -1) {
                            args.options.returnTXIDOnly = undefined;
                        }
                        else {
                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;
                        }
                        // noSend
                        const noSendFlag = paramsReader.readInt8();
                        if (noSendFlag === -1) {
                            args.options.noSend = undefined;
                        }
                        else {
                            args.options.noSend = noSendFlag === 1;
                        }
                        // noSendChange
                        const noSendChangeLength = paramsReader.readVarIntNum();
                        if (noSendChangeLength >= 0) {
                            args.options.noSendChange = [];
                            for (let i = 0; i < noSendChangeLength; i++) {
                                const outpoint = this.decodeOutpoint(paramsReader);
                                args.options.noSendChange.push(outpoint);
                            }
                        }
                        else {
                            args.options.noSendChange = undefined;
                        }
                        // sendWith
                        const sendWithLength = paramsReader.readVarIntNum();
                        if (sendWithLength >= 0) {
                            args.options.sendWith = [];
                            for (let i = 0; i < sendWithLength; i++) {
                                const txidBytes = paramsReader.read(32);
                                const txid = Utils.toHex(txidBytes);
                                args.options.sendWith.push(txid);
                            }
                        }
                        else {
                            args.options.sendWith = undefined;
                        }
                        // randomizeOutputs
                        const randomizeOutputsFlag = paramsReader.readInt8();
                        if (randomizeOutputsFlag === -1) {
                            args.options.randomizeOutputs = undefined;
                        }
                        else {
                            args.options.randomizeOutputs = randomizeOutputsFlag === 1;
                        }
                    }
                    else {
                        args.options = undefined;
                    }
                    // Call the method
                    const createActionResult = await this.wallet.createAction(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // txid
                    if (createActionResult.txid != null && createActionResult.txid !== '') {
                        resultWriter.writeInt8(1);
                        resultWriter.write(Utils.toArray(createActionResult.txid, 'hex'));
                    }
                    else {
                        resultWriter.writeInt8(0);
                    }
                    // tx
                    if (createActionResult.tx != null) {
                        resultWriter.writeInt8(1);
                        resultWriter.writeVarIntNum(createActionResult.tx.length);
                        resultWriter.write(createActionResult.tx);
                    }
                    else {
                        resultWriter.writeInt8(0);
                    }
                    // noSendChange
                    if (createActionResult.noSendChange != null) {
                        resultWriter.writeVarIntNum(createActionResult.noSendChange.length);
                        for (const outpoint of createActionResult.noSendChange) {
                            resultWriter.write(this.encodeOutpoint(outpoint));
                        }
                    }
                    else {
                        resultWriter.writeVarIntNum(-1);
                    }
                    // sendWithResults
                    if (createActionResult.sendWithResults != null) {
                        resultWriter.writeVarIntNum(createActionResult.sendWithResults.length);
                        for (const result of createActionResult.sendWithResults) {
                            resultWriter.write(Utils.toArray(result.txid, 'hex'));
                            let statusCode;
                            if (result.status === 'unproven')
                                statusCode = 1;
                            else if (result.status === 'sending')
                                statusCode = 2;
                            else if (result.status === 'failed')
                                statusCode = 3;
                            resultWriter.writeInt8(statusCode);
                        }
                    }
                    else {
                        resultWriter.writeVarIntNum(-1);
                    }
                    // signableTransaction
                    if (createActionResult.signableTransaction != null) {
                        resultWriter.writeInt8(1);
                        resultWriter.writeVarIntNum(createActionResult.signableTransaction.tx.length);
                        resultWriter.write(createActionResult.signableTransaction.tx);
                        const referenceBytes = Utils.toArray(createActionResult.signableTransaction.reference, 'base64');
                        resultWriter.writeVarIntNum(referenceBytes.length);
                        resultWriter.write(referenceBytes);
                    }
                    else {
                        resultWriter.writeInt8(0);
                    }
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'signAction': {
                    const args = {};
                    // Deserialize spends
                    const spendCount = paramsReader.readVarIntNum();
                    args.spends = {};
                    for (let i = 0; i < spendCount; i++) {
                        const inputIndex = paramsReader.readVarIntNum();
                        const spend = {};
                        // unlockingScript
                        const unlockingScriptLength = paramsReader.readVarIntNum();
                        const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);
                        spend.unlockingScript = Utils.toHex(unlockingScriptBytes);
                        // sequenceNumber
                        const sequenceNumber = paramsReader.readVarIntNum();
                        if (sequenceNumber >= 0) {
                            spend.sequenceNumber = sequenceNumber;
                        }
                        else {
                            spend.sequenceNumber = undefined;
                        }
                        args.spends[inputIndex] = spend;
                    }
                    // Deserialize reference
                    const referenceLength = paramsReader.readVarIntNum();
                    const referenceBytes = paramsReader.read(referenceLength);
                    args.reference = Utils.toBase64(referenceBytes);
                    // Deserialize options
                    const optionsPresent = paramsReader.readInt8();
                    if (optionsPresent === 1) {
                        args.options = {};
                        // acceptDelayedBroadcast
                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();
                        if (acceptDelayedBroadcastFlag === -1) {
                            args.options.acceptDelayedBroadcast = undefined;
                        }
                        else {
                            args.options.acceptDelayedBroadcast =
                                acceptDelayedBroadcastFlag === 1;
                        }
                        // returnTXIDOnly
                        const returnTXIDOnlyFlag = paramsReader.readInt8();
                        if (returnTXIDOnlyFlag === -1) {
                            args.options.returnTXIDOnly = undefined;
                        }
                        else {
                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;
                        }
                        // noSend
                        const noSendFlag = paramsReader.readInt8();
                        if (noSendFlag === -1) {
                            args.options.noSend = undefined;
                        }
                        else {
                            args.options.noSend = noSendFlag === 1;
                        }
                        // sendWith
                        const sendWithLength = paramsReader.readVarIntNum();
                        if (sendWithLength >= 0) {
                            args.options.sendWith = [];
                            for (let i = 0; i < sendWithLength; i++) {
                                const txidBytes = paramsReader.read(32);
                                const txid = Utils.toHex(txidBytes);
                                args.options.sendWith.push(txid);
                            }
                        }
                        else {
                            args.options.sendWith = undefined;
                        }
                    }
                    else {
                        args.options = undefined;
                    }
                    // Call the method
                    const signActionResult = await this.wallet.signAction(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // txid
                    if (signActionResult.txid != null && signActionResult.txid !== '') {
                        resultWriter.writeInt8(1);
                        resultWriter.write(Utils.toArray(signActionResult.txid, 'hex'));
                    }
                    else {
                        resultWriter.writeInt8(0);
                    }
                    // tx
                    if (signActionResult.tx != null) {
                        resultWriter.writeInt8(1);
                        resultWriter.writeVarIntNum(signActionResult.tx.length);
                        resultWriter.write(signActionResult.tx);
                    }
                    else {
                        resultWriter.writeInt8(0);
                    }
                    // sendWithResults
                    if (signActionResult.sendWithResults != null) {
                        resultWriter.writeVarIntNum(signActionResult.sendWithResults.length);
                        for (const result of signActionResult.sendWithResults) {
                            resultWriter.write(Utils.toArray(result.txid, 'hex'));
                            let statusCode;
                            if (result.status === 'unproven')
                                statusCode = 1;
                            else if (result.status === 'sending')
                                statusCode = 2;
                            else if (result.status === 'failed')
                                statusCode = 3;
                            resultWriter.writeInt8(statusCode);
                        }
                    }
                    else {
                        resultWriter.writeVarIntNum(-1);
                    }
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'abortAction': {
                    // Deserialize reference
                    const referenceBytes = paramsReader.read();
                    const reference = Utils.toBase64(referenceBytes);
                    // Call the method
                    await this.wallet.abortAction({ reference }, originator);
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'listActions': {
                    const args = {};
                    // Deserialize labels
                    const labelsLength = paramsReader.readVarIntNum();
                    args.labels = [];
                    for (let i = 0; i < labelsLength; i++) {
                        const labelLength = paramsReader.readVarIntNum();
                        const labelBytes = paramsReader.read(labelLength);
                        args.labels.push(Utils.toUTF8(labelBytes));
                    }
                    // Deserialize labelQueryMode
                    const labelQueryModeFlag = paramsReader.readInt8();
                    if (labelQueryModeFlag === -1) {
                        args.labelQueryMode = undefined;
                    }
                    else if (labelQueryModeFlag === 1) {
                        args.labelQueryMode = 'any';
                    }
                    else if (labelQueryModeFlag === 2) {
                        args.labelQueryMode = 'all';
                    }
                    // Deserialize include options
                    const includeOptionsNames = [
                        'includeLabels',
                        'includeInputs',
                        'includeInputSourceLockingScripts',
                        'includeInputUnlockingScripts',
                        'includeOutputs',
                        'includeOutputLockingScripts'
                    ];
                    for (const optionName of includeOptionsNames) {
                        const optionFlag = paramsReader.readInt8();
                        if (optionFlag === -1) {
                            args[optionName] = undefined;
                        }
                        else {
                            args[optionName] = optionFlag === 1;
                        }
                    }
                    // Deserialize limit
                    const limit = paramsReader.readVarIntNum();
                    if (limit >= 0) {
                        args.limit = limit;
                    }
                    else {
                        args.limit = undefined;
                    }
                    // Deserialize offset
                    const offset = paramsReader.readVarIntNum();
                    if (offset >= 0) {
                        args.offset = offset;
                    }
                    else {
                        args.offset = undefined;
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const listActionsResult = await this.wallet.listActions(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // totalActions
                    resultWriter.writeVarIntNum(listActionsResult.totalActions);
                    // actions
                    for (const action of listActionsResult.actions) {
                        // txid
                        resultWriter.write(Utils.toArray(action.txid, 'hex'));
                        // satoshis
                        resultWriter.writeVarIntNum(action.satoshis);
                        // status
                        let statusCode;
                        switch (action.status) {
                            case 'completed':
                                statusCode = 1;
                                break;
                            case 'unprocessed':
                                statusCode = 2;
                                break;
                            case 'sending':
                                statusCode = 3;
                                break;
                            case 'unproven':
                                statusCode = 4;
                                break;
                            case 'unsigned':
                                statusCode = 5;
                                break;
                            case 'nosend':
                                statusCode = 6;
                                break;
                            case 'nonfinal':
                                statusCode = 7;
                                break;
                            case 'failed':
                                statusCode = 8;
                                break;
                            default:
                                statusCode = -1;
                                break;
                        }
                        resultWriter.writeInt8(statusCode);
                        // isOutgoing
                        resultWriter.writeInt8(action.isOutgoing ? 1 : 0);
                        // description
                        const descriptionBytes = Utils.toArray(action.description, 'utf8');
                        resultWriter.writeVarIntNum(descriptionBytes.length);
                        resultWriter.write(descriptionBytes);
                        // labels
                        if (action.labels !== undefined) {
                            resultWriter.writeVarIntNum(action.labels.length);
                            for (const label of action.labels) {
                                const labelBytes = Utils.toArray(label, 'utf8');
                                resultWriter.writeVarIntNum(labelBytes.length);
                                resultWriter.write(labelBytes);
                            }
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                        // version
                        resultWriter.writeVarIntNum(action.version);
                        // lockTime
                        resultWriter.writeVarIntNum(action.lockTime);
                        // inputs
                        if (action.inputs !== undefined) {
                            resultWriter.writeVarIntNum(action.inputs.length);
                            for (const input of action.inputs) {
                                // sourceOutpoint
                                resultWriter.write(this.encodeOutpoint(input.sourceOutpoint));
                                // sourceSatoshis
                                resultWriter.writeVarIntNum(input.sourceSatoshis);
                                // sourceLockingScript
                                if (input.sourceLockingScript !== undefined) {
                                    const sourceLockingScriptBytes = Utils.toArray(input.sourceLockingScript, 'hex');
                                    resultWriter.writeVarIntNum(sourceLockingScriptBytes.length);
                                    resultWriter.write(sourceLockingScriptBytes);
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                                // unlockingScript
                                if (input.unlockingScript !== undefined) {
                                    const unlockingScriptBytes = Utils.toArray(input.unlockingScript, 'hex');
                                    resultWriter.writeVarIntNum(unlockingScriptBytes.length);
                                    resultWriter.write(unlockingScriptBytes);
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                                // inputDescription
                                const inputDescriptionBytes = Utils.toArray(input.inputDescription, 'utf8');
                                resultWriter.writeVarIntNum(inputDescriptionBytes.length);
                                resultWriter.write(inputDescriptionBytes);
                                // sequenceNumber
                                resultWriter.writeVarIntNum(input.sequenceNumber);
                            }
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                        // outputs
                        if (action.outputs !== undefined) {
                            resultWriter.writeVarIntNum(action.outputs.length);
                            for (const output of action.outputs) {
                                // outputIndex
                                resultWriter.writeVarIntNum(output.outputIndex);
                                // satoshis
                                resultWriter.writeVarIntNum(output.satoshis);
                                // lockingScript
                                if (output.lockingScript !== undefined) {
                                    const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');
                                    resultWriter.writeVarIntNum(lockingScriptBytes.length);
                                    resultWriter.write(lockingScriptBytes);
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                                // spendable
                                resultWriter.writeInt8(output.spendable ? 1 : 0);
                                // outputDescription
                                const outputDescriptionBytes = Utils.toArray(output.outputDescription, 'utf8');
                                resultWriter.writeVarIntNum(outputDescriptionBytes.length);
                                resultWriter.write(outputDescriptionBytes);
                                // basket
                                if (output.basket !== undefined) {
                                    const basketBytes = Utils.toArray(output.basket, 'utf8');
                                    resultWriter.writeVarIntNum(basketBytes.length);
                                    resultWriter.write(basketBytes);
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                                // tags
                                if (output.tags !== undefined) {
                                    resultWriter.writeVarIntNum(output.tags.length);
                                    for (const tag of output.tags) {
                                        const tagBytes = Utils.toArray(tag, 'utf8');
                                        resultWriter.writeVarIntNum(tagBytes.length);
                                        resultWriter.write(tagBytes);
                                    }
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                                // customInstructions
                                if (output.customInstructions !== undefined) {
                                    const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');
                                    resultWriter.writeVarIntNum(customInstructionsBytes.length);
                                    resultWriter.write(customInstructionsBytes);
                                }
                                else {
                                    resultWriter.writeVarIntNum(-1);
                                }
                            }
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                    }
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'internalizeAction': {
                    const args = {};
                    // Read tx
                    const txLength = paramsReader.readVarIntNum();
                    args.tx = paramsReader.read(txLength);
                    // Read outputs
                    const outputsLength = paramsReader.readVarIntNum();
                    args.outputs = [];
                    for (let i = 0; i < outputsLength; i++) {
                        const output = {};
                        // outputIndex
                        output.outputIndex = paramsReader.readVarIntNum();
                        // protocol
                        const protocolFlag = paramsReader.readUInt8();
                        if (protocolFlag === 1) {
                            output.protocol = 'wallet payment';
                            output.paymentRemittance = {};
                            // senderIdentityKey
                            const senderIdentityKeyBytes = paramsReader.read(33);
                            output.paymentRemittance.senderIdentityKey = Utils.toHex(senderIdentityKeyBytes);
                            // derivationPrefix
                            const derivationPrefixLength = paramsReader.readVarIntNum();
                            const derivationPrefixBytes = paramsReader.read(derivationPrefixLength);
                            output.paymentRemittance.derivationPrefix = Utils.toBase64(derivationPrefixBytes);
                            // derivationSuffix
                            const derivationSuffixLength = paramsReader.readVarIntNum();
                            const derivationSuffixBytes = paramsReader.read(derivationSuffixLength);
                            output.paymentRemittance.derivationSuffix = Utils.toBase64(derivationSuffixBytes);
                        }
                        else if (protocolFlag === 2) {
                            output.protocol = 'basket insertion';
                            output.insertionRemittance = {};
                            // basket
                            const basketLength = paramsReader.readVarIntNum();
                            const basketBytes = paramsReader.read(basketLength);
                            output.insertionRemittance.basket = Utils.toUTF8(basketBytes);
                            // customInstructions
                            const customInstructionsLength = paramsReader.readVarIntNum();
                            if (customInstructionsLength >= 0) {
                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);
                                output.insertionRemittance.customInstructions = Utils.toUTF8(customInstructionsBytes);
                            }
                            // tags
                            const tagsLength = paramsReader.readVarIntNum();
                            if (tagsLength > 0) {
                                output.insertionRemittance.tags = [];
                                for (let j = 0; j < tagsLength; j++) {
                                    const tagLength = paramsReader.readVarIntNum();
                                    const tagBytes = paramsReader.read(tagLength);
                                    output.insertionRemittance.tags.push(Utils.toUTF8(tagBytes));
                                }
                            }
                            else {
                                output.insertionRemittance.tags = [];
                            }
                        }
                        args.outputs.push(output);
                    }
                    const numberOfLabels = paramsReader.readVarIntNum();
                    if (numberOfLabels >= 0) {
                        args.labels = [];
                        for (let i = 0; i < numberOfLabels; i++) {
                            const labelLength = paramsReader.readVarIntNum();
                            args.labels.push(Utils.toUTF8(paramsReader.read(labelLength)));
                        }
                    }
                    const descriptionLength = paramsReader.readVarIntNum();
                    args.description = Utils.toUTF8(paramsReader.read(descriptionLength));
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    await this.wallet.internalizeAction(args, originator);
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'listOutputs': {
                    const args = {};
                    // Deserialize basket
                    const basketLength = paramsReader.readVarIntNum();
                    const basketBytes = paramsReader.read(basketLength);
                    args.basket = Utils.toUTF8(basketBytes);
                    // Deserialize tags
                    const tagsLength = paramsReader.readVarIntNum();
                    if (tagsLength > 0) {
                        args.tags = [];
                        for (let i = 0; i < tagsLength; i++) {
                            const tagLength = paramsReader.readVarIntNum();
                            const tagBytes = paramsReader.read(tagLength);
                            args.tags.push(Utils.toUTF8(tagBytes));
                        }
                    }
                    else {
                        args.tags = undefined;
                    }
                    // Deserialize tagQueryMode
                    const tagQueryModeFlag = paramsReader.readInt8();
                    if (tagQueryModeFlag === 1) {
                        args.tagQueryMode = 'all';
                    }
                    else if (tagQueryModeFlag === 2) {
                        args.tagQueryMode = 'any';
                    }
                    else {
                        args.tagQueryMode = undefined;
                    }
                    // Deserialize include
                    const includeFlag = paramsReader.readInt8();
                    if (includeFlag === 1) {
                        args.include = 'locking scripts';
                    }
                    else if (includeFlag === 2) {
                        args.include = 'entire transactions';
                    }
                    else {
                        args.include = undefined;
                    }
                    // Deserialize includeCustomInstructions
                    const includeCustomInstructionsFlag = paramsReader.readInt8();
                    if (includeCustomInstructionsFlag === -1) {
                        args.includeCustomInstructions = undefined;
                    }
                    else {
                        args.includeCustomInstructions =
                            includeCustomInstructionsFlag === 1;
                    }
                    // Deserialize includeTags
                    const includeTagsFlag = paramsReader.readInt8();
                    if (includeTagsFlag === -1) {
                        args.includeTags = undefined;
                    }
                    else {
                        args.includeTags = includeTagsFlag === 1;
                    }
                    // Deserialize includeLabels
                    const includeLabelsFlag = paramsReader.readInt8();
                    if (includeLabelsFlag === -1) {
                        args.includeLabels = undefined;
                    }
                    else {
                        args.includeLabels = includeLabelsFlag === 1;
                    }
                    // Deserialize limit
                    const limit = paramsReader.readVarIntNum();
                    if (limit >= 0) {
                        args.limit = limit;
                    }
                    else {
                        args.limit = undefined;
                    }
                    // Deserialize offset
                    const offset = paramsReader.readVarIntNum();
                    if (offset >= 0) {
                        args.offset = offset;
                    }
                    else {
                        args.offset = undefined;
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const listOutputsResult = await this.wallet.listOutputs(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // totalOutputs
                    resultWriter.writeVarIntNum(listOutputsResult.totalOutputs);
                    // BEEF length and BEEF or -1
                    if (listOutputsResult.BEEF != null) {
                        resultWriter.writeVarIntNum(listOutputsResult.BEEF.length);
                        resultWriter.write(listOutputsResult.BEEF);
                    }
                    else {
                        resultWriter.writeVarIntNum(-1);
                    }
                    // outputs
                    for (const output of listOutputsResult.outputs) {
                        // outpoint
                        resultWriter.write(this.encodeOutpoint(output.outpoint));
                        // satoshis
                        resultWriter.writeVarIntNum(output.satoshis);
                        // lockingScript
                        if (output.lockingScript !== undefined) {
                            const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');
                            resultWriter.writeVarIntNum(lockingScriptBytes.length);
                            resultWriter.write(lockingScriptBytes);
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                        // customInstructions
                        if (output.customInstructions !== undefined) {
                            const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');
                            resultWriter.writeVarIntNum(customInstructionsBytes.length);
                            resultWriter.write(customInstructionsBytes);
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                        // tags
                        if (output.tags !== undefined) {
                            resultWriter.writeVarIntNum(output.tags.length);
                            for (const tag of output.tags) {
                                const tagBytes = Utils.toArray(tag, 'utf8');
                                resultWriter.writeVarIntNum(tagBytes.length);
                                resultWriter.write(tagBytes);
                            }
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                        // labels
                        if (output.labels !== undefined) {
                            resultWriter.writeVarIntNum(output.labels.length);
                            for (const label of output.labels) {
                                const labelBytes = Utils.toArray(label, 'utf8');
                                resultWriter.writeVarIntNum(labelBytes.length);
                                resultWriter.write(labelBytes);
                            }
                        }
                        else {
                            resultWriter.writeVarIntNum(-1);
                        }
                    }
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'relinquishOutput': {
                    const args = {};
                    // Deserialize basket
                    const basketLength = paramsReader.readVarIntNum();
                    const basketBytes = paramsReader.read(basketLength);
                    args.basket = Utils.toUTF8(basketBytes);
                    // Deserialize outpoint
                    args.output = this.decodeOutpoint(paramsReader);
                    // Call the method
                    await this.wallet.relinquishOutput(args, originator);
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'getPublicKey': {
                    const args = {};
                    // Deserialize identityKey flag
                    const identityKeyFlag = paramsReader.readUInt8();
                    args.identityKey = identityKeyFlag === 1;
                    if (args.identityKey !== true) {
                        // Deserialize protocolID
                        args.protocolID = this.decodeProtocolID(paramsReader);
                        // Deserialize keyID
                        args.keyID = this.decodeString(paramsReader);
                        // Deserialize counterparty
                        args.counterparty = this.decodeCounterparty(paramsReader);
                        // Deserialize privilege parameters
                        const privilegedFlag = paramsReader.readInt8();
                        if (privilegedFlag === -1) {
                            args.privileged = undefined;
                        }
                        else {
                            args.privileged = privilegedFlag === 1;
                        }
                        const privilegedReasonLength = paramsReader.readInt8();
                        if (privilegedReasonLength !== -1) {
                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                        }
                        else {
                            args.privilegedReason = undefined;
                        }
                        // Deserialize forSelf
                        const forSelfFlag = paramsReader.readInt8();
                        if (forSelfFlag === -1) {
                            args.forSelf = undefined;
                        }
                        else {
                            args.forSelf = forSelfFlag === 1;
                        }
                    }
                    else {
                        // Deserialize privilege parameters
                        const privilegedFlag = paramsReader.readInt8();
                        if (privilegedFlag === -1) {
                            args.privileged = undefined;
                        }
                        else {
                            args.privileged = privilegedFlag === 1;
                        }
                        const privilegedReasonLength = paramsReader.readInt8();
                        if (privilegedReasonLength !== -1) {
                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                        }
                        else {
                            args.privilegedReason = undefined;
                        }
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const getPublicKeyResult = await this.wallet.getPublicKey(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    const publicKeyBytes = Utils.toArray(getPublicKeyResult.publicKey, 'hex');
                    responseWriter.write(publicKeyBytes);
                    return responseWriter.toArray();
                }
                case 'encrypt': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize plaintext
                    const plaintextLength = paramsReader.readVarIntNum();
                    args.plaintext = paramsReader.read(plaintextLength);
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const encryptResult = await this.wallet.encrypt(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(encryptResult.ciphertext);
                    return responseWriter.toArray();
                }
                case 'decrypt': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize ciphertext
                    const ciphertextLength = paramsReader.readVarIntNum();
                    args.ciphertext = paramsReader.read(ciphertextLength);
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const decryptResult = await this.wallet.decrypt(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(decryptResult.plaintext);
                    return responseWriter.toArray();
                }
                case 'createHmac': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize data
                    const dataLength = paramsReader.readVarIntNum();
                    args.data = paramsReader.read(dataLength);
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const createHmacResult = await this.wallet.createHmac(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(createHmacResult.hmac);
                    return responseWriter.toArray();
                }
                case 'verifyHmac': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize hmac
                    args.hmac = paramsReader.read(32);
                    // Deserialize data
                    const dataLength = paramsReader.readVarIntNum();
                    args.data = paramsReader.read(dataLength);
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    await this.wallet.verifyHmac(args, originator);
                    // Serialize the result (no data to return)
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'createSignature': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize data or hashToDirectlySign
                    const dataTypeFlag = paramsReader.readUInt8();
                    if (dataTypeFlag === 1) {
                        const dataLength = paramsReader.readVarIntNum();
                        args.data = paramsReader.read(dataLength);
                    }
                    else if (dataTypeFlag === 2) {
                        args.hashToDirectlySign = paramsReader.read(32);
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const createSignatureResult = await this.wallet.createSignature(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(createSignatureResult.signature);
                    return responseWriter.toArray();
                }
                case 'verifySignature': {
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Deserialize forSelf
                    const forSelfFlag = paramsReader.readInt8();
                    if (forSelfFlag === -1) {
                        args.forSelf = undefined;
                    }
                    else {
                        args.forSelf = forSelfFlag === 1;
                    }
                    // Deserialize signature
                    const signatureLength = paramsReader.readVarIntNum();
                    args.signature = paramsReader.read(signatureLength);
                    // Deserialize data or hashToDirectlyVerify
                    const dataTypeFlag = paramsReader.readUInt8();
                    if (dataTypeFlag === 1) {
                        const dataLength = paramsReader.readVarIntNum();
                        args.data = paramsReader.read(dataLength);
                    }
                    else if (dataTypeFlag === 2) {
                        args.hashToDirectlyVerify = paramsReader.read(32);
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    await this.wallet.verifySignature(args, originator);
                    // Serialize the result (no data to return)
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'isAuthenticated': {
                    // No parameters to deserialize
                    // Call the method
                    const isAuthenticatedResult = await this.wallet.isAuthenticated({}, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.writeUInt8(isAuthenticatedResult.authenticated ? 1 : 0);
                    return responseWriter.toArray();
                }
                case 'waitForAuthentication': {
                    // No parameters to deserialize
                    // Call the method
                    await this.wallet.waitForAuthentication({}, originator);
                    // Serialize the result (authenticated is always true)
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'getHeight': {
                    // No parameters to deserialize
                    // Call the method
                    const getHeightResult = await this.wallet.getHeight({}, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.writeVarIntNum(getHeightResult.height);
                    return responseWriter.toArray();
                }
                case 'getHeaderForHeight': {
                    const args = {};
                    // Deserialize height
                    args.height = paramsReader.readVarIntNum();
                    // Call the method
                    const getHeaderResult = await this.wallet.getHeaderForHeight(args, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    const headerBytes = Utils.toArray(getHeaderResult.header, 'hex');
                    responseWriter.write(headerBytes);
                    return responseWriter.toArray();
                }
                case 'getNetwork': {
                    // No parameters to deserialize
                    // Call the method
                    const getNetworkResult = await this.wallet.getNetwork({}, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.writeUInt8(getNetworkResult.network === 'mainnet' ? 0 : 1);
                    return responseWriter.toArray();
                }
                case 'getVersion': {
                    // No parameters to deserialize
                    // Call the method
                    const getVersionResult = await this.wallet.getVersion({}, originator);
                    // Serialize the result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    const versionBytes = Utils.toArray(getVersionResult.version, 'utf8');
                    responseWriter.write(versionBytes);
                    return responseWriter.toArray();
                }
                case 'revealCounterpartyKeyLinkage': {
                    const args = {};
                    // Read privileged parameters
                    const privilegedFlag = paramsReader.readInt8();
                    if (privilegedFlag === -1) {
                        args.privileged = undefined;
                    }
                    else {
                        args.privileged = privilegedFlag === 1;
                    }
                    const privilegedReasonLength = paramsReader.readInt8();
                    if (privilegedReasonLength === -1) {
                        args.privilegedReason = undefined;
                    }
                    else {
                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                    }
                    // Read counterparty public key
                    const counterpartyBytes = paramsReader.read(33);
                    args.counterparty = Utils.toHex(counterpartyBytes);
                    // Read verifier public key
                    const verifierBytes = paramsReader.read(33);
                    args.verifier = Utils.toHex(verifierBytes);
                    // Call the method
                    const revealResult = await this.wallet.revealCounterpartyKeyLinkage(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // Write prover
                    resultWriter.write(Utils.toArray(revealResult.prover, 'hex'));
                    // Write verifier
                    resultWriter.write(Utils.toArray(revealResult.verifier, 'hex'));
                    // Write counterparty
                    resultWriter.write(Utils.toArray(revealResult.counterparty, 'hex'));
                    // Write revelationTime
                    const revelationTimeBytes = Utils.toArray(revealResult.revelationTime, 'utf8');
                    resultWriter.writeVarIntNum(revelationTimeBytes.length);
                    resultWriter.write(revelationTimeBytes);
                    // Write encryptedLinkage
                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);
                    resultWriter.write(revealResult.encryptedLinkage);
                    // Write encryptedLinkageProof
                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);
                    resultWriter.write(revealResult.encryptedLinkageProof);
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'revealSpecificKeyLinkage': {
                    // Deserialize key-related parameters and privileged parameters
                    const args = this.decodeKeyRelatedParams(paramsReader);
                    // Read verifier public key
                    const verifierBytes = paramsReader.read(33);
                    args.verifier = Utils.toHex(verifierBytes);
                    // Call the method
                    const revealResult = await this.wallet.revealSpecificKeyLinkage(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // Write prover
                    resultWriter.write(Utils.toArray(revealResult.prover, 'hex'));
                    // Write verifier
                    resultWriter.write(Utils.toArray(revealResult.verifier, 'hex'));
                    // Write counterparty
                    resultWriter.write(Utils.toArray(revealResult.counterparty, 'hex'));
                    // Write securityLevel
                    resultWriter.writeUInt8(revealResult.protocolID[0]);
                    // Write protocol string
                    const protocolBytesOut = Utils.toArray(revealResult.protocolID[1], 'utf8');
                    resultWriter.writeVarIntNum(protocolBytesOut.length);
                    resultWriter.write(protocolBytesOut);
                    // Write keyID
                    const keyIDBytesOut = Utils.toArray(revealResult.keyID, 'utf8');
                    resultWriter.writeVarIntNum(keyIDBytesOut.length);
                    resultWriter.write(keyIDBytesOut);
                    // Write encryptedLinkage
                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);
                    resultWriter.write(revealResult.encryptedLinkage);
                    // Write encryptedLinkageProof
                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);
                    resultWriter.write(revealResult.encryptedLinkageProof);
                    // Write proofType
                    resultWriter.writeUInt8(revealResult.proofType);
                    // Return success code and result
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'acquireCertificate': {
                    const args = {};
                    // Read args.type
                    const typeBytes = paramsReader.read(32);
                    args.type = Utils.toBase64(typeBytes);
                    // args.certifier
                    const certifierBytes = paramsReader.read(33);
                    args.certifier = Utils.toHex(certifierBytes);
                    // Read fields
                    const fieldsLength = paramsReader.readVarIntNum();
                    args.fields = {};
                    for (let i = 0; i < fieldsLength; i++) {
                        const fieldNameLength = paramsReader.readVarIntNum();
                        const fieldNameBytes = paramsReader.read(fieldNameLength);
                        const fieldName = Utils.toUTF8(fieldNameBytes);
                        const fieldValueLength = paramsReader.readVarIntNum();
                        const fieldValueBytes = paramsReader.read(fieldValueLength);
                        const fieldValue = Utils.toUTF8(fieldValueBytes);
                        args.fields[fieldName] = fieldValue;
                    }
                    // Read privileged parameters
                    const privilegedFlag = paramsReader.readInt8();
                    if (privilegedFlag === -1) {
                        args.privileged = undefined;
                    }
                    else {
                        args.privileged = privilegedFlag === 1;
                    }
                    const privilegedReasonLength = paramsReader.readInt8();
                    if (privilegedReasonLength === -1) {
                        args.privilegedReason = undefined;
                    }
                    else {
                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                    }
                    // Read acquisitionProtocol
                    const acquisitionProtocolFlag = paramsReader.readUInt8();
                    args.acquisitionProtocol =
                        acquisitionProtocolFlag === 1 ? 'direct' : 'issuance';
                    if (args.acquisitionProtocol === 'direct') {
                        // args.serialNumber
                        const serialNumberBytes = paramsReader.read(32);
                        args.serialNumber = Utils.toBase64(serialNumberBytes);
                        // args.revocationOutpoint
                        args.revocationOutpoint = this.decodeOutpoint(paramsReader);
                        // args.signature
                        const signatureLength = paramsReader.readVarIntNum();
                        const signatureBytes = paramsReader.read(signatureLength);
                        args.signature = Utils.toHex(signatureBytes);
                        // args.keyringRevealer
                        const keyringRevealerIdentifier = paramsReader.readUInt8();
                        if (keyringRevealerIdentifier === 11) {
                            args.keyringRevealer = 'certifier';
                        }
                        else {
                            const keyringRevealerBytes = [keyringRevealerIdentifier].concat(paramsReader.read(32));
                            args.keyringRevealer = Utils.toHex(keyringRevealerBytes);
                        }
                        // args.keyringForSubject
                        const keyringEntriesLength = paramsReader.readVarIntNum();
                        args.keyringForSubject = {};
                        for (let i = 0; i < keyringEntriesLength; i++) {
                            const fieldKeyLength = paramsReader.readVarIntNum();
                            const fieldKeyBytes = paramsReader.read(fieldKeyLength);
                            const fieldKey = Utils.toUTF8(fieldKeyBytes);
                            const fieldValueLength = paramsReader.readVarIntNum();
                            const fieldValueBytes = paramsReader.read(fieldValueLength);
                            const fieldValue = Utils.toBase64(fieldValueBytes);
                            args.keyringForSubject[fieldKey] = fieldValue;
                        }
                    }
                    else {
                        // args.certifierUrl
                        const certifierUrlLength = paramsReader.readVarIntNum();
                        const certifierUrlBytes = paramsReader.read(certifierUrlLength);
                        args.certifierUrl = Utils.toUTF8(certifierUrlBytes);
                    }
                    // Call the method
                    const acquireResult = await this.wallet.acquireCertificate(args, originator);
                    // Serialize the certificate (assuming Certificate class is available)
                    const cert = new Certificate_js_1.default(acquireResult.type, acquireResult.serialNumber, acquireResult.subject, acquireResult.certifier, acquireResult.revocationOutpoint, acquireResult.fields, acquireResult.signature);
                    const certBin = cert.toBinary();
                    // Return success code and certificate binary
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(certBin);
                    return responseWriter.toArray();
                }
                case 'listCertificates': {
                    const args = {};
                    // Read certifiers
                    const certifiersLength = paramsReader.readVarIntNum();
                    args.certifiers = [];
                    for (let i = 0; i < certifiersLength; i++) {
                        const certifierBytes = paramsReader.read(33);
                        args.certifiers.push(Utils.toHex(certifierBytes));
                    }
                    // Read types
                    const typesLength = paramsReader.readVarIntNum();
                    args.types = [];
                    for (let i = 0; i < typesLength; i++) {
                        const typeBytes = paramsReader.read(32);
                        args.types.push(Utils.toBase64(typeBytes));
                    }
                    // Read limit and offset
                    const limit = paramsReader.readVarIntNum();
                    if (limit >= 0) {
                        args.limit = limit;
                    }
                    else {
                        args.limit = undefined;
                    }
                    const offset = paramsReader.readVarIntNum();
                    if (offset >= 0) {
                        args.offset = offset;
                    }
                    else {
                        args.offset = undefined;
                    }
                    // Read privileged parameters
                    const privilegedFlag = paramsReader.readInt8();
                    if (privilegedFlag === -1) {
                        args.privileged = undefined;
                    }
                    else {
                        args.privileged = privilegedFlag === 1;
                    }
                    const privilegedReasonLength = paramsReader.readInt8();
                    if (privilegedReasonLength === -1) {
                        args.privilegedReason = undefined;
                    }
                    else {
                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                    }
                    // Call the method
                    const listResult = await this.wallet.listCertificates(args, originator);
                    // Serialize the result
                    const resultWriter = new Utils.Writer();
                    // totalCertificates
                    resultWriter.writeVarIntNum(listResult.totalCertificates);
                    // certificates
                    for (const cert of listResult.certificates) {
                        const certificate = new Certificate_js_1.default(cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);
                        const certBin = certificate.toBinary();
                        // Write certificate binary length and data
                        resultWriter.writeVarIntNum(certBin.length);
                        resultWriter.write(certBin);
                    }
                    // Return the response
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'proveCertificate': {
                    const args = {};
                    // Read certificate
                    const cert = {};
                    // Read type
                    const typeBytes = paramsReader.read(32);
                    cert.type = Utils.toBase64(typeBytes);
                    // Read subject
                    const subjectBytes = paramsReader.read(33);
                    cert.subject = Utils.toHex(subjectBytes);
                    // Read serialNumber
                    const serialNumberBytes = paramsReader.read(32);
                    cert.serialNumber = Utils.toBase64(serialNumberBytes);
                    // Read certifier
                    const certifierBytes = paramsReader.read(33);
                    cert.certifier = Utils.toHex(certifierBytes);
                    // Read revocationOutpoint
                    cert.revocationOutpoint = this.decodeOutpoint(paramsReader);
                    // Read signature
                    const signatureLength = paramsReader.readVarIntNum();
                    const signatureBytes = paramsReader.read(signatureLength);
                    cert.signature = Utils.toHex(signatureBytes);
                    // Read fields
                    const fieldsLength = paramsReader.readVarIntNum();
                    cert.fields = {};
                    for (let i = 0; i < fieldsLength; i++) {
                        const fieldNameLength = paramsReader.readVarIntNum();
                        const fieldNameBytes = paramsReader.read(fieldNameLength);
                        const fieldName = Utils.toUTF8(fieldNameBytes);
                        const fieldValueLength = paramsReader.readVarIntNum();
                        const fieldValueBytes = paramsReader.read(fieldValueLength);
                        const fieldValue = Utils.toUTF8(fieldValueBytes);
                        cert.fields[fieldName] = fieldValue;
                    }
                    args.certificate = cert;
                    // Read fields to reveal
                    const fieldsToRevealLength = paramsReader.readVarIntNum();
                    args.fieldsToReveal = [];
                    for (let i = 0; i < fieldsToRevealLength; i++) {
                        const fieldNameLength = paramsReader.readVarIntNum();
                        const fieldNameBytes = paramsReader.read(fieldNameLength);
                        const fieldName = Utils.toUTF8(fieldNameBytes);
                        args.fieldsToReveal.push(fieldName);
                    }
                    // Read verifier
                    const verifierBytes = paramsReader.read(33);
                    args.verifier = Utils.toHex(verifierBytes);
                    // Read privileged parameters
                    const privilegedFlag = paramsReader.readInt8();
                    if (privilegedFlag === -1) {
                        args.privileged = undefined;
                    }
                    else {
                        args.privileged = privilegedFlag === 1;
                    }
                    const privilegedReasonLength = paramsReader.readInt8();
                    if (privilegedReasonLength === -1) {
                        args.privilegedReason = undefined;
                    }
                    else {
                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
                    }
                    // Call the method
                    const proveResult = await this.wallet.proveCertificate(args, originator);
                    // Serialize keyringForVerifier
                    const resultWriter = new Utils.Writer();
                    const keyringEntries = Object.entries(proveResult.keyringForVerifier);
                    resultWriter.writeVarIntNum(keyringEntries.length);
                    for (const [fieldName, fieldValue] of keyringEntries) {
                        const fieldNameBytes = Utils.toArray(fieldName, 'utf8');
                        resultWriter.writeVarIntNum(fieldNameBytes.length);
                        resultWriter.write(fieldNameBytes);
                        const fieldValueBytes = Utils.toArray(fieldValue, 'base64');
                        resultWriter.writeVarIntNum(fieldValueBytes.length);
                        resultWriter.write(fieldValueBytes);
                    }
                    // Return the response
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(resultWriter.toArray());
                    return responseWriter.toArray();
                }
                case 'relinquishCertificate': {
                    const args = {};
                    // Read type
                    const typeBytes = paramsReader.read(32);
                    args.type = Utils.toBase64(typeBytes);
                    // Read serialNumber
                    const serialNumberBytes = paramsReader.read(32);
                    args.serialNumber = Utils.toBase64(serialNumberBytes);
                    // Read certifier
                    const certifierBytes = paramsReader.read(33);
                    args.certifier = Utils.toHex(certifierBytes);
                    // Call the method
                    await this.wallet.relinquishCertificate(args, originator);
                    // Return success code
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    return responseWriter.toArray();
                }
                case 'discoverByIdentityKey': {
                    const args = {};
                    // Read identityKey
                    const identityKeyBytes = paramsReader.read(33);
                    args.identityKey = Utils.toHex(identityKeyBytes);
                    // Read limit and offset
                    const limit = paramsReader.readVarIntNum();
                    if (limit >= 0) {
                        args.limit = limit;
                    }
                    else {
                        args.limit = undefined;
                    }
                    const offset = paramsReader.readVarIntNum();
                    if (offset >= 0) {
                        args.offset = offset;
                    }
                    else {
                        args.offset = undefined;
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const discoverResult = await this.wallet.discoverByIdentityKey(args, originator);
                    // Serialize the result
                    const result = this.serializeDiscoveryResult(discoverResult);
                    // Return the response
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(result);
                    return responseWriter.toArray();
                }
                case 'discoverByAttributes': {
                    const args = {};
                    // Read attributes
                    const attributesLength = paramsReader.readVarIntNum();
                    args.attributes = {};
                    for (let i = 0; i < attributesLength; i++) {
                        const fieldKeyLength = paramsReader.readVarIntNum();
                        const fieldKeyBytes = paramsReader.read(fieldKeyLength);
                        const fieldKey = Utils.toUTF8(fieldKeyBytes);
                        const fieldValueLength = paramsReader.readVarIntNum();
                        const fieldValueBytes = paramsReader.read(fieldValueLength);
                        const fieldValue = Utils.toUTF8(fieldValueBytes);
                        args.attributes[fieldKey] = fieldValue;
                    }
                    // Read limit and offset
                    const limit = paramsReader.readVarIntNum();
                    if (limit >= 0) {
                        args.limit = limit;
                    }
                    else {
                        args.limit = undefined;
                    }
                    const offset = paramsReader.readVarIntNum();
                    if (offset >= 0) {
                        args.offset = offset;
                    }
                    else {
                        args.offset = undefined;
                    }
                    // Deserialize seekPermission
                    const seekPermission = paramsReader.readInt8();
                    if (seekPermission >= 0) {
                        args.seekPermission = seekPermission === 1;
                    }
                    else {
                        args.seekPermission = undefined;
                    }
                    // Call the method
                    const discoverResult = await this.wallet.discoverByAttributes(args, originator);
                    // Serialize the result
                    const result = this.serializeDiscoveryResult(discoverResult);
                    // Return the response
                    const responseWriter = new Utils.Writer();
                    responseWriter.writeUInt8(0); // errorByte = 0
                    responseWriter.write(result);
                    return responseWriter.toArray();
                }
                default:
                    throw new Error(`Method ${callName} not implemented`);
            }
        }
        catch (err) {
            const responseWriter = new Utils.Writer();
            responseWriter.writeUInt8(typeof err.code === 'number' ? err.code : 1); // errorCode = 1 (generic error)
            // Serialize the error message
            const errorMessage = typeof err.message === 'string' ? err.message : 'Unknown error';
            const errorMessageBytes = Utils.toArray(errorMessage, 'utf8');
            responseWriter.writeVarIntNum(errorMessageBytes.length);
            responseWriter.write(errorMessageBytes);
            // Serialize the stack trace
            const stackTrace = typeof err.stack === 'string' ? err.stack : '';
            const stackTraceBytes = Utils.toArray(stackTrace, 'utf8');
            responseWriter.writeVarIntNum(stackTraceBytes.length);
            responseWriter.write(stackTraceBytes);
            return responseWriter.toArray();
        }
    }
    decodeProtocolID(reader) {
        const securityLevel = reader.readUInt8();
        const protocolLength = reader.readVarIntNum();
        const protocolBytes = reader.read(protocolLength);
        const protocolString = Utils.toUTF8(protocolBytes);
        return [securityLevel, protocolString];
    }
    decodeString(reader) {
        const length = reader.readVarIntNum();
        const bytes = reader.read(length);
        return Utils.toUTF8(bytes);
    }
    decodeCounterparty(reader) {
        const counterpartyFlag = reader.readUInt8();
        if (counterpartyFlag === 11) {
            return 'self';
        }
        else if (counterpartyFlag === 12) {
            return 'anyone';
        }
        else if (counterpartyFlag === 0) {
            return undefined;
        }
        else {
            const counterpartyRemainingBytes = reader.read(32);
            return Utils.toHex([counterpartyFlag, ...counterpartyRemainingBytes]);
        }
    }
    serializeDiscoveryResult(discoverResult) {
        const resultWriter = new Utils.Writer();
        // totalCertificates
        resultWriter.writeVarIntNum(discoverResult.totalCertificates);
        // certificates
        for (const cert of discoverResult.certificates) {
            // Serialize certificate binary
            const certificate = new Certificate_js_1.default(cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);
            const certBin = certificate.toBinary();
            // Write certificate binary length and data
            resultWriter.writeVarIntNum(certBin.length);
            resultWriter.write(certBin);
            // Serialize certifierInfo
            const nameBytes = Utils.toArray(cert.certifierInfo.name, 'utf8');
            resultWriter.writeVarIntNum(nameBytes.length);
            resultWriter.write(nameBytes);
            const iconUrlBytes = Utils.toArray(cert.certifierInfo.iconUrl, 'utf8');
            resultWriter.writeVarIntNum(iconUrlBytes.length);
            resultWriter.write(iconUrlBytes);
            const descriptionBytes = Utils.toArray(cert.certifierInfo.description, 'utf8');
            resultWriter.writeVarIntNum(descriptionBytes.length);
            resultWriter.write(descriptionBytes);
            resultWriter.writeUInt8(cert.certifierInfo.trust);
            // Serialize publiclyRevealedKeyring
            const publicKeyringEntries = Object.entries(cert.publiclyRevealedKeyring);
            resultWriter.writeVarIntNum(publicKeyringEntries.length);
            for (const [fieldName, fieldValue] of publicKeyringEntries) {
                const fieldNameBytes = Utils.toArray(fieldName, 'utf8');
                resultWriter.writeVarIntNum(fieldNameBytes.length);
                resultWriter.write(fieldNameBytes);
                const fieldValueBytes = Utils.toArray(fieldValue, 'base64');
                resultWriter.writeVarIntNum(fieldValueBytes.length);
                resultWriter.write(fieldValueBytes);
            }
            // Serialize decryptedFields
            const decryptedFieldEntries = Object.entries(cert.decryptedFields);
            resultWriter.writeVarIntNum(decryptedFieldEntries.length);
            for (const [fieldName, fieldValue] of decryptedFieldEntries) {
                const fieldNameBytes = Utils.toArray(fieldName, 'utf8');
                resultWriter.writeVarIntNum(fieldNameBytes.length);
                resultWriter.write(fieldNameBytes);
                const fieldValueBytes = Utils.toArray(fieldValue, 'utf8');
                resultWriter.writeVarIntNum(fieldValueBytes.length);
                resultWriter.write(fieldValueBytes);
            }
        }
        return resultWriter.toArray();
    }
    decodeKeyRelatedParams(paramsReader) {
        const args = {};
        // Read protocolID
        args.protocolID = this.decodeProtocolID(paramsReader);
        // Read keyID
        const keyIDLength = paramsReader.readVarIntNum();
        const keyIDBytes = paramsReader.read(keyIDLength);
        args.keyID = Utils.toUTF8(keyIDBytes);
        // Read counterparty
        args.counterparty = this.decodeCounterparty(paramsReader);
        // Read privileged parameters
        const privilegedFlag = paramsReader.readInt8();
        if (privilegedFlag === -1) {
            args.privileged = undefined;
        }
        else {
            args.privileged = privilegedFlag === 1;
        }
        const privilegedReasonLength = paramsReader.readInt8();
        if (privilegedReasonLength === -1) {
            args.privilegedReason = undefined;
        }
        else {
            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);
            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);
        }
        return args;
    }
}
exports.default = WalletWireProcessor;

},{"../../auth/certificates/Certificate.js":4,"../../primitives/utils.js":62,"./WalletWireCalls.js":118}],120:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Wallet_interfaces_js_1 = require("../Wallet.interfaces.js");
const Certificate_js_1 = __importDefault(require("../../auth/certificates/Certificate.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
const WalletWireCalls_js_1 = __importDefault(require("./WalletWireCalls.js"));
const WalletError_js_1 = require("../WalletError.js");
/**
 * A way to make remote calls to a wallet over a wallet wire.
 */
class WalletWireTransceiver {
    constructor(wire) {
        this.wire = wire;
    }
    async transmit(call, originator = '', params = []) {
        const frameWriter = new Utils.Writer();
        frameWriter.writeUInt8(WalletWireCalls_js_1.default[call]);
        const originatorArray = Utils.toArray(originator, 'utf8');
        frameWriter.writeUInt8(originatorArray.length);
        frameWriter.write(originatorArray);
        if (params.length > 0) {
            frameWriter.write(params);
        }
        const frame = frameWriter.toArray();
        const result = await this.wire.transmitToWallet(frame);
        const resultReader = new Utils.Reader(result);
        const errorByte = resultReader.readUInt8();
        if (errorByte === 0) {
            const resultFrame = resultReader.read();
            return resultFrame;
        }
        else {
            // Deserialize the error message length
            const errorMessageLength = resultReader.readVarIntNum();
            const errorMessageBytes = resultReader.read(errorMessageLength);
            const errorMessage = Utils.toUTF8(errorMessageBytes);
            // Deserialize the stack trace length
            const stackTraceLength = resultReader.readVarIntNum();
            const stackTraceBytes = resultReader.read(stackTraceLength);
            const stackTrace = Utils.toUTF8(stackTraceBytes);
            // Construct a custom wallet error
            const e = new WalletError_js_1.WalletError(errorMessage, errorByte, stackTrace);
            throw e;
        }
    }
    async createAction(args, originator) {
        const paramWriter = new Utils.Writer();
        // Serialize description
        const descriptionBytes = Utils.toArray(args.description, 'utf8');
        paramWriter.writeVarIntNum(descriptionBytes.length);
        paramWriter.write(descriptionBytes);
        // input BEEF
        if (args.inputBEEF != null) {
            paramWriter.writeVarIntNum(args.inputBEEF.length);
            paramWriter.write(args.inputBEEF);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize inputs
        if (args.inputs != null) {
            paramWriter.writeVarIntNum(args.inputs.length);
            for (const input of args.inputs) {
                // outpoint
                paramWriter.write(this.encodeOutpoint(input.outpoint));
                // unlockingScript / unlockingScriptLength
                if (input.unlockingScript != null && input.unlockingScript !== '') {
                    const unlockingScriptBytes = Utils.toArray(input.unlockingScript, 'hex');
                    paramWriter.writeVarIntNum(unlockingScriptBytes.length);
                    paramWriter.write(unlockingScriptBytes);
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                    paramWriter.writeVarIntNum(input.unlockingScriptLength ?? 0);
                }
                // inputDescription
                const inputDescriptionBytes = Utils.toArray(input.inputDescription, 'utf8');
                paramWriter.writeVarIntNum(inputDescriptionBytes.length);
                paramWriter.write(inputDescriptionBytes);
                // sequenceNumber
                if (typeof input.sequenceNumber === 'number') {
                    paramWriter.writeVarIntNum(input.sequenceNumber);
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                }
            }
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize outputs
        if (args.outputs != null) {
            paramWriter.writeVarIntNum(args.outputs.length);
            for (const output of args.outputs) {
                // lockingScript
                const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');
                paramWriter.writeVarIntNum(lockingScriptBytes.length);
                paramWriter.write(lockingScriptBytes);
                // satoshis
                paramWriter.writeVarIntNum(output.satoshis);
                // outputDescription
                const outputDescriptionBytes = Utils.toArray(output.outputDescription, 'utf8');
                paramWriter.writeVarIntNum(outputDescriptionBytes.length);
                paramWriter.write(outputDescriptionBytes);
                // basket
                if (output.basket != null && output.basket !== '') {
                    const basketBytes = Utils.toArray(output.basket, 'utf8');
                    paramWriter.writeVarIntNum(basketBytes.length);
                    paramWriter.write(basketBytes);
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                }
                // customInstructions
                if (output.customInstructions != null && output.customInstructions !== '') {
                    const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');
                    paramWriter.writeVarIntNum(customInstructionsBytes.length);
                    paramWriter.write(customInstructionsBytes);
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                }
                // tags
                if (output.tags != null) {
                    paramWriter.writeVarIntNum(output.tags.length);
                    for (const tag of output.tags) {
                        const tagBytes = Utils.toArray(tag, 'utf8');
                        paramWriter.writeVarIntNum(tagBytes.length);
                        paramWriter.write(tagBytes);
                    }
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                }
            }
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize lockTime
        if (typeof args.lockTime === 'number') {
            paramWriter.writeVarIntNum(args.lockTime);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize version
        if (typeof args.version === 'number') {
            paramWriter.writeVarIntNum(args.version);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize labels
        if (args.labels != null) {
            paramWriter.writeVarIntNum(args.labels.length);
            for (const label of args.labels) {
                const labelBytes = Utils.toArray(label, 'utf8');
                paramWriter.writeVarIntNum(labelBytes.length);
                paramWriter.write(labelBytes);
            }
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize options
        if (args.options != null) {
            paramWriter.writeInt8(1); // options present
            // signAndProcess
            if (typeof args.options.signAndProcess === 'boolean') {
                paramWriter.writeInt8(args.options.signAndProcess ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // acceptDelayedBroadcast
            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {
                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // trustSelf
            if (args.options.trustSelf === 'known') {
                paramWriter.writeInt8(1);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // knownTxids
            if (args.options.knownTxids != null) {
                paramWriter.writeVarIntNum(args.options.knownTxids.length);
                for (const txid of args.options.knownTxids) {
                    const txidBytes = Utils.toArray(txid, 'hex');
                    paramWriter.write(txidBytes);
                }
            }
            else {
                paramWriter.writeVarIntNum(-1);
            }
            // returnTXIDOnly
            if (typeof args.options.returnTXIDOnly === 'boolean') {
                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // noSend
            if (typeof args.options.noSend === 'boolean') {
                paramWriter.writeInt8(args.options.noSend ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // noSendChange
            if (args.options.noSendChange != null) {
                paramWriter.writeVarIntNum(args.options.noSendChange.length);
                for (const outpoint of args.options.noSendChange) {
                    paramWriter.write(this.encodeOutpoint(outpoint));
                }
            }
            else {
                paramWriter.writeVarIntNum(-1);
            }
            // sendWith
            if (args.options.sendWith != null) {
                paramWriter.writeVarIntNum(args.options.sendWith.length);
                for (const txid of args.options.sendWith) {
                    const txidBytes = Utils.toArray(txid, 'hex');
                    paramWriter.write(txidBytes);
                }
            }
            else {
                paramWriter.writeVarIntNum(-1);
            }
            // randomizeOutputs
            if (typeof args.options.randomizeOutputs === 'boolean') {
                paramWriter.writeInt8(args.options.randomizeOutputs ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
        }
        else {
            paramWriter.writeInt8(0); // options not present
        }
        // Transmit and parse response
        const result = await this.transmit('createAction', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const response = {};
        // Parse txid
        const txidFlag = resultReader.readInt8();
        if (txidFlag === 1) {
            const txidBytes = resultReader.read(32);
            response.txid = Utils.toHex(txidBytes);
        }
        // Parse tx
        const txFlag = resultReader.readInt8();
        if (txFlag === 1) {
            const txLength = resultReader.readVarIntNum();
            response.tx = resultReader.read(txLength);
        }
        // Parse noSendChange
        const noSendChangeLength = resultReader.readVarIntNum();
        if (noSendChangeLength >= 0) {
            response.noSendChange = [];
            for (let i = 0; i < noSendChangeLength; i++) {
                const outpoint = this.readOutpoint(resultReader);
                response.noSendChange.push(outpoint);
            }
        }
        // Parse sendWithResults
        const sendWithResultsLength = resultReader.readVarIntNum();
        if (sendWithResultsLength >= 0) {
            response.sendWithResults = [];
            for (let i = 0; i < sendWithResultsLength; i++) {
                const txidBytes = resultReader.read(32);
                const txid = Utils.toHex(txidBytes);
                const statusCode = resultReader.readInt8();
                let status = 'unproven';
                if (statusCode === 1)
                    status = 'unproven';
                else if (statusCode === 2)
                    status = 'sending';
                else if (statusCode === 3)
                    status = 'failed';
                response.sendWithResults.push({ txid, status });
            }
        }
        // Parse signableTransaction
        const signableTransactionFlag = resultReader.readInt8();
        if (signableTransactionFlag === 1) {
            const txLength = resultReader.readVarIntNum();
            const tx = resultReader.read(txLength);
            const referenceLength = resultReader.readVarIntNum();
            const referenceBytes = resultReader.read(referenceLength);
            response.signableTransaction = {
                tx,
                reference: Utils.toBase64(referenceBytes)
            };
        }
        return response;
    }
    async signAction(args, originator) {
        const paramWriter = new Utils.Writer();
        // Serialize spends
        const spendIndexes = Object.keys(args.spends);
        paramWriter.writeVarIntNum(spendIndexes.length);
        for (const index of spendIndexes) {
            paramWriter.writeVarIntNum(Number(index));
            const spend = args.spends[Number(index)];
            // unlockingScript
            const unlockingScriptBytes = Utils.toArray(spend.unlockingScript, 'hex');
            paramWriter.writeVarIntNum(unlockingScriptBytes.length);
            paramWriter.write(unlockingScriptBytes);
            // sequenceNumber
            if (typeof spend.sequenceNumber === 'number') {
                paramWriter.writeVarIntNum(spend.sequenceNumber);
            }
            else {
                paramWriter.writeVarIntNum(-1);
            }
        }
        // Serialize reference
        const referenceBytes = Utils.toArray(args.reference, 'base64');
        paramWriter.writeVarIntNum(referenceBytes.length);
        paramWriter.write(referenceBytes);
        // Serialize options
        if (args.options != null) {
            paramWriter.writeInt8(1); // options present
            // acceptDelayedBroadcast
            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {
                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // returnTXIDOnly
            if (typeof args.options.returnTXIDOnly === 'boolean') {
                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // noSend
            if (typeof args.options.noSend === 'boolean') {
                paramWriter.writeInt8(args.options.noSend ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
            // sendWith
            if (args.options.sendWith != null) {
                paramWriter.writeVarIntNum(args.options.sendWith.length);
                for (const txid of args.options.sendWith) {
                    const txidBytes = Utils.toArray(txid, 'hex');
                    paramWriter.write(txidBytes);
                }
            }
            else {
                paramWriter.writeVarIntNum(-1);
            }
        }
        else {
            paramWriter.writeInt8(0); // options not present
        }
        // Transmit and parse response
        const result = await this.transmit('signAction', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const response = {};
        // Parse txid
        const txidFlag = resultReader.readInt8();
        if (txidFlag === 1) {
            const txidBytes = resultReader.read(32);
            response.txid = Utils.toHex(txidBytes);
        }
        // Parse tx
        const txFlag = resultReader.readInt8();
        if (txFlag === 1) {
            const txLength = resultReader.readVarIntNum();
            response.tx = resultReader.read(txLength);
        }
        // Parse sendWithResults
        const sendWithResultsLength = resultReader.readVarIntNum();
        if (sendWithResultsLength >= 0) {
            response.sendWithResults = [];
            for (let i = 0; i < sendWithResultsLength; i++) {
                const txidBytes = resultReader.read(32);
                const txid = Utils.toHex(txidBytes);
                const statusCode = resultReader.readInt8();
                let status = 'unproven';
                if (statusCode === 1)
                    status = 'unproven';
                else if (statusCode === 2)
                    status = 'sending';
                else if (statusCode === 3)
                    status = 'failed';
                response.sendWithResults.push({ txid, status });
            }
        }
        return response;
    }
    async abortAction(args, originator) {
        await this.transmit('abortAction', originator, Utils.toArray(args.reference, 'base64'));
        return { aborted: true };
    }
    async listActions(args, originator) {
        const paramWriter = new Utils.Writer();
        // Serialize labels
        paramWriter.writeVarIntNum(args.labels.length);
        for (const label of args.labels) {
            const labelBytes = Utils.toArray(label, 'utf8');
            paramWriter.writeVarIntNum(labelBytes.length);
            paramWriter.write(labelBytes);
        }
        // Serialize labelQueryMode
        if (args.labelQueryMode === 'any') {
            paramWriter.writeInt8(1);
        }
        else if (args.labelQueryMode === 'all') {
            paramWriter.writeInt8(2);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        // Serialize include options
        const includeOptions = [
            args.includeLabels,
            args.includeInputs,
            args.includeInputSourceLockingScripts,
            args.includeInputUnlockingScripts,
            args.includeOutputs,
            args.includeOutputLockingScripts
        ];
        for (const option of includeOptions) {
            if (typeof option === 'boolean') {
                paramWriter.writeInt8(option ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
        }
        // Serialize limit and offset
        if (typeof args.limit === 'number') {
            paramWriter.writeVarIntNum(args.limit);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        if (typeof args.offset === 'number') {
            paramWriter.writeVarIntNum(args.offset);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        // Transmit and parse response
        const result = await this.transmit('listActions', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const totalActions = resultReader.readVarIntNum();
        const actions = [];
        for (let i = 0; i < totalActions; i++) {
            // Parse action fields
            const txidBytes = resultReader.read(32);
            const txid = Utils.toHex(txidBytes);
            const satoshis = resultReader.readVarIntNum();
            const statusCode = resultReader.readInt8();
            let status;
            switch (statusCode) {
                case 1:
                    status = 'completed';
                    break;
                case 2:
                    status = 'unprocessed';
                    break;
                case 3:
                    status = 'sending';
                    break;
                case 4:
                    status = 'unproven';
                    break;
                case 5:
                    status = 'unsigned';
                    break;
                case 6:
                    status = 'nosend';
                    break;
                case 7:
                    status = 'nonfinal';
                    break;
                case 8:
                    status = 'failed';
                    break;
                default:
                    throw new Error(`Unknown status code: ${statusCode}`);
            }
            const isOutgoing = resultReader.readInt8() === 1;
            const descriptionLength = resultReader.readVarIntNum();
            const descriptionBytes = resultReader.read(descriptionLength);
            const description = Utils.toUTF8(descriptionBytes);
            const action = {
                txid,
                satoshis,
                status,
                isOutgoing,
                description,
                version: 0,
                lockTime: 0
            };
            // Parse labels
            const labelsLength = resultReader.readVarIntNum();
            if (labelsLength >= 0) {
                action.labels = [];
                for (let j = 0; j < labelsLength; j++) {
                    const labelLength = resultReader.readVarIntNum();
                    const labelBytes = resultReader.read(labelLength);
                    action.labels.push(Utils.toUTF8(labelBytes));
                }
            }
            // Parse version and lockTime
            action.version = resultReader.readVarIntNum();
            action.lockTime = resultReader.readVarIntNum();
            // Parse inputs
            const inputsLength = resultReader.readVarIntNum();
            if (inputsLength >= 0) {
                action.inputs = [];
                for (let k = 0; k < inputsLength; k++) {
                    const sourceOutpoint = this.readOutpoint(resultReader);
                    const sourceSatoshis = resultReader.readVarIntNum();
                    // sourceLockingScript
                    const sourceLockingScriptLength = resultReader.readVarIntNum();
                    let sourceLockingScript;
                    if (sourceLockingScriptLength >= 0) {
                        const sourceLockingScriptBytes = resultReader.read(sourceLockingScriptLength);
                        sourceLockingScript = Utils.toHex(sourceLockingScriptBytes);
                    }
                    // unlockingScript
                    const unlockingScriptLength = resultReader.readVarIntNum();
                    let unlockingScript;
                    if (unlockingScriptLength >= 0) {
                        const unlockingScriptBytes = resultReader.read(unlockingScriptLength);
                        unlockingScript = Utils.toHex(unlockingScriptBytes);
                    }
                    // inputDescription
                    const inputDescriptionLength = resultReader.readVarIntNum();
                    const inputDescriptionBytes = resultReader.read(inputDescriptionLength);
                    const inputDescription = Utils.toUTF8(inputDescriptionBytes);
                    // sequenceNumber
                    const sequenceNumber = resultReader.readVarIntNum();
                    action.inputs.push({
                        sourceOutpoint,
                        sourceSatoshis,
                        sourceLockingScript,
                        unlockingScript,
                        inputDescription,
                        sequenceNumber
                    });
                }
            }
            // Parse outputs
            const outputsLength = resultReader.readVarIntNum();
            if (outputsLength >= 0) {
                action.outputs = [];
                for (let l = 0; l < outputsLength; l++) {
                    const outputIndex = resultReader.readVarIntNum();
                    const satoshis = resultReader.readVarIntNum();
                    // lockingScript
                    const lockingScriptLength = resultReader.readVarIntNum();
                    let lockingScript;
                    if (lockingScriptLength >= 0) {
                        const lockingScriptBytes = resultReader.read(lockingScriptLength);
                        lockingScript = Utils.toHex(lockingScriptBytes);
                    }
                    const spendable = resultReader.readInt8() === 1;
                    // outputDescription
                    const outputDescriptionLength = resultReader.readVarIntNum();
                    const outputDescriptionBytes = resultReader.read(outputDescriptionLength);
                    const outputDescription = Utils.toUTF8(outputDescriptionBytes);
                    // basket
                    const basketLength = resultReader.readVarIntNum();
                    let basket;
                    if (basketLength >= 0) {
                        const basketBytes = resultReader.read(basketLength);
                        basket = Utils.toUTF8(basketBytes);
                    }
                    // tags
                    const tagsLength = resultReader.readVarIntNum();
                    const tags = [];
                    if (tagsLength >= 0) {
                        for (let m = 0; m < tagsLength; m++) {
                            const tagLength = resultReader.readVarIntNum();
                            const tagBytes = resultReader.read(tagLength);
                            tags.push(Utils.toUTF8(tagBytes));
                        }
                    }
                    // customInstructions
                    const customInstructionsLength = resultReader.readVarIntNum();
                    let customInstructions;
                    if (customInstructionsLength >= 0) {
                        const customInstructionsBytes = resultReader.read(customInstructionsLength);
                        customInstructions = Utils.toUTF8(customInstructionsBytes);
                    }
                    action.outputs.push({
                        outputIndex,
                        satoshis,
                        lockingScript,
                        spendable,
                        outputDescription,
                        basket,
                        tags,
                        customInstructions
                    });
                }
            }
            actions.push(action);
        }
        return {
            totalActions,
            actions
        };
    }
    async internalizeAction(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.writeVarIntNum(args.tx.length);
        paramWriter.write(args.tx);
        paramWriter.writeVarIntNum(args.outputs.length);
        for (const out of args.outputs) {
            paramWriter.writeVarIntNum(out.outputIndex);
            if (out.protocol === 'wallet payment') {
                if (out.paymentRemittance == null) {
                    throw new Error('Payment remittance is required for wallet payment');
                }
                paramWriter.writeUInt8(1);
                paramWriter.write(Utils.toArray(out.paymentRemittance.senderIdentityKey, 'hex'));
                const derivationPrefixAsArray = Utils.toArray(out.paymentRemittance.derivationPrefix, 'base64');
                paramWriter.writeVarIntNum(derivationPrefixAsArray.length);
                paramWriter.write(derivationPrefixAsArray);
                const derivationSuffixAsArray = Utils.toArray(out.paymentRemittance.derivationSuffix, 'base64');
                paramWriter.writeVarIntNum(derivationSuffixAsArray.length);
                paramWriter.write(derivationSuffixAsArray);
            }
            else {
                paramWriter.writeUInt8(2);
                const basketAsArray = Utils.toArray(out.insertionRemittance?.basket, 'utf8');
                paramWriter.writeVarIntNum(basketAsArray.length);
                paramWriter.write(basketAsArray);
                if (typeof out.insertionRemittance?.customInstructions === 'string' && out.insertionRemittance.customInstructions !== '') {
                    const customInstructionsAsArray = Utils.toArray(out.insertionRemittance.customInstructions, 'utf8');
                    paramWriter.writeVarIntNum(customInstructionsAsArray.length);
                    paramWriter.write(customInstructionsAsArray);
                }
                else {
                    paramWriter.writeVarIntNum(-1);
                }
                if (typeof out.insertionRemittance?.tags === 'object') {
                    paramWriter.writeVarIntNum(out.insertionRemittance.tags.length);
                    for (const tag of out.insertionRemittance.tags) {
                        const tagAsArray = Utils.toArray(tag, 'utf8');
                        paramWriter.writeVarIntNum(tagAsArray.length);
                        paramWriter.write(tagAsArray);
                    }
                }
                else {
                    paramWriter.writeVarIntNum(0);
                }
            }
        }
        if (typeof args.labels === 'object') {
            paramWriter.writeVarIntNum(args.labels.length);
            for (const l of args.labels) {
                const labelAsArray = Utils.toArray(l, 'utf8');
                paramWriter.writeVarIntNum(labelAsArray.length);
                paramWriter.write(labelAsArray);
            }
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        const descriptionAsArray = Utils.toArray(args.description);
        paramWriter.writeVarIntNum(descriptionAsArray.length);
        paramWriter.write(descriptionAsArray);
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        await this.transmit('internalizeAction', originator, paramWriter.toArray());
        return { accepted: true };
    }
    async listOutputs(args, originator) {
        const paramWriter = new Utils.Writer();
        const basketAsArray = Utils.toArray(args.basket, 'utf8');
        paramWriter.writeVarIntNum(basketAsArray.length);
        paramWriter.write(basketAsArray);
        if (typeof args.tags === 'object') {
            paramWriter.writeVarIntNum(args.tags.length);
            for (const tag of args.tags) {
                const tagAsArray = Utils.toArray(tag, 'utf8');
                paramWriter.writeVarIntNum(tagAsArray.length);
                paramWriter.write(tagAsArray);
            }
        }
        else {
            paramWriter.writeVarIntNum(0);
        }
        if (args.tagQueryMode === 'all') {
            paramWriter.writeInt8(1);
        }
        else if (args.tagQueryMode === 'any') {
            paramWriter.writeInt8(2);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (args.include === 'locking scripts') {
            paramWriter.writeInt8(1);
        }
        else if (args.include === 'entire transactions') {
            paramWriter.writeInt8(2);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (typeof args.includeCustomInstructions === 'boolean') {
            paramWriter.writeInt8(args.includeCustomInstructions ? 1 : 0);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (typeof args.includeTags === 'boolean') {
            paramWriter.writeInt8(args.includeTags ? 1 : 0);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (typeof args.includeLabels === 'boolean') {
            paramWriter.writeInt8(args.includeLabels ? 1 : 0);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (typeof args.limit === 'number') {
            paramWriter.writeVarIntNum(args.limit);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        if (typeof args.offset === 'number') {
            paramWriter.writeVarIntNum(args.offset);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        const result = await this.transmit('listOutputs', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const totalOutputs = resultReader.readVarIntNum();
        const beefLength = resultReader.readVarIntNum();
        let BEEF;
        if (beefLength >= 0) {
            BEEF = resultReader.read(beefLength);
        }
        const outputs = [];
        for (let i = 0; i < totalOutputs; i++) {
            const outpoint = this.readOutpoint(resultReader);
            const satoshis = resultReader.readVarIntNum();
            const output = {
                spendable: true,
                outpoint,
                satoshis
            };
            const scriptLength = resultReader.readVarIntNum();
            if (scriptLength >= 0) {
                output.lockingScript = Utils.toHex(resultReader.read(scriptLength));
            }
            const customInstructionsLength = resultReader.readVarIntNum();
            if (customInstructionsLength >= 0) {
                output.customInstructions = Utils.toUTF8(resultReader.read(customInstructionsLength));
            }
            const tagsLength = resultReader.readVarIntNum();
            if (tagsLength !== -1) {
                const tags = [];
                for (let i = 0; i < tagsLength; i++) {
                    const tagLength = resultReader.readVarIntNum();
                    tags.push(Utils.toUTF8(resultReader.read(tagLength)));
                }
                output.tags = tags;
            }
            const labelsLength = resultReader.readVarIntNum();
            if (labelsLength !== -1) {
                const labels = [];
                for (let i = 0; i < labelsLength; i++) {
                    const labelLength = resultReader.readVarIntNum();
                    labels.push(Utils.toUTF8(resultReader.read(labelLength)));
                }
                output.labels = labels;
            }
            outputs.push(output);
        }
        return {
            totalOutputs,
            BEEF,
            outputs
        };
    }
    async relinquishOutput(args, originator) {
        const paramWriter = new Utils.Writer();
        const basketAsArray = Utils.toArray(args.basket, 'utf8');
        paramWriter.writeVarIntNum(basketAsArray.length);
        paramWriter.write(basketAsArray);
        paramWriter.write(this.encodeOutpoint(args.output));
        await this.transmit('relinquishOutput', originator, paramWriter.toArray());
        return { relinquished: true };
    }
    encodeOutpoint(outpoint) {
        const writer = new Utils.Writer();
        const [txid, index] = outpoint.split('.');
        writer.write(Utils.toArray(txid, 'hex'));
        writer.writeVarIntNum(Number(index));
        return writer.toArray();
    }
    readOutpoint(reader) {
        const txid = Utils.toHex(reader.read(32));
        const index = reader.readVarIntNum();
        return `${txid}.${index}`;
    }
    async getPublicKey(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.writeUInt8(args.identityKey ? 1 : 0);
        if (!args.identityKey) {
            paramWriter.write(this.encodeKeyRelatedParams(args.protocolID ?? (args.protocolID = [Wallet_interfaces_js_1.SecurityLevels.Silent, 'default']), args.keyID ?? (args.keyID = ''), args.counterparty, args.privileged, args.privilegedReason));
            if (typeof args.forSelf === 'boolean') {
                paramWriter.writeInt8(args.forSelf ? 1 : 0);
            }
            else {
                paramWriter.writeInt8(-1);
            }
        }
        else {
            paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        const result = await this.transmit('getPublicKey', originator, paramWriter.toArray());
        return {
            publicKey: Utils.toHex(result)
        };
    }
    async revealCounterpartyKeyLinkage(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));
        paramWriter.write(Utils.toArray(args.counterparty, 'hex'));
        paramWriter.write(Utils.toArray(args.verifier, 'hex'));
        const result = await this.transmit('revealCounterpartyKeyLinkage', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const prover = Utils.toHex(resultReader.read(33));
        const verifier = Utils.toHex(resultReader.read(33));
        const counterparty = Utils.toHex(resultReader.read(33));
        const revelationTimeLength = resultReader.readVarIntNum();
        const revelationTime = Utils.toUTF8(resultReader.read(revelationTimeLength));
        const encryptedLinkageLength = resultReader.readVarIntNum();
        const encryptedLinkage = resultReader.read(encryptedLinkageLength);
        const encryptedLinkageProofLength = resultReader.readVarIntNum();
        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);
        return {
            prover,
            verifier,
            counterparty,
            revelationTime,
            encryptedLinkage,
            encryptedLinkageProof
        };
    }
    async revealSpecificKeyLinkage(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        paramWriter.write(Utils.toArray(args.verifier, 'hex'));
        const result = await this.transmit('revealSpecificKeyLinkage', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const prover = Utils.toHex(resultReader.read(33));
        const verifier = Utils.toHex(resultReader.read(33));
        const counterparty = Utils.toHex(resultReader.read(33));
        const securityLevel = resultReader.readUInt8();
        const protocolLength = resultReader.readVarIntNum();
        const protocol = Utils.toUTF8(resultReader.read(protocolLength));
        const keyIDLength = resultReader.readVarIntNum();
        const keyID = Utils.toUTF8(resultReader.read(keyIDLength));
        const encryptedLinkageLength = resultReader.readVarIntNum();
        const encryptedLinkage = resultReader.read(encryptedLinkageLength);
        const encryptedLinkageProofLength = resultReader.readVarIntNum();
        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);
        const proofType = resultReader.readUInt8();
        return {
            prover,
            verifier,
            counterparty,
            protocolID: [securityLevel, protocol],
            keyID,
            encryptedLinkage,
            encryptedLinkageProof,
            proofType
        };
    }
    async encrypt(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        paramWriter.writeVarIntNum(args.plaintext.length);
        paramWriter.write(args.plaintext);
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        return {
            ciphertext: await this.transmit('encrypt', originator, paramWriter.toArray())
        };
    }
    async decrypt(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        paramWriter.writeVarIntNum(args.ciphertext.length);
        paramWriter.write(args.ciphertext);
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        return {
            plaintext: await this.transmit('decrypt', originator, paramWriter.toArray())
        };
    }
    async createHmac(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        paramWriter.writeVarIntNum(args.data.length);
        paramWriter.write(args.data);
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        return {
            hmac: await this.transmit('createHmac', originator, paramWriter.toArray())
        };
    }
    async verifyHmac(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        paramWriter.write(args.hmac);
        paramWriter.writeVarIntNum(args.data.length);
        paramWriter.write(args.data);
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        await this.transmit('verifyHmac', originator, paramWriter.toArray());
        return { valid: true };
    }
    async createSignature(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        if (typeof args.data === 'object') {
            paramWriter.writeUInt8(1);
            paramWriter.writeVarIntNum(args.data.length);
            paramWriter.write(args.data);
        }
        else {
            paramWriter.writeUInt8(2);
            paramWriter.write(args.hashToDirectlySign ?? (args.hashToDirectlySign = []));
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        return {
            signature: await this.transmit('createSignature', originator, paramWriter.toArray())
        };
    }
    async verifySignature(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));
        if (typeof args.forSelf === 'boolean') {
            paramWriter.writeInt8(args.forSelf ? 1 : 0);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        paramWriter.writeVarIntNum(args.signature.length);
        paramWriter.write(args.signature);
        if (typeof args.data === 'object') {
            paramWriter.writeUInt8(1);
            paramWriter.writeVarIntNum(args.data.length);
            paramWriter.write(args.data);
        }
        else {
            paramWriter.writeUInt8(2);
            paramWriter.write(args.hashToDirectlyVerify ?? []);
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        await this.transmit('verifySignature', originator, paramWriter.toArray());
        return { valid: true };
    }
    encodeKeyRelatedParams(protocolID, keyID, counterparty, privileged, privilegedReason) {
        const paramWriter = new Utils.Writer();
        paramWriter.writeUInt8(protocolID[0]);
        const protocolAsArray = Utils.toArray(protocolID[1], 'utf8');
        paramWriter.writeVarIntNum(protocolAsArray.length);
        paramWriter.write(protocolAsArray);
        const keyIDAsArray = Utils.toArray(keyID, 'utf8');
        paramWriter.writeVarIntNum(keyIDAsArray.length);
        paramWriter.write(keyIDAsArray);
        if (typeof counterparty !== 'string') {
            paramWriter.writeUInt8(0);
        }
        else if (counterparty === 'self') {
            paramWriter.writeUInt8(11);
        }
        else if (counterparty === 'anyone') {
            paramWriter.writeUInt8(12);
        }
        else {
            paramWriter.write(Utils.toArray(counterparty, 'hex'));
        }
        paramWriter.write(this.encodePrivilegedParams(privileged, privilegedReason));
        return paramWriter.toArray();
    }
    async acquireCertificate(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(Utils.toArray(args.type, 'base64'));
        paramWriter.write(Utils.toArray(args.certifier, 'hex'));
        const fieldEntries = Object.entries(args.fields);
        paramWriter.writeVarIntNum(fieldEntries.length);
        for (const [key, value] of fieldEntries) {
            const keyAsArray = Utils.toArray(key, 'utf8');
            const valueAsArray = Utils.toArray(value, 'utf8');
            paramWriter.writeVarIntNum(keyAsArray.length);
            paramWriter.write(keyAsArray);
            paramWriter.writeVarIntNum(valueAsArray.length);
            paramWriter.write(valueAsArray);
        }
        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));
        paramWriter.writeUInt8(args.acquisitionProtocol === 'direct' ? 1 : 2);
        if (args.acquisitionProtocol === 'direct') {
            paramWriter.write(Utils.toArray(args.serialNumber, 'base64'));
            paramWriter.write(this.encodeOutpoint(args.revocationOutpoint ?? ''));
            const signatureAsArray = Utils.toArray(args.signature, 'hex');
            paramWriter.writeVarIntNum(signatureAsArray.length);
            paramWriter.write(signatureAsArray);
            const keyringRevealerAsArray = args.keyringRevealer !== 'certifier'
                ? Utils.toArray(args.keyringRevealer, 'hex')
                : [11];
            paramWriter.write(keyringRevealerAsArray);
            const keyringKeys = Object.keys(args.keyringForSubject ?? {});
            paramWriter.writeVarIntNum(keyringKeys.length);
            for (let i = 0; i < keyringKeys.length; i++) {
                const keyringKeysAsArray = Utils.toArray(keyringKeys[i], 'utf8');
                paramWriter.writeVarIntNum(keyringKeysAsArray.length);
                paramWriter.write(keyringKeysAsArray);
                const keyringForSubjectAsArray = Utils.toArray(args.keyringForSubject?.[keyringKeys[i]], 'base64');
                paramWriter.writeVarIntNum(keyringForSubjectAsArray.length);
                paramWriter.write(keyringForSubjectAsArray);
            }
        }
        else {
            const certifierUrlAsArray = Utils.toArray(args.certifierUrl, 'utf8');
            paramWriter.writeVarIntNum(certifierUrlAsArray.length);
            paramWriter.write(certifierUrlAsArray);
        }
        const result = await this.transmit('acquireCertificate', originator, paramWriter.toArray());
        const cert = Certificate_js_1.default.fromBinary(result);
        return {
            ...cert,
            signature: cert.signature
        };
    }
    encodePrivilegedParams(privileged, privilegedReason) {
        const paramWriter = new Utils.Writer();
        if (typeof privileged === 'boolean') {
            paramWriter.writeInt8(privileged ? 1 : 0);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        if (typeof privilegedReason === 'string') {
            const privilegedReasonAsArray = Utils.toArray(privilegedReason, 'utf8');
            paramWriter.writeInt8(privilegedReasonAsArray.length);
            paramWriter.write(privilegedReasonAsArray);
        }
        else {
            paramWriter.writeInt8(-1);
        }
        return paramWriter.toArray();
    }
    async listCertificates(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.writeVarIntNum(args.certifiers.length);
        for (let i = 0; i < args.certifiers.length; i++) {
            paramWriter.write(Utils.toArray(args.certifiers[i], 'hex'));
        }
        paramWriter.writeVarIntNum(args.types.length);
        for (let i = 0; i < args.types.length; i++) {
            paramWriter.write(Utils.toArray(args.types[i], 'base64'));
        }
        if (typeof args.limit === 'number') {
            paramWriter.writeVarIntNum(args.limit);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        if (typeof args.offset === 'number') {
            paramWriter.writeVarIntNum(args.offset);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));
        const result = await this.transmit('listCertificates', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const totalCertificates = resultReader.readVarIntNum();
        const certificates = [];
        for (let i = 0; i < totalCertificates; i++) {
            const certificateLength = resultReader.readVarIntNum();
            const certificateBin = resultReader.read(certificateLength);
            const cert = Certificate_js_1.default.fromBinary(certificateBin);
            certificates.push({
                ...cert,
                signature: cert.signature
            });
        }
        return {
            totalCertificates,
            certificates
        };
    }
    async proveCertificate(args, originator) {
        const paramWriter = new Utils.Writer();
        const typeAsArray = Utils.toArray(args.certificate.type, 'base64');
        paramWriter.write(typeAsArray);
        const subjectAsArray = Utils.toArray(args.certificate.subject, 'hex');
        paramWriter.write(subjectAsArray);
        const serialNumberAsArray = Utils.toArray(args.certificate.serialNumber, 'base64');
        paramWriter.write(serialNumberAsArray);
        const certifierAsArray = Utils.toArray(args.certificate.certifier, 'hex');
        paramWriter.write(certifierAsArray);
        const revocationOutpointAsArray = this.encodeOutpoint(args.certificate.revocationOutpoint ?? '');
        paramWriter.write(revocationOutpointAsArray);
        const signatureAsArray = Utils.toArray(args.certificate.signature, 'hex');
        paramWriter.writeVarIntNum(signatureAsArray.length);
        paramWriter.write(signatureAsArray);
        const fieldEntries = Object.entries(args.certificate.fields ?? {});
        paramWriter.writeVarIntNum(fieldEntries.length);
        for (const [key, value] of fieldEntries) {
            const keyAsArray = Utils.toArray(key, 'utf8');
            const valueAsArray = Utils.toArray(value, 'utf8');
            paramWriter.writeVarIntNum(keyAsArray.length);
            paramWriter.write(keyAsArray);
            paramWriter.writeVarIntNum(valueAsArray.length);
            paramWriter.write(valueAsArray);
        }
        paramWriter.writeVarIntNum(args.fieldsToReveal.length);
        for (const field of args.fieldsToReveal) {
            const fieldAsArray = Utils.toArray(field, 'utf8');
            paramWriter.writeVarIntNum(fieldAsArray.length);
            paramWriter.write(fieldAsArray);
        }
        paramWriter.write(Utils.toArray(args.verifier, 'hex'));
        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));
        const result = await this.transmit('proveCertificate', originator, paramWriter.toArray());
        const resultReader = new Utils.Reader(result);
        const numFields = resultReader.readVarIntNum();
        const keyringForVerifier = {};
        for (let i = 0; i < numFields; i++) {
            const fieldKeyLength = resultReader.readVarIntNum();
            const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLength));
            const fieldValueLength = resultReader.readVarIntNum();
            keyringForVerifier[fieldKey] = Utils.toBase64(resultReader.read(fieldValueLength));
        }
        return {
            keyringForVerifier
        };
    }
    async relinquishCertificate(args, originator) {
        const paramWriter = new Utils.Writer();
        const typeAsArray = Utils.toArray(args.type, 'base64');
        paramWriter.write(typeAsArray);
        const serialNumberAsArray = Utils.toArray(args.serialNumber, 'base64');
        paramWriter.write(serialNumberAsArray);
        const certifierAsArray = Utils.toArray(args.certifier, 'hex');
        paramWriter.write(certifierAsArray);
        await this.transmit('relinquishCertificate', originator, paramWriter.toArray());
        return { relinquished: true };
    }
    parseDiscoveryResult(result) {
        const resultReader = new Utils.Reader(result);
        const totalCertificates = resultReader.readVarIntNum();
        const certificates = [];
        for (let i = 0; i < totalCertificates; i++) {
            const certBinLen = resultReader.readVarIntNum();
            const certBin = resultReader.read(certBinLen);
            const cert = Certificate_js_1.default.fromBinary(certBin);
            const nameLength = resultReader.readVarIntNum();
            const name = Utils.toUTF8(resultReader.read(nameLength));
            const iconUrlLength = resultReader.readVarIntNum();
            const iconUrl = Utils.toUTF8(resultReader.read(iconUrlLength));
            const descriptionLength = resultReader.readVarIntNum();
            const description = Utils.toUTF8(resultReader.read(descriptionLength));
            const trust = resultReader.readUInt8();
            const publiclyRevealedKeyring = {};
            const numPublicKeyringEntries = resultReader.readVarIntNum();
            for (let j = 0; j < numPublicKeyringEntries; j++) {
                const fieldKeyLen = resultReader.readVarIntNum();
                const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLen));
                const fieldValueLen = resultReader.readVarIntNum();
                publiclyRevealedKeyring[fieldKey] = resultReader.read(fieldValueLen);
            }
            const decryptedFields = {};
            const numDecryptedFields = resultReader.readVarIntNum();
            for (let k = 0; k < numDecryptedFields; k++) {
                const fieldKeyLen = resultReader.readVarIntNum();
                const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLen));
                const fieldValueLen = resultReader.readVarIntNum();
                decryptedFields[fieldKey] = Utils.toUTF8(resultReader.read(fieldValueLen));
            }
            certificates.push({
                ...cert,
                signature: cert.signature,
                certifierInfo: { iconUrl, name, description, trust },
                publiclyRevealedKeyring,
                decryptedFields
            });
        }
        return {
            totalCertificates,
            certificates
        };
    }
    async discoverByIdentityKey(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.write(Utils.toArray(args.identityKey, 'hex'));
        if (typeof args.limit === 'number') {
            paramWriter.writeVarIntNum(args.limit);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        if (typeof args.offset === 'number') {
            paramWriter.writeVarIntNum(args.offset);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        const result = await this.transmit('discoverByIdentityKey', originator, paramWriter.toArray());
        return this.parseDiscoveryResult(result);
    }
    async discoverByAttributes(args, originator) {
        const paramWriter = new Utils.Writer();
        const attributeKeys = Object.keys(args.attributes);
        paramWriter.writeVarIntNum(attributeKeys.length);
        for (let i = 0; i < attributeKeys.length; i++) {
            paramWriter.writeVarIntNum(attributeKeys[i].length);
            paramWriter.write(Utils.toArray(attributeKeys[i], 'utf8'));
            paramWriter.writeVarIntNum(args.attributes[attributeKeys[i]].length);
            paramWriter.write(Utils.toArray(args.attributes[attributeKeys[i]], 'utf8'));
        }
        if (typeof args.limit === 'number') {
            paramWriter.writeVarIntNum(args.limit);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        if (typeof args.offset === 'number') {
            paramWriter.writeVarIntNum(args.offset);
        }
        else {
            paramWriter.writeVarIntNum(-1);
        }
        // Serialize seekPermission
        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'
            ? args.seekPermission
                ? 1
                : 0
            : -1);
        const result = await this.transmit('discoverByAttributes', originator, paramWriter.toArray());
        return this.parseDiscoveryResult(result);
    }
    async isAuthenticated(args, originator) {
        const result = await this.transmit('isAuthenticated', originator);
        // @ts-expect-error
        return { authenticated: result[0] === 1 };
    }
    async waitForAuthentication(args, originator) {
        await this.transmit('waitForAuthentication', originator);
        return { authenticated: true };
    }
    async getHeight(args, originator) {
        const result = await this.transmit('getHeight', originator);
        const resultReader = new Utils.Reader(result);
        return {
            height: resultReader.readVarIntNum()
        };
    }
    async getHeaderForHeight(args, originator) {
        const paramWriter = new Utils.Writer();
        paramWriter.writeVarIntNum(args.height);
        const header = await this.transmit('getHeaderForHeight', originator, paramWriter.toArray());
        return {
            header: Utils.toHex(header)
        };
    }
    async getNetwork(args, originator) {
        const net = await this.transmit('getNetwork', originator);
        return {
            network: net[0] === 0 ? 'mainnet' : 'testnet'
        };
    }
    async getVersion(args, originator) {
        const version = await this.transmit('getVersion', originator);
        return {
            version: Utils.toUTF8(version)
        };
    }
}
exports.default = WalletWireTransceiver;

},{"../../auth/certificates/Certificate.js":4,"../../primitives/utils.js":62,"../Wallet.interfaces.js":110,"../WalletError.js":112,"./WalletWireCalls.js":118}],121:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Random_js_1 = __importDefault(require("../../primitives/Random.js"));
const Utils = __importStar(require("../../primitives/utils.js"));
const WalletError_js_1 = require("../WalletError.js");
/**
 * Facilitates wallet operations over cross-document messaging.
 */
class XDMSubstrate {
    constructor(domain = '*') {
        if (typeof window !== 'object') {
            throw new Error('The XDM substrate requires a global window object.');
        }
        if (typeof window.postMessage !== 'function') {
            throw new Error('The window object does not seem to support postMessage calls.');
        }
        this.domain = domain;
    }
    async invoke(call, args) {
        return await new Promise((resolve, reject) => {
            const id = Utils.toBase64((0, Random_js_1.default)(12));
            const listener = (e) => {
                if (e.data.type !== 'CWI' ||
                    !e.isTrusted ||
                    e.data.id !== id ||
                    e.data.isInvocation === true) {
                    return;
                }
                if (typeof window.removeEventListener === 'function') {
                    window.removeEventListener('message', listener);
                }
                if (e.data.status === 'error') {
                    const err = new WalletError_js_1.WalletError(e.data.description, e.data.code);
                    reject(err);
                }
                else {
                    resolve(e.data.result);
                }
            };
            window.addEventListener('message', listener);
            window.parent.postMessage({
                type: 'CWI',
                isInvocation: true,
                id,
                call,
                args
            }, this.domain);
        });
    }
    async createAction(args) {
        return await this.invoke('createAction', args);
    }
    async signAction(args) {
        return await this.invoke('signAction', args);
    }
    async abortAction(args) {
        return await this.invoke('abortAction', args);
    }
    async listActions(args) {
        return await this.invoke('listActions', args);
    }
    async internalizeAction(args) {
        return await this.invoke('internalizeAction', args);
    }
    async listOutputs(args) {
        return await this.invoke('listOutputs', args);
    }
    async relinquishOutput(args) {
        return await this.invoke('relinquishOutput', args);
    }
    async getPublicKey(args) {
        return await this.invoke('getPublicKey', args);
    }
    async revealCounterpartyKeyLinkage(args) {
        return await this.invoke('revealCounterpartyKeyLinkage', args);
    }
    async revealSpecificKeyLinkage(args) {
        return await this.invoke('revealSpecificKeyLinkage', args);
    }
    async encrypt(args) {
        return await this.invoke('encrypt', args);
    }
    async decrypt(args) {
        return await this.invoke('decrypt', args);
    }
    async createHmac(args) {
        return await this.invoke('createHmac', args);
    }
    async verifyHmac(args) {
        return await this.invoke('verifyHmac', args);
    }
    async createSignature(args) {
        return await this.invoke('createSignature', args);
    }
    async verifySignature(args) {
        return await this.invoke('verifySignature', args);
    }
    async acquireCertificate(args) {
        return await this.invoke('acquireCertificate', args);
    }
    async listCertificates(args) {
        return await this.invoke('listCertificates', args);
    }
    async proveCertificate(args) {
        return await this.invoke('proveCertificate', args);
    }
    async relinquishCertificate(args) {
        return await this.invoke('relinquishCertificate', args);
    }
    async discoverByIdentityKey(args) {
        return await this.invoke('discoverByIdentityKey', args);
    }
    async discoverByAttributes(args) {
        return await this.invoke('discoverByAttributes', args);
    }
    async isAuthenticated(args) {
        return await this.invoke('isAuthenticated', args);
    }
    async waitForAuthentication(args) {
        return await this.invoke('waitForAuthentication', args);
    }
    async getHeight(args) {
        return await this.invoke('getHeight', args);
    }
    async getHeaderForHeight(args) {
        return await this.invoke('getHeaderForHeight', args);
    }
    async getNetwork(args) {
        return await this.invoke('getNetwork', args);
    }
    async getVersion(args) {
        return await this.invoke('getVersion', args);
    }
}
exports.default = XDMSubstrate;

},{"../../primitives/Random.js":55,"../../primitives/utils.js":62,"../WalletError.js":112}],122:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactNativeWebView = exports.HTTPWalletJSON = exports.HTTPWalletWire = exports.WalletWireProcessor = exports.WalletWireTransceiver = exports.XDM = exports.WindowCWISubstrate = void 0;
var window_CWI_js_1 = require("./window.CWI.js");
Object.defineProperty(exports, "WindowCWISubstrate", { enumerable: true, get: function () { return __importDefault(window_CWI_js_1).default; } });
var XDM_js_1 = require("./XDM.js");
Object.defineProperty(exports, "XDM", { enumerable: true, get: function () { return __importDefault(XDM_js_1).default; } });
__exportStar(require("./WalletWire.js"), exports);
__exportStar(require("./WalletWireCalls.js"), exports);
var WalletWireTransceiver_js_1 = require("./WalletWireTransceiver.js");
Object.defineProperty(exports, "WalletWireTransceiver", { enumerable: true, get: function () { return __importDefault(WalletWireTransceiver_js_1).default; } });
var WalletWireProcessor_js_1 = require("./WalletWireProcessor.js");
Object.defineProperty(exports, "WalletWireProcessor", { enumerable: true, get: function () { return __importDefault(WalletWireProcessor_js_1).default; } });
var HTTPWalletWire_js_1 = require("./HTTPWalletWire.js");
Object.defineProperty(exports, "HTTPWalletWire", { enumerable: true, get: function () { return __importDefault(HTTPWalletWire_js_1).default; } });
var HTTPWalletJSON_js_1 = require("./HTTPWalletJSON.js");
Object.defineProperty(exports, "HTTPWalletJSON", { enumerable: true, get: function () { return __importDefault(HTTPWalletJSON_js_1).default; } });
var ReactNativeWebView_js_1 = require("./ReactNativeWebView.js");
Object.defineProperty(exports, "ReactNativeWebView", { enumerable: true, get: function () { return __importDefault(ReactNativeWebView_js_1).default; } });

},{"./HTTPWalletJSON.js":114,"./HTTPWalletWire.js":115,"./ReactNativeWebView.js":116,"./WalletWire.js":117,"./WalletWireCalls.js":118,"./WalletWireProcessor.js":119,"./WalletWireTransceiver.js":120,"./XDM.js":121,"./window.CWI.js":124}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toOriginHeader = void 0;
function toOriginHeader(originator, fallbackScheme = 'http') {
    // If the caller already gave us a scheme, assume it’s fine
    if (/^[a-z][a-z0-9+.-]*:\/\//i.test(originator)) {
        try {
            return new URL(originator).origin; // trims any path/query
        }
        catch { /* fall through to fix-up */ }
    }
    // Otherwise, prepend the fallback scheme and validate
    try {
        return new URL(`${fallbackScheme}://${originator}`).origin;
    }
    catch {
        throw new Error(`Invalid originator value: ${originator}`);
    }
}
exports.toOriginHeader = toOriginHeader;

},{}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Facilitates wallet operations over the window.CWI interface.
 */
class WindowCWISubstrate {
    constructor() {
        if (typeof window !== 'object') {
            throw new Error('The window.CWI substrate requires a global window object.');
        }
        if (typeof window.CWI !== 'object') {
            throw new Error('The window.CWI interface does not appear to be bound to the window object.');
        }
        this.CWI = window.CWI; // Binding CWI to prevent changes
    }
    async createAction(args, originator) {
        return await this.CWI.createAction(args, originator);
    }
    async signAction(args, originator) {
        return await this.CWI.signAction(args, originator);
    }
    async abortAction(args, originator) {
        return await this.CWI.abortAction(args, originator);
    }
    async listActions(args, originator) {
        return await this.CWI.listActions(args, originator);
    }
    async internalizeAction(args, originator) {
        return await this.CWI.internalizeAction(args, originator);
    }
    async listOutputs(args, originator) {
        return await this.CWI.listOutputs(args, originator);
    }
    async relinquishOutput(args, originator) {
        return await this.CWI.relinquishOutput(args, originator);
    }
    async getPublicKey(args, originator) {
        return await this.CWI.getPublicKey(args, originator);
    }
    async revealCounterpartyKeyLinkage(args, originator) {
        return await this.CWI.revealCounterpartyKeyLinkage(args, originator);
    }
    async revealSpecificKeyLinkage(args, originator) {
        return await this.CWI.revealSpecificKeyLinkage(args, originator);
    }
    async encrypt(args, originator) {
        return await this.CWI.encrypt(args, originator);
    }
    async decrypt(args, originator) {
        return await this.CWI.decrypt(args, originator);
    }
    async createHmac(args, originator) {
        return await this.CWI.createHmac(args, originator);
    }
    async verifyHmac(args, originator) {
        return await this.CWI.verifyHmac(args, originator);
    }
    async createSignature(args, originator) {
        return await this.CWI.createSignature(args, originator);
    }
    async verifySignature(args, originator) {
        return await this.CWI.verifySignature(args, originator);
    }
    async acquireCertificate(args, originator) {
        return await this.CWI.acquireCertificate(args, originator);
    }
    async listCertificates(args, originator) {
        return await this.CWI.listCertificates(args, originator);
    }
    async proveCertificate(args, originator) {
        return await this.CWI.proveCertificate(args, originator);
    }
    async relinquishCertificate(args, originator) {
        return await this.CWI.relinquishCertificate(args, originator);
    }
    async discoverByIdentityKey(args, originator) {
        return await this.CWI.discoverByIdentityKey(args, originator);
    }
    async discoverByAttributes(args, originator) {
        return await this.CWI.discoverByAttributes(args, originator);
    }
    async isAuthenticated(args, originator) {
        return await this.CWI.isAuthenticated(args, originator);
    }
    async waitForAuthentication(args, originator) {
        return await this.CWI.waitForAuthentication(args, originator);
    }
    async getHeight(args, originator) {
        return await this.CWI.getHeight(args, originator);
    }
    async getHeaderForHeight(args, originator) {
        return await this.CWI.getHeaderForHeight(args, originator);
    }
    async getNetwork(args, originator) {
        return await this.CWI.getNetwork(args, originator);
    }
    async getVersion(args, originator) {
        return await this.CWI.getVersion(args, originator);
    }
}
exports.default = WindowCWISubstrate;

},{}],125:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":126,"./asn1/base":128,"./asn1/constants":132,"./asn1/decoders":134,"./asn1/encoders":137,"bn.js":139}],126:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":125,"inherits":324,"vm":433}],127:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":128,"buffer":185,"inherits":324}],128:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":127,"./node":129,"./reporter":130}],129:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":128,"minimalistic-assert":339}],130:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":324}],131:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":132}],132:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":131}],133:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":125,"inherits":324}],134:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":133,"./pem":135}],135:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":133,"buffer":185,"inherits":324}],136:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":125,"buffer":185,"inherits":324}],137:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":136,"./pem":138}],138:[function(require,module,exports){
var inherits = require('inherits');

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":136,"inherits":324}],139:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    this.length = num === 0 ? 1 : this.length;

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":144}],140:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = require('possible-typed-array-names');

var g = typeof globalThis === 'undefined' ? global : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
	var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			// @ts-expect-error
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"possible-typed-array-names":357}],141:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],142:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    this.length = num === 0 ? 1 : this.length;

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":144}],143:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":144}],144:[function(require,module,exports){

},{}],145:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":391}],146:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":145,"./ghash":150,"./incr32":151,"buffer-xor":188,"cipher-base":198,"inherits":324,"safe-buffer":391}],147:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":148,"./encrypter":149,"./modes/list.json":159}],148:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":145,"./authCipher":146,"./modes":158,"./streamCipher":161,"cipher-base":198,"evp_bytestokey":293,"inherits":324,"safe-buffer":391}],149:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":145,"./authCipher":146,"./modes":158,"./streamCipher":161,"cipher-base":198,"evp_bytestokey":293,"inherits":324,"safe-buffer":391}],150:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":391}],151:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],152:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":188}],153:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":188,"safe-buffer":391}],154:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":391}],155:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":391}],156:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":151,"buffer-xor":188,"safe-buffer":391}],157:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],158:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":152,"./cfb":153,"./cfb1":154,"./cfb8":155,"./ctr":156,"./ecb":157,"./list.json":159,"./ofb":160}],159:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],160:[function(require,module,exports){
(function (Buffer){(function (){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"buffer-xor":188}],161:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":145,"cipher-base":198,"inherits":324,"safe-buffer":391}],162:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":147,"browserify-aes/modes":158,"browserify-des":163,"browserify-des/modes":164,"evp_bytestokey":293}],163:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":198,"des.js":254,"inherits":324,"safe-buffer":391}],164:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],165:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var randomBytes = require('randombytes');
var Buffer = require('safe-buffer').Buffer;

function getr(priv) {
	var len = priv.modulus.byteLength();
	var r;
	do {
		r = new BN(randomBytes(len));
	} while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
	return r;
}

function blind(priv) {
	var r = getr(priv);
	var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
	return { blinder: blinder, unblinder: r.invm(priv.modulus) };
}

function crt(msg, priv) {
	var blinds = blind(priv);
	var len = priv.modulus.byteLength();
	var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
	var c1 = blinded.toRed(BN.mont(priv.prime1));
	var c2 = blinded.toRed(BN.mont(priv.prime2));
	var qinv = priv.coefficient;
	var p = priv.prime1;
	var q = priv.prime2;
	var m1 = c1.redPow(priv.exponent1).fromRed();
	var m2 = c2.redPow(priv.exponent2).fromRed();
	var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
	return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len);
}
crt.getr = getr;

module.exports = crt;

},{"bn.js":142,"randombytes":373,"safe-buffer":391}],166:[function(require,module,exports){
'use strict';

module.exports = require('./browser/algorithms.json');

},{"./browser/algorithms.json":167}],167:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],168:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],169:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var createHash = require('create-hash');
var stream = require('readable-stream');
var inherits = require('inherits');
var sign = require('./sign');
var verify = require('./verify');

var algorithms = require('./algorithms.json');
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});

function Sign(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Sign, stream.Writable);

Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Sign.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
  this.end();
  var hash = this._hash.digest();
  var sig = sign(hash, key, this._hashType, this._signType, this._tag);

  return enc ? sig.toString(enc) : sig;
};

function Verify(algorithm) {
  stream.Writable.call(this);

  var data = algorithms[algorithm];
  if (!data) { throw new Error('Unknown message digest'); }

  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Verify, stream.Writable);

Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};

Verify.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

  return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;

  this.end();
  var hash = this._hash.digest();
  return verify(sigBuffer, hash, key, this._signType, this._tag);
};

function createSign(algorithm) {
  return new Sign(algorithm);
}

function createVerify(algorithm) {
  return new Verify(algorithm);
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};

},{"./algorithms.json":167,"./sign":170,"./verify":171,"create-hash":202,"inherits":324,"readable-stream":182,"safe-buffer":391}],170:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var createHmac = require('create-hmac');
var crt = require('browserify-rsa');
var EC = require('elliptic').ec;
var BN = require('bn.js');
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');

var RSA_PKCS1_PADDING = 1;

function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong private key type'); }
    return dsaSign(hash, priv, hashType);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) { throw new Error('illegal or unsupported padding mode'); }

  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];
  while (hash.length + pad.length + 1 < len) { pad.push(0xff); }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) { pad.push(hash[i]); }

  var out = crt(pad, priv);
  return out;
}

function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + priv.curve.join('.')); }

  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);

  return Buffer.from(out.toDER());
}

function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);
  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }
  return toDER(r, s);
}

function toDER(r, s) {
  r = r.toArray();
  s = s.toArray();

  // Pad values
  if (r[0] & 0x80) { r = [0].concat(r); }
  if (s[0] & 0x80) { s = [0].concat(s); }

  var total = r.length + s.length + 4;
  var res = [
    0x30, total, 0x02, r.length
  ];
  res = res.concat(r, [0x02, s.length], s);
  return Buffer.from(res);
}

function getKey(x, q, hash, algo) {
  x = Buffer.from(x.toArray());
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length);
    x = Buffer.concat([zeros, x]);
  }
  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = Buffer.alloc(hlen);
  v.fill(1);
  var k = Buffer.alloc(hlen);
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return { k: k, v: v };
}

function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) { bits.ishrn(shift); }
  return bits;
}

function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = Buffer.from(bits.toArray());
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length);
    out = Buffer.concat([zeros, out]);
  }
  return out;
}

function makeKey(q, kv, algo) {
  var t;
  var k;

  do {
    t = Buffer.alloc(0);

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }

    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);

  return k;
}

function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}

module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;

},{"./curves.json":168,"bn.js":142,"browserify-rsa":165,"create-hmac":204,"elliptic":266,"parse-asn1":346,"safe-buffer":391}],171:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var BN = require('bn.js');
var EC = require('elliptic').ec;
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');

function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') { throw new Error('wrong public key type'); }
    return dsaVerify(sig, hash, pub);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }

  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum += 1;
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  pad = Buffer.from(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);

  sig = sig.redPow(new BN(pub.publicExponent));
  sig = Buffer.from(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) { out = 1; }

  i = -1;
  while (++i < len) { out |= sig[i] ^ pad[i]; }
  return out === 0;
}

function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) { throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')); }

  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;

  return curve.verify(hash, sig, pubkey);
}

function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q);
  return v.cmp(r) === 0;
}

function checkValue(b, q) {
  if (b.cmpn(0) <= 0) { throw new Error('invalid sig'); }
  if (b.cmp(q) >= 0) { throw new Error('invalid sig'); }
}

module.exports = verify;

},{"./curves.json":168,"bn.js":142,"elliptic":266,"parse-asn1":346,"safe-buffer":391}],172:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],173:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":175,"./_stream_writable":177,"core-util-is":199,"inherits":324,"process-nextick-args":358}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":176,"core-util-is":199,"inherits":324}],175:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":173,"./internal/streams/BufferList":178,"./internal/streams/destroy":179,"./internal/streams/stream":180,"_process":359,"core-util-is":199,"events":292,"inherits":324,"isarray":172,"process-nextick-args":358,"safe-buffer":181,"string_decoder/":183,"util":144}],176:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":173,"core-util-is":199,"inherits":324}],177:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":173,"./internal/streams/destroy":179,"./internal/streams/stream":180,"_process":359,"core-util-is":199,"inherits":324,"process-nextick-args":358,"safe-buffer":181,"timers":412,"util-deprecate":416}],178:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":181,"util":144}],179:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":358}],180:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":292}],181:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":185}],182:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":173,"./lib/_stream_passthrough.js":174,"./lib/_stream_readable.js":175,"./lib/_stream_transform.js":176,"./lib/_stream_writable.js":177}],183:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":184}],184:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"buffer":185,"dup":181}],185:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":141,"buffer":185,"ieee754":323}],186:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"buffer":185,"dup":181}],187:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183,"safe-buffer":186}],188:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185}],189:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],190:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

var $apply = require('./functionApply');
var $call = require('./functionCall');
var $reflectApply = require('./reflectApply');

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);

},{"./functionApply":192,"./functionCall":193,"./reflectApply":195,"function-bind":296}],191:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $apply = require('./functionApply');
var actualApply = require('./actualApply');

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};

},{"./actualApply":190,"./functionApply":192,"function-bind":296}],192:[function(require,module,exports){
'use strict';

/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;

},{}],193:[function(require,module,exports){
'use strict';

/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;

},{}],194:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $TypeError = require('es-errors/type');

var $call = require('./functionCall');
var $actualApply = require('./actualApply');

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};

},{"./actualApply":190,"./functionCall":193,"es-errors/type":289,"function-bind":296}],195:[function(require,module,exports){
'use strict';

/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

},{}],196:[function(require,module,exports){
'use strict';

var setFunctionLength = require('set-function-length');

var $defineProperty = require('es-define-property');

var callBindBasic = require('call-bind-apply-helpers');
var applyBind = require('call-bind-apply-helpers/applyBind');

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"call-bind-apply-helpers":194,"call-bind-apply-helpers/applyBind":191,"es-define-property":283,"set-function-length":393}],197:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBindBasic = require('call-bind-apply-helpers');

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};

},{"call-bind-apply-helpers":194,"get-intrinsic":297}],198:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var StringDecoder = require('string_decoder').StringDecoder;
var inherits = require('inherits');

function CipherBase(hashMode) {
	Transform.call(this);
	this.hashMode = typeof hashMode === 'string';
	if (this.hashMode) {
		this[hashMode] = this._finalOrDigest;
	} else {
		this['final'] = this._finalOrDigest;
	}
	if (this._final) {
		this.__final = this._final;
		this._final = null;
	}
	this._decoder = null;
	this._encoding = null;
}
inherits(CipherBase, Transform);

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
	&& typeof Uint8Array !== 'undefined'
	&& ArrayBuffer.isView
	&& (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

function toBuffer(data, encoding) {
	/*
	 * No need to do anything for exact instance
	 * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed
	 */
	if (data instanceof Buffer) {
		return data;
	}

	// Convert strings to Buffer
	if (typeof data === 'string') {
		return Buffer.from(data, encoding);
	}

	/*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */
	if (useArrayBuffer && ArrayBuffer.isView(data)) {
		// Bug in Node.js <6.3.1, which treats this as out-of-bounds
		if (data.byteLength === 0) {
			return Buffer.alloc(0);
		}

		var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
		/*
		 * Recheck result size, as offset/length doesn't work on Node.js <5.10
		 * We just go to Uint8Array case if this fails
		 */
		if (res.byteLength === data.byteLength) {
			return res;
		}
	}

	/*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */
	if (useUint8Array && data instanceof Uint8Array) {
		return Buffer.from(data);
	}

	/*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */
	if (
		Buffer.isBuffer(data)
			&& data.constructor
			&& typeof data.constructor.isBuffer === 'function'
			&& data.constructor.isBuffer(data)
	) {
		return Buffer.from(data);
	}

	throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	var bufferData = toBuffer(data, inputEnc); // asserts correct input type
	var outData = this._update(bufferData);
	if (this.hashMode) {
		return this;
	}

	if (outputEnc) {
		outData = this._toString(outData, outputEnc);
	}

	return outData;
};

CipherBase.prototype.setAutoPadding = function () {};
CipherBase.prototype.getAuthTag = function () {
	throw new Error('trying to get auth tag in unsupported state');
};

CipherBase.prototype.setAuthTag = function () {
	throw new Error('trying to set auth tag in unsupported state');
};

CipherBase.prototype.setAAD = function () {
	throw new Error('trying to set aad in unsupported state');
};

CipherBase.prototype._transform = function (data, _, next) {
	var err;
	try {
		if (this.hashMode) {
			this._update(data);
		} else {
			this.push(this._update(data));
		}
	} catch (e) {
		err = e;
	} finally {
		next(err);
	}
};
CipherBase.prototype._flush = function (done) {
	var err;
	try {
		this.push(this.__final());
	} catch (e) {
		err = e;
	}

	done(err);
};
CipherBase.prototype._finalOrDigest = function (outputEnc) {
	var outData = this.__final() || Buffer.alloc(0);
	if (outputEnc) {
		outData = this._toString(outData, outputEnc, true);
	}
	return outData;
};

CipherBase.prototype._toString = function (value, enc, fin) {
	if (!this._decoder) {
		this._decoder = new StringDecoder(enc);
		this._encoding = enc;
	}

	if (this._encoding !== enc) {
		throw new Error('can’t switch encodings');
	}

	var out = this._decoder.write(value);
	if (fin) {
		out += this._decoder.end();
	}

	return out;
};

module.exports = CipherBase;

},{"inherits":324,"safe-buffer":391,"stream":406,"string_decoder":187}],199:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":185}],200:[function(require,module,exports){
(function (Buffer){(function (){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":201,"buffer":185,"elliptic":266}],201:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"buffer":144,"dup":139}],202:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":198,"inherits":324,"md5.js":336,"ripemd160":390,"sha.js":395}],203:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":336}],204:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":205,"cipher-base":198,"create-hash/md5":203,"inherits":324,"ripemd160":390,"safe-buffer":391,"sha.js":395}],205:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":198,"inherits":324,"safe-buffer":391}],206:[function(require,module,exports){
'use strict';

// eslint-disable-next-line no-multi-assign
exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');

// eslint-disable-next-line no-multi-assign
exports.createHash = exports.Hash = require('create-hash');

// eslint-disable-next-line no-multi-assign
exports.createHmac = exports.Hmac = require('create-hmac');

var algos = require('browserify-sign/algos');
var algoKeys = Object.keys(algos);
var hashes = [
	'sha1',
	'sha224',
	'sha256',
	'sha384',
	'sha512',
	'md5',
	'rmd160'
].concat(algoKeys);

exports.getHashes = function () {
	return hashes;
};

var p = require('pbkdf2');
exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;

var aes = require('browserify-cipher');

exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;

var dh = require('diffie-hellman');

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;

var sign = require('browserify-sign');

exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;

exports.createECDH = require('create-ecdh');

var publicEncrypt = require('public-encrypt');

exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt;

// the least I can do is make error messages for the rest of the node.js/crypto api.
// [
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error('sorry, ' + name + ' is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
//   };
// });

var rf = require('randomfill');

exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;

exports.createCredentials = function () {
	throw new Error('sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify');
};

exports.constants = {
	DH_CHECK_P_NOT_SAFE_PRIME: 2,
	DH_CHECK_P_NOT_PRIME: 1,
	DH_UNABLE_TO_CHECK_GENERATOR: 4,
	DH_NOT_SUITABLE_GENERATOR: 8,
	NPN_ENABLED: 1,
	ALPN_ENABLED: 1,
	RSA_PKCS1_PADDING: 1,
	RSA_SSLV23_PADDING: 2,
	RSA_NO_PADDING: 3,
	RSA_PKCS1_OAEP_PADDING: 4,
	RSA_X931_PADDING: 5,
	RSA_PKCS1_PSS_PADDING: 6,
	POINT_CONVERSION_COMPRESSED: 2,
	POINT_CONVERSION_UNCOMPRESSED: 4,
	POINT_CONVERSION_HYBRID: 6
};

},{"browserify-cipher":162,"browserify-sign":169,"browserify-sign/algos":166,"create-ecdh":200,"create-hash":202,"create-hmac":204,"diffie-hellman":260,"pbkdf2":207,"public-encrypt":360,"randombytes":373,"randomfill":374}],207:[function(require,module,exports){
'use strict';

exports.pbkdf2 = require('./lib/async');
exports.pbkdf2Sync = require('./lib/sync');

},{"./lib/async":208,"./lib/sync":211}],208:[function(require,module,exports){
(function (global){(function (){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var sync = require('./sync');
var toBuffer = require('./to-buffer');

var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
	sha: 'SHA-1',
	'sha-1': 'SHA-1',
	sha1: 'SHA-1',
	sha256: 'SHA-256',
	'sha-256': 'SHA-256',
	sha384: 'SHA-384',
	'sha-384': 'SHA-384',
	'sha-512': 'SHA-512',
	sha512: 'SHA-512'
};
var checks = [];
var nextTick;
function getNextTick() {
	if (nextTick) {
		return nextTick;
	}
	if (global.process && global.process.nextTick) {
		nextTick = global.process.nextTick;
	} else if (global.queueMicrotask) {
		nextTick = global.queueMicrotask;
	} else if (global.setImmediate) {
		nextTick = global.setImmediate;
	} else {
		nextTick = global.setTimeout;
	}
	return nextTick;
}
function browserPbkdf2(password, salt, iterations, length, algo) {
	return subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']).then(function (key) {
		return subtle.deriveBits({
			name: 'PBKDF2',
			salt: salt,
			iterations: iterations,
			hash: {
				name: algo
			}
		}, key, length << 3);
	}).then(function (res) {
		return Buffer.from(res);
	});
}
function checkNative(algo) {
	if (global.process && !global.process.browser) {
		return Promise.resolve(false);
	}
	if (!subtle || !subtle.importKey || !subtle.deriveBits) {
		return Promise.resolve(false);
	}
	if (checks[algo] !== undefined) {
		return checks[algo];
	}
	ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
	var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
		.then(
			function () { return true; },
			function () { return false; }
		);
	checks[algo] = prom;
	return prom;
}

function resolvePromise(promise, callback) {
	promise.then(function (out) {
		getNextTick()(function () {
			callback(null, out);
		});
	}, function (e) {
		getNextTick()(function () {
			callback(e);
		});
	});
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
	if (typeof digest === 'function') {
		callback = digest;
		digest = undefined;
	}

	digest = digest || 'sha1';
	var algo = toBrowser[digest.toLowerCase()];

	if (!algo || typeof global.Promise !== 'function') {
		getNextTick()(function () {
			var out;
			try {
				out = sync(password, salt, iterations, keylen, digest);
			} catch (e) {
				callback(e);
				return;
			}
			callback(null, out);
		});
		return;
	}

	checkParameters(iterations, keylen);
	password = toBuffer(password, defaultEncoding, 'Password');
	salt = toBuffer(salt, defaultEncoding, 'Salt');
	if (typeof callback !== 'function') {
		throw new Error('No callback provided to pbkdf2');
	}

	resolvePromise(checkNative(algo).then(function (resp) {
		if (resp) {
			return browserPbkdf2(password, salt, iterations, keylen, algo);
		}

		return sync(password, salt, iterations, keylen, digest);
	}), callback);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":209,"./precondition":210,"./sync":211,"./to-buffer":212,"safe-buffer":391}],209:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var defaultEncoding;
/* istanbul ignore next */
if (global.process && global.process.browser) {
	defaultEncoding = 'utf-8';
} else if (global.process && global.process.version) {
	var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

	defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
} else {
	defaultEncoding = 'utf-8';
}
module.exports = defaultEncoding;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":359}],210:[function(require,module,exports){
'use strict';

var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

module.exports = function (iterations, keylen) {
	if (typeof iterations !== 'number') {
		throw new TypeError('Iterations not a number');
	}

	if (iterations < 0) {
		throw new TypeError('Bad iterations');
	}

	if (typeof keylen !== 'number') {
		throw new TypeError('Key length not a number');
	}

	if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
		throw new TypeError('Bad key length');
	}
};

},{}],211:[function(require,module,exports){
'use strict';

var md5 = require('create-hash/md5');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var Buffer = require('safe-buffer').Buffer;

var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var toBuffer = require('./to-buffer');

var ZEROS = Buffer.alloc(128);
var sizes = {
	__proto__: null,
	md5: 16,
	sha1: 20,
	sha224: 28,
	sha256: 32,
	sha384: 48,
	sha512: 64,
	'sha512-256': 32,
	ripemd160: 20,
	rmd160: 20
};

var mapping = {
	__proto__: null,
	'sha-1': 'sha1',
	'sha-224': 'sha224',
	'sha-256': 'sha256',
	'sha-384': 'sha384',
	'sha-512': 'sha512',
	'ripemd-160': 'ripemd160'
};

function rmd160Func(data) {
	return new RIPEMD160().update(data).digest();
}

function getDigest(alg) {
	function shaFunc(data) {
		return sha(alg).update(data).digest();
	}

	if (alg === 'rmd160' || alg === 'ripemd160') {
		return rmd160Func;
	}
	if (alg === 'md5') {
		return md5;
	}
	return shaFunc;
}

function Hmac(alg, key, saltLen) {
	var hash = getDigest(alg);
	var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

	if (key.length > blocksize) {
		key = hash(key);
	} else if (key.length < blocksize) {
		key = Buffer.concat([key, ZEROS], blocksize);
	}

	var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	for (var i = 0; i < blocksize; i++) {
		ipad[i] = key[i] ^ 0x36;
		opad[i] = key[i] ^ 0x5C;
	}

	var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
	ipad.copy(ipad1, 0, 0, blocksize);
	this.ipad1 = ipad1;
	this.ipad2 = ipad;
	this.opad = opad;
	this.alg = alg;
	this.blocksize = blocksize;
	this.hash = hash;
	this.size = sizes[alg];
}

Hmac.prototype.run = function (data, ipad) {
	data.copy(ipad, this.blocksize);
	var h = this.hash(ipad);
	h.copy(this.opad, this.blocksize);
	return this.hash(this.opad);
};

function pbkdf2(password, salt, iterations, keylen, digest) {
	checkParameters(iterations, keylen);
	password = toBuffer(password, defaultEncoding, 'Password');
	salt = toBuffer(salt, defaultEncoding, 'Salt');

	var lowerDigest = (digest || 'sha1').toLowerCase();
	var mappedDigest = mapping[lowerDigest] || lowerDigest;
	var size = sizes[mappedDigest];
	if (typeof size !== 'number' || !size) {
		throw new TypeError('Digest algorithm not supported: ' + digest);
	}

	var hmac = new Hmac(mappedDigest, password, salt.length);

	var DK = Buffer.allocUnsafe(keylen);
	var block1 = Buffer.allocUnsafe(salt.length + 4);
	salt.copy(block1, 0, 0, salt.length);

	var destPos = 0;
	var hLen = size;
	var l = Math.ceil(keylen / hLen);

	for (var i = 1; i <= l; i++) {
		block1.writeUInt32BE(i, salt.length);

		var T = hmac.run(block1, hmac.ipad1);
		var U = T;

		for (var j = 1; j < iterations; j++) {
			U = hmac.run(U, hmac.ipad2);
			for (var k = 0; k < hLen; k++) {
				T[k] ^= U[k];
			}
		}

		T.copy(DK, destPos);
		destPos += hLen;
	}

	return DK;
}

module.exports = pbkdf2;

},{"./default-encoding":209,"./precondition":210,"./to-buffer":212,"create-hash/md5":214,"ripemd160":215,"safe-buffer":391,"sha.js":395}],212:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('to-buffer');

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== 'undefined';
var isView = useArrayBuffer && ArrayBuffer.isView;

module.exports = function (thing, encoding, name) {
	if (
		typeof thing === 'string'
		|| Buffer.isBuffer(thing)
		|| (useUint8Array && thing instanceof Uint8Array)
		|| (isView && isView(thing))
	) {
		return toBuffer(thing, encoding);
	}
	throw new TypeError(name + ' must be a string, a Buffer, a Uint8Array, or a DataView');
};

},{"safe-buffer":391,"to-buffer":413}],213:[function(require,module,exports){
(function (Buffer){(function (){
'use strict'
var intSize = 4
var zeroBuffer = new Buffer(intSize)
zeroBuffer.fill(0)

var charSize = 8
var hashSize = 16

function toArray (buf) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize))
    buf = Buffer.concat([buf, zeroBuffer], len)
  }

  var arr = new Array(buf.length >>> 2)
  for (var i = 0, j = 0; i < buf.length; i += intSize, j++) {
    arr[j] = buf.readInt32LE(i)
  }

  return arr
}

module.exports = function hash (buf, fn) {
  var arr = fn(toArray(buf), buf.length * charSize)
  buf = new Buffer(hashSize)
  for (var i = 0; i < arr.length; i++) {
    buf.writeInt32LE(arr[i], i << 2, true)
  }
  return buf
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185}],214:[function(require,module,exports){
'use strict'
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var makeHash = require('./make-hash')

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5 (x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32)
  x[(((len + 64) >>> 9) << 4) + 14] = len

  var a = 1732584193
  var b = -271733879
  var c = -1732584194
  var d = 271733878

  for (var i = 0; i < x.length; i += 16) {
    var olda = a
    var oldb = b
    var oldc = c
    var oldd = d

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936)
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302)
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222)
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844)
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)

    a = safe_add(a, olda)
    b = safe_add(b, oldb)
    c = safe_add(c, oldc)
    d = safe_add(d, oldd)
  }

  return [a, b, c, d]
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn (q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
}

function md5_ff (a, b, c, d, x, s, t) {
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
}

function md5_gg (a, b, c, d, x, s, t) {
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
}

function md5_hh (a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t)
}

function md5_ii (a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add (x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF)
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
  return (msw << 16) | (lsw & 0xFFFF)
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

module.exports = function md5 (buf) {
  return makeHash(buf, core_md5)
}

},{"./make-hash":213}],215:[function(require,module,exports){
(function (Buffer){(function (){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var m = new Array(16)
  for (var i = 0; i < 16; ++i) m[i] = this._block.readInt32LE(i * 4)

  var al = this._a
  var bl = this._b
  var cl = this._c
  var dl = this._d
  var el = this._e

  // Mj = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  // K = 0x00000000
  // Sj = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
  al = fn1(al, bl, cl, dl, el, m[0], 0x00000000, 11); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[1], 0x00000000, 14); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[2], 0x00000000, 15); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[3], 0x00000000, 12); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[4], 0x00000000, 5); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[5], 0x00000000, 8); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[6], 0x00000000, 7); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[7], 0x00000000, 9); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[8], 0x00000000, 11); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[9], 0x00000000, 13); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[10], 0x00000000, 14); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[11], 0x00000000, 15); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[12], 0x00000000, 6); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[13], 0x00000000, 7); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[14], 0x00000000, 9); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[15], 0x00000000, 8); cl = rotl(cl, 10)

  // Mj = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
  // K = 0x5a827999
  // Sj = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
  el = fn2(el, al, bl, cl, dl, m[7], 0x5a827999, 7); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[4], 0x5a827999, 6); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[13], 0x5a827999, 8); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[1], 0x5a827999, 13); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[10], 0x5a827999, 11); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[6], 0x5a827999, 9); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[15], 0x5a827999, 7); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[3], 0x5a827999, 15); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[12], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[0], 0x5a827999, 12); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[9], 0x5a827999, 15); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[5], 0x5a827999, 9); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[2], 0x5a827999, 11); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[14], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[11], 0x5a827999, 13); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[8], 0x5a827999, 12); bl = rotl(bl, 10)

  // Mj = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
  // K = 0x6ed9eba1
  // Sj = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
  dl = fn3(dl, el, al, bl, cl, m[3], 0x6ed9eba1, 11); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[10], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[14], 0x6ed9eba1, 6); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[4], 0x6ed9eba1, 7); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[9], 0x6ed9eba1, 14); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[15], 0x6ed9eba1, 9); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[8], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[1], 0x6ed9eba1, 15); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[2], 0x6ed9eba1, 14); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[7], 0x6ed9eba1, 8); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[0], 0x6ed9eba1, 13); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[6], 0x6ed9eba1, 6); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[13], 0x6ed9eba1, 5); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[11], 0x6ed9eba1, 12); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[5], 0x6ed9eba1, 7); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[12], 0x6ed9eba1, 5); al = rotl(al, 10)

  // Mj = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
  // K = 0x8f1bbcdc
  // Sj = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
  cl = fn4(cl, dl, el, al, bl, m[1], 0x8f1bbcdc, 11); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[9], 0x8f1bbcdc, 12); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[11], 0x8f1bbcdc, 14); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[10], 0x8f1bbcdc, 15); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[0], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[8], 0x8f1bbcdc, 15); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[12], 0x8f1bbcdc, 9); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[4], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[13], 0x8f1bbcdc, 9); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[3], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[7], 0x8f1bbcdc, 5); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[15], 0x8f1bbcdc, 6); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[14], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[5], 0x8f1bbcdc, 6); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[6], 0x8f1bbcdc, 5); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[2], 0x8f1bbcdc, 12); el = rotl(el, 10)

  // Mj = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  // K = 0xa953fd4e
  // Sj = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  bl = fn5(bl, cl, dl, el, al, m[4], 0xa953fd4e, 9); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[0], 0xa953fd4e, 15); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[5], 0xa953fd4e, 5); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[9], 0xa953fd4e, 11); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[7], 0xa953fd4e, 6); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[12], 0xa953fd4e, 8); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[2], 0xa953fd4e, 13); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[10], 0xa953fd4e, 12); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[14], 0xa953fd4e, 5); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[1], 0xa953fd4e, 12); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[3], 0xa953fd4e, 13); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[8], 0xa953fd4e, 14); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[11], 0xa953fd4e, 11); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[6], 0xa953fd4e, 8); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[15], 0xa953fd4e, 5); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[13], 0xa953fd4e, 6); dl = rotl(dl, 10)

  var ar = this._a
  var br = this._b
  var cr = this._c
  var dr = this._d
  var er = this._e

  // M'j = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
  // K' = 0x50a28be6
  // S'j = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
  ar = fn5(ar, br, cr, dr, er, m[5], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[14], 0x50a28be6, 9); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[7], 0x50a28be6, 9); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[0], 0x50a28be6, 11); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[9], 0x50a28be6, 13); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[2], 0x50a28be6, 15); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[11], 0x50a28be6, 15); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[4], 0x50a28be6, 5); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[13], 0x50a28be6, 7); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[6], 0x50a28be6, 7); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[15], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[8], 0x50a28be6, 11); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[1], 0x50a28be6, 14); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[10], 0x50a28be6, 14); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[3], 0x50a28be6, 12); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[12], 0x50a28be6, 6); cr = rotl(cr, 10)

  // M'j = 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
  // K' = 0x5c4dd124
  // S'j = 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
  er = fn4(er, ar, br, cr, dr, m[6], 0x5c4dd124, 9); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[11], 0x5c4dd124, 13); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[3], 0x5c4dd124, 15); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[7], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[0], 0x5c4dd124, 12); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[13], 0x5c4dd124, 8); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[5], 0x5c4dd124, 9); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[10], 0x5c4dd124, 11); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[14], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[15], 0x5c4dd124, 7); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[8], 0x5c4dd124, 12); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[12], 0x5c4dd124, 7); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[4], 0x5c4dd124, 6); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[9], 0x5c4dd124, 15); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[1], 0x5c4dd124, 13); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[2], 0x5c4dd124, 11); br = rotl(br, 10)

  // M'j = 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
  // K' = 0x6d703ef3
  // S'j = 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
  dr = fn3(dr, er, ar, br, cr, m[15], 0x6d703ef3, 9); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[5], 0x6d703ef3, 7); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[1], 0x6d703ef3, 15); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[3], 0x6d703ef3, 11); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[7], 0x6d703ef3, 8); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[14], 0x6d703ef3, 6); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[6], 0x6d703ef3, 6); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[9], 0x6d703ef3, 14); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[11], 0x6d703ef3, 12); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[8], 0x6d703ef3, 13); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[12], 0x6d703ef3, 5); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[2], 0x6d703ef3, 14); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[10], 0x6d703ef3, 13); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[0], 0x6d703ef3, 13); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[4], 0x6d703ef3, 7); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[13], 0x6d703ef3, 5); ar = rotl(ar, 10)

  // M'j = 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
  // K' = 0x7a6d76e9
  // S'j = 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
  cr = fn2(cr, dr, er, ar, br, m[8], 0x7a6d76e9, 15); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[6], 0x7a6d76e9, 5); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[4], 0x7a6d76e9, 8); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[1], 0x7a6d76e9, 11); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[3], 0x7a6d76e9, 14); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[11], 0x7a6d76e9, 14); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[15], 0x7a6d76e9, 6); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[0], 0x7a6d76e9, 14); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[5], 0x7a6d76e9, 6); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[12], 0x7a6d76e9, 9); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[2], 0x7a6d76e9, 12); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[13], 0x7a6d76e9, 9); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[9], 0x7a6d76e9, 12); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[7], 0x7a6d76e9, 5); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[10], 0x7a6d76e9, 15); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[14], 0x7a6d76e9, 8); er = rotl(er, 10)

  // M'j = 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  // K' = 0x00000000
  // S'j = 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  br = fn1(br, cr, dr, er, ar, m[12], 0x00000000, 8); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[15], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[10], 0x00000000, 12); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[4], 0x00000000, 9); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[1], 0x00000000, 12); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[5], 0x00000000, 5); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[8], 0x00000000, 14); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[7], 0x00000000, 6); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[6], 0x00000000, 8); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[2], 0x00000000, 13); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[13], 0x00000000, 6); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[14], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[0], 0x00000000, 15); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[3], 0x00000000, 13); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[9], 0x00000000, 11); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[11], 0x00000000, 11); dr = rotl(dr, 10)

  // change state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"hash-base":216,"inherits":324}],216:[function(require,module,exports){
(function (Buffer){(function (){
'use strict'
var Transform = require('stream').Transform
var inherits = require('inherits')

function HashBase (blockSize) {
  Transform.call(this)

  this._block = new Buffer(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding)
    this.update(chunk)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this._digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || 'binary')

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function (data) {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)
  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"inherits":324,"stream":406}],217:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],218:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    const N = 16;

	    //Origin pbox and sbox, derived from PI
	    const ORIG_P = [
	        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
	        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
	        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
	        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
	        0x9216D5D9, 0x8979FB1B
	    ];

	    const ORIG_S = [
	        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
	            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
	            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
	            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
	            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
	            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
	            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
	            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
	            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
	            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
	            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
	            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
	            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
	            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
	            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
	            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
	            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
	            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
	            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
	            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
	            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
	            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
	            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
	            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
	            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
	            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
	            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
	            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
	            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
	            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
	            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
	            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
	            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
	            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
	            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
	            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
	            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
	            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
	            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
	            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
	            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
	            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
	            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
	            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
	            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
	            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
	            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
	            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
	            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
	            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
	            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
	            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
	            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
	            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
	            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
	            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
	            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
	            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
	            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
	            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
	            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
	            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
	            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
	            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],
	        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
	            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
	            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
	            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
	            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
	            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
	            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
	            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
	            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
	            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
	            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
	            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
	            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
	            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
	            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
	            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
	            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
	            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
	            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
	            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
	            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
	            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
	            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
	            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
	            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
	            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
	            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
	            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
	            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
	            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
	            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
	            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
	            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
	            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
	            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
	            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
	            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
	            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
	            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
	            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
	            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
	            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
	            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
	            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
	            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
	            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
	            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
	            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
	            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
	            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
	            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
	            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
	            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
	            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
	            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
	            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
	            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
	            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
	            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
	            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
	            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
	            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
	            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
	            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],
	        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
	            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
	            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
	            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
	            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
	            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
	            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
	            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
	            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
	            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
	            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
	            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
	            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
	            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
	            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
	            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
	            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
	            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
	            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
	            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
	            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
	            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
	            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
	            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
	            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
	            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
	            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
	            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
	            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
	            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
	            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
	            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
	            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
	            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
	            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
	            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
	            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
	            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
	            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
	            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
	            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
	            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
	            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
	            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
	            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
	            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
	            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
	            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
	            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
	            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
	            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
	            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
	            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
	            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
	            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
	            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
	            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
	            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
	            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
	            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
	            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
	            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
	            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
	            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],
	        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
	            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
	            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
	            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
	            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
	            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
	            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
	            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
	            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
	            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
	            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
	            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
	            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
	            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
	            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
	            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
	            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
	            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
	            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
	            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
	            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
	            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
	            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
	            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
	            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
	            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
	            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
	            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
	            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
	            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
	            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
	            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
	            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
	            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
	            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
	            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
	            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
	            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
	            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
	            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
	            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
	            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
	            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
	            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
	            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
	            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
	            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
	            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
	            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
	            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
	            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
	            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
	            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
	            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
	            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
	            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
	            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
	            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
	            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
	            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
	            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
	            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
	            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
	            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]
	    ];

	    var BLOWFISH_CTX = {
	        pbox: [],
	        sbox: []
	    }

	    function F(ctx, x){
	        let a = (x >> 24) & 0xFF;
	        let b = (x >> 16) & 0xFF;
	        let c = (x >> 8) & 0xFF;
	        let d = x & 0xFF;

	        let y = ctx.sbox[0][a] + ctx.sbox[1][b];
	        y = y ^ ctx.sbox[2][c];
	        y = y + ctx.sbox[3][d];

	        return y;
	    }

	    function BlowFish_Encrypt(ctx, left, right){
	        let Xl = left;
	        let Xr = right;
	        let temp;

	        for(let i = 0; i < N; ++i){
	            Xl = Xl ^ ctx.pbox[i];
	            Xr = F(ctx, Xl) ^ Xr;

	            temp = Xl;
	            Xl = Xr;
	            Xr = temp;
	        }

	        temp = Xl;
	        Xl = Xr;
	        Xr = temp;

	        Xr = Xr ^ ctx.pbox[N];
	        Xl = Xl ^ ctx.pbox[N + 1];

	        return {left: Xl, right: Xr};
	    }

	    function BlowFish_Decrypt(ctx, left, right){
	        let Xl = left;
	        let Xr = right;
	        let temp;

	        for(let i = N + 1; i > 1; --i){
	            Xl = Xl ^ ctx.pbox[i];
	            Xr = F(ctx, Xl) ^ Xr;

	            temp = Xl;
	            Xl = Xr;
	            Xr = temp;
	        }

	        temp = Xl;
	        Xl = Xr;
	        Xr = temp;

	        Xr = Xr ^ ctx.pbox[1];
	        Xl = Xl ^ ctx.pbox[0];

	        return {left: Xl, right: Xr};
	    }

	    /**
	     * Initialization ctx's pbox and sbox.
	     *
	     * @param {Object} ctx The object has pbox and sbox.
	     * @param {Array} key An array of 32-bit words.
	     * @param {int} keysize The length of the key.
	     *
	     * @example
	     *
	     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);
	     */
	    function BlowFishInit(ctx, key, keysize)
	    {
	        for(let Row = 0; Row < 4; Row++)
	        {
	            ctx.sbox[Row] = [];
	            for(let Col = 0; Col < 256; Col++)
	            {
	                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
	            }
	        }

	        let keyIndex = 0;
	        for(let index = 0; index < N + 2; index++)
	        {
	            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
	            keyIndex++;
	            if(keyIndex >= keysize)
	            {
	                keyIndex = 0;
	            }
	        }

	        let Data1 = 0;
	        let Data2 = 0;
	        let res = 0;
	        for(let i = 0; i < N + 2; i += 2)
	        {
	            res = BlowFish_Encrypt(ctx, Data1, Data2);
	            Data1 = res.left;
	            Data2 = res.right;
	            ctx.pbox[i] = Data1;
	            ctx.pbox[i + 1] = Data2;
	        }

	        for(let i = 0; i < 4; i++)
	        {
	            for(let j = 0; j < 256; j += 2)
	            {
	                res = BlowFish_Encrypt(ctx, Data1, Data2);
	                Data1 = res.left;
	                Data2 = res.right;
	                ctx.sbox[i][j] = Data1;
	                ctx.sbox[i][j + 1] = Data2;
	            }
	        }

	        return true;
	    }

	    /**
	     * Blowfish block cipher algorithm.
	     */
	    var Blowfish = C_algo.Blowfish = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            //Initialization pbox and sbox
	            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
	        },

	        encryptBlock: function (M, offset) {
	            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
	            M[offset] = res.left;
	            M[offset + 1] = res.right;
	        },

	        decryptBlock: function (M, offset) {
	            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
	            M[offset] = res.left;
	            M[offset + 1] = res.right;
	        },

	        blockSize: 64/32,

	        keySize: 128/32,

	        ivSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);
	     */
	    C.Blowfish = BlockCipher._createHelper(Blowfish);
	}());


	return CryptoJS.Blowfish;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],219:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./evpkdf"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt, hasher) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            if (!hasher) {
	                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
	            } else {
	                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);
	            }


	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
},{"./core":220,"./evpkdf":224}],220:[function(require,module,exports){
(function (global){(function (){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && typeof require === 'function') {
	        try {
	            crypto = require('crypto');
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"crypto":144}],221:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":220}],222:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64url encoding strategy.
	     */
	    var Base64url = C_enc.Base64url = {
	        /**
	         * Converts a word array to a Base64url string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {string} The Base64url string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
	         */
	        stringify: function (wordArray, urlSafe) {
	            if (urlSafe === undefined) {
	                urlSafe = true
	            }
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = urlSafe ? this._safe_map : this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64url string to a word array.
	         *
	         * @param {string} base64Str The Base64url string.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
	         */
	        parse: function (base64Str, urlSafe) {
	            if (urlSafe === undefined) {
	                urlSafe = true
	            }

	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = urlSafe ? this._safe_map : this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                reverseMap = this._reverseMap = [];
	                for (var j = 0; j < map.length; j++) {
	                    reverseMap[map.charCodeAt(j)] = j;
	                }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
	        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	        var words = [];
	        var nBytes = 0;
	        for (var i = 0; i < base64StrLength; i++) {
	            if (i % 4) {
	                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	                var bitsCombined = bits1 | bits2;
	                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	                nBytes++;
	            }
	        }
	        return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64url;

}));
},{"./core":220}],223:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));
},{"./core":220}],224:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
},{"./core":220,"./hmac":226,"./sha1":245}],225:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));
},{"./cipher-core":219,"./core":220}],226:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":220}],227:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./enc-base64url"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"), require("./blowfish"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));
},{"./aes":217,"./blowfish":218,"./cipher-core":219,"./core":220,"./enc-base64":221,"./enc-base64url":222,"./enc-utf16":223,"./evpkdf":224,"./format-hex":225,"./hmac":226,"./lib-typedarrays":228,"./md5":229,"./mode-cfb":230,"./mode-ctr":232,"./mode-ctr-gladman":231,"./mode-ecb":233,"./mode-ofb":234,"./pad-ansix923":235,"./pad-iso10126":236,"./pad-iso97971":237,"./pad-nopadding":238,"./pad-zeropadding":239,"./pbkdf2":240,"./rabbit":242,"./rabbit-legacy":241,"./rc4":243,"./ripemd160":244,"./sha1":245,"./sha224":246,"./sha256":247,"./sha3":248,"./sha384":249,"./sha512":250,"./tripledes":251,"./x64-core":252}],228:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));
},{"./core":220}],229:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":220}],230:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        var keystream;

	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));
},{"./cipher-core":219,"./core":220}],231:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));
},{"./cipher-core":219,"./core":220}],232:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));
},{"./cipher-core":219,"./core":220}],233:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));
},{"./cipher-core":219,"./core":220}],234:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));
},{"./cipher-core":219,"./core":220}],235:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));
},{"./cipher-core":219,"./core":220}],236:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));
},{"./cipher-core":219,"./core":220}],237:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));
},{"./cipher-core":219,"./core":220}],238:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));
},{"./cipher-core":219,"./core":220}],239:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        for (var i = data.sigBytes - 1; i >= 0; i--) {
	            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	                data.sigBytes = i + 1;
	                break;
	            }
	        }
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));
},{"./cipher-core":219,"./core":220}],240:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA256
	         * @property {number} iterations The number of iterations to perform. Default: 250000
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA256,
	            iterations: 250000
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));
},{"./core":220,"./hmac":226,"./sha256":247}],241:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],242:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],243:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],244:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));
},{"./core":220}],245:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
},{"./core":220}],246:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));
},{"./core":220,"./sha256":247}],247:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
},{"./core":220}],248:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    var tMsw;
	                    var tLsw;

	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));
},{"./core":220,"./x64-core":252}],249:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));
},{"./core":220,"./sha512":250,"./x64-core":252}],250:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                var Wil;
	                var Wih;

	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    Wih = Wi.high = M[offset + i * 2]     | 0;
	                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    Wil = gamma0l + Wi7l;
	                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    Wil = Wil + gamma1l;
	                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    Wil = Wil + Wi16l;
	                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));
},{"./core":220,"./x64-core":252}],251:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            // Make sure the key length is valid (64, 128 or >= 192 bit)
	            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
	                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
	            }

	            // Extend the key according to the keying options defined in 3DES standard
	            var key1 = keyWords.slice(0, 2);
	            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
	            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(key1));
	            this._des2 = DES.createEncryptor(WordArray.create(key2));
	            this._des3 = DES.createEncryptor(WordArray.create(key3));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));
},{"./cipher-core":219,"./core":220,"./enc-base64":221,"./evpkdf":224,"./md5":229}],252:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));
},{"./core":220}],253:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};

},{"es-define-property":283,"es-errors/syntax":288,"es-errors/type":289,"gopd":302}],254:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":255,"./des/cipher":256,"./des/des":257,"./des/ede":258,"./des/utils":259}],255:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":324,"minimalistic-assert":339}],256:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
  this.padding = options.padding !== false
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":339}],257:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  if (this.padding === false) {
    return false;
  }

  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  if (this.padding === false) {
    return buffer;
  }

  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"./cipher":256,"./utils":259,"inherits":324,"minimalistic-assert":339}],258:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":256,"./des":257,"inherits":324,"minimalistic-assert":339}],259:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],260:[function(require,module,exports){
(function (Buffer){(function (){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/dh":261,"./lib/generatePrime":262,"./lib/primes.json":263,"buffer":185}],261:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./generatePrime":262,"bn.js":264,"buffer":185,"miller-rabin":337,"randombytes":373}],262:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":264,"miller-rabin":337,"randombytes":373}],263:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],264:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"buffer":144,"dup":139}],265:[function(require,module,exports){
'use strict';

var callBind = require('call-bind-apply-helpers');
var gOPD = require('gopd');

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;

},{"call-bind-apply-helpers":194,"gopd":302}],266:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":282,"./elliptic/curve":269,"./elliptic/curves":272,"./elliptic/ec":273,"./elliptic/eddsa":276,"./elliptic/utils":280,"brorand":143}],267:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":280,"bn.js":281}],268:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":280,"./base":267,"bn.js":281,"inherits":324}],269:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":267,"./edwards":268,"./mont":270,"./short":271}],270:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":280,"./base":267,"bn.js":281,"inherits":324}],271:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":280,"./base":267,"bn.js":281,"inherits":324}],272:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":269,"./precomputed/secp256k1":279,"./utils":280,"hash.js":308}],273:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
  var byteLength;
  if (BN.isBN(msg) || typeof msg === 'number') {
    msg = new BN(msg, 16);
    byteLength = msg.byteLength();
  } else if (typeof msg === 'object') {
    // BN assumes an array-like input and asserts length
    byteLength = msg.length;
    msg = new BN(msg, 16);
  } else {
    // BN converts the value to string
    var str = msg.toString();
    // HEX encoding
    byteLength = (str.length + 1) >>> 1;
    msg = new BN(str, 16);
  }
  // Allow overriding
  if (typeof bitLength !== 'number') {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  if (typeof msg !== 'string' && typeof msg !== 'number' && !BN.isBN(msg)) {
    assert(typeof msg === 'object' && msg && typeof msg.length === 'number',
      'Expected message to be an array-like, a hex string, or a BN instance');
    assert((msg.length >>> 0) === msg.length); // non-negative 32-bit integer
    for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
  }

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(msg, false, options.msgBitLength);

  // Would fail further checks, but let's make the error message clear
  assert(!msg.isNeg(), 'Can not sign a negative message');

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Recheck nonce to be bijective to msg
  assert((new BN(nonce)).eq(msg), 'Can not sign message');

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc, options) {
  if (!options)
    options = {};

  msg = this._truncateToN(msg, false, options.msgBitLength);
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":272,"../utils":280,"./key":274,"./signature":275,"bn.js":281,"brorand":143,"hmac-drbg":321}],274:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature, options) {
  return this.ec.verify(msg, signature, this, undefined, options);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":280,"bn.js":281}],275:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  if(buf[p.place] === 0x00) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  if ((data[p.place] & 128) !== 0) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":280,"bn.js":281}],276:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":272,"../utils":280,"./key":277,"./signature":278,"hash.js":308}],277:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":280}],278:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    assert(sig.length === eddsa.encodingLength * 2, 'Signature has invalid size');
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":280,"bn.js":281}],279:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],280:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  var i;
  for (i = 0; i < naf.length; i += 1) {
    naf[i] = 0;
  }

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":281,"minimalistic-assert":339,"minimalistic-crypto-utils":340}],281:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"buffer":144,"dup":139}],282:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.6.1",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],283:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;

},{}],284:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],285:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],286:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],287:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],288:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],289:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],290:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],291:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Object;

},{}],292:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],293:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":336,"safe-buffer":391}],294:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
    return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

},{"is-callable":325}],295:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],296:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":295}],297:[function(require,module,exports){
'use strict';

var undefined;

var $Object = require('es-object-atoms');

var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');
var pow = require('math-intrinsics/pow');
var round = require('math-intrinsics/round');
var sign = require('math-intrinsics/sign');

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = require('gopd');
var $defineProperty = require('es-define-property');

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = require('get-proto');
var $ObjectGPO = require('get-proto/Object.getPrototypeOf');
var $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');

var $apply = require('call-bind-apply-helpers/functionApply');
var $call = require('call-bind-apply-helpers/functionCall');

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"call-bind-apply-helpers/functionApply":192,"call-bind-apply-helpers/functionCall":193,"es-define-property":283,"es-errors":285,"es-errors/eval":284,"es-errors/range":286,"es-errors/ref":287,"es-errors/syntax":288,"es-errors/type":289,"es-errors/uri":290,"es-object-atoms":291,"function-bind":296,"get-proto":300,"get-proto/Object.getPrototypeOf":298,"get-proto/Reflect.getPrototypeOf":299,"gopd":302,"has-symbols":304,"hasown":320,"math-intrinsics/abs":328,"math-intrinsics/floor":329,"math-intrinsics/max":331,"math-intrinsics/min":332,"math-intrinsics/pow":333,"math-intrinsics/round":334,"math-intrinsics/sign":335}],298:[function(require,module,exports){
'use strict';

var $Object = require('es-object-atoms');

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;

},{"es-object-atoms":291}],299:[function(require,module,exports){
'use strict';

/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;

},{}],300:[function(require,module,exports){
'use strict';

var reflectGetProto = require('./Reflect.getPrototypeOf');
var originalGetProto = require('./Object.getPrototypeOf');

var getDunderProto = require('dunder-proto/get');

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;

},{"./Object.getPrototypeOf":298,"./Reflect.getPrototypeOf":299,"dunder-proto/get":265}],301:[function(require,module,exports){
'use strict';

/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;

},{}],302:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $gOPD = require('./gOPD');

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"./gOPD":301}],303:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

},{"es-define-property":283}],304:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":305}],305:[function(require,module,exports){
'use strict';

/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],306:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":305}],307:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":324,"readable-stream":389,"safe-buffer":391}],308:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":309,"./hash/hmac":310,"./hash/ripemd":311,"./hash/sha":312,"./hash/utils":319}],309:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":319,"minimalistic-assert":339}],310:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":319,"minimalistic-assert":339}],311:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":309,"./utils":319}],312:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":313,"./sha/224":314,"./sha/256":315,"./sha/384":316,"./sha/512":317}],313:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":309,"../utils":319,"./common":318}],314:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":319,"./256":315}],315:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":309,"../utils":319,"./common":318,"minimalistic-assert":339}],316:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":319,"./512":317}],317:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":309,"../utils":319,"minimalistic-assert":339}],318:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":319}],319:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":324,"minimalistic-assert":339}],320:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":296}],321:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":308,"minimalistic-assert":339,"minimalistic-crypto-utils":340}],322:[function(require,module,exports){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":407,"url":415}],323:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],324:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],325:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};

},{}],326:[function(require,module,exports){
'use strict';

var whichTypedArray = require('which-typed-array');

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};

},{"which-typed-array":434}],327:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"dup":172}],328:[function(require,module,exports){
'use strict';

/** @type {import('./abs')} */
module.exports = Math.abs;

},{}],329:[function(require,module,exports){
'use strict';

/** @type {import('./floor')} */
module.exports = Math.floor;

},{}],330:[function(require,module,exports){
'use strict';

/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],331:[function(require,module,exports){
'use strict';

/** @type {import('./max')} */
module.exports = Math.max;

},{}],332:[function(require,module,exports){
'use strict';

/** @type {import('./min')} */
module.exports = Math.min;

},{}],333:[function(require,module,exports){
'use strict';

/** @type {import('./pow')} */
module.exports = Math.pow;

},{}],334:[function(require,module,exports){
'use strict';

/** @type {import('./round')} */
module.exports = Math.round;

},{}],335:[function(require,module,exports){
'use strict';

var $isNaN = require('./isNaN');

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};

},{"./isNaN":330}],336:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":307,"inherits":324,"safe-buffer":391}],337:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":338,"brorand":143}],338:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"buffer":144,"dup":139}],339:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],340:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],341:[function(require,module,exports){
(function (global){(function (){
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = require('./util.inspect');
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof global !== 'undefined' && obj === global)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./util.inspect":144}],342:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],343:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

'use strict';

var asn1 = require('asn1.js');

exports.certificate = require('./certificate');

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('modulus')['int'](),
		this.key('publicExponent')['int'](),
		this.key('privateExponent')['int'](),
		this.key('prime1')['int'](),
		this.key('prime2')['int'](),
		this.key('exponent1')['int'](),
		this.key('exponent2')['int'](),
		this.key('coefficient')['int']()
	);
});
exports.RSAPrivateKey = RSAPrivateKey;

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
	this.seq().obj(
		this.key('modulus')['int'](),
		this.key('publicExponent')['int']()
	);
});
exports.RSAPublicKey = RSAPublicKey;

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('none').null_().optional(),
		this.key('curve').objid().optional(),
		this.key('params').seq().obj(
			this.key('p')['int'](),
			this.key('q')['int'](),
			this.key('g')['int']()
		).optional()
	);
});

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});
exports.PublicKey = PublicKey;

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPrivateKey').octstr()
	);
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').seq().obj(
			this.key('id').objid(),
			this.key('decrypt').seq().obj(
				this.key('kde').seq().obj(
					this.key('id').objid(),
					this.key('kdeparams').seq().obj(
						this.key('salt').octstr(),
						this.key('iters')['int']()
					)
				),
				this.key('cipher').seq().obj(
					this.key('algo').objid(),
					this.key('iv').octstr()
				)
			)
		),
		this.key('subjectPrivateKey').octstr()
	);
});

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('p')['int'](),
		this.key('q')['int'](),
		this.key('g')['int'](),
		this.key('pub_key')['int'](),
		this.key('priv_key')['int']()
	);
});
exports.DSAPrivateKey = DSAPrivateKey;

exports.DSAparam = asn1.define('DSAparam', function () {
	this['int']();
});

var ECParameters = asn1.define('ECParameters', function () {
	this.choice({
		namedCurve: this.objid()
	});
});

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
	this.seq().obj(
		this.key('version')['int'](),
		this.key('privateKey').octstr(),
		this.key('parameters').optional().explicit(0).use(ECParameters),
		this.key('publicKey').optional().explicit(1).bitstr()
	);
});
exports.ECPrivateKey = ECPrivateKey;

exports.signature = asn1.define('signature', function () {
	this.seq().obj(
		this.key('r')['int'](),
		this.key('s')['int']()
	);
});

},{"./certificate":344,"asn1.js":125}],344:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict';

var asn = require('asn1.js');

var Time = asn.define('Time', function () {
	this.choice({
		utcTime: this.utctime(),
		generalTime: this.gentime()
	});
});

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
	this.seq().obj(
		this.key('type').objid(),
		this.key('value').any()
	);
});

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
	this.seq().obj(
		this.key('algorithm').objid(),
		this.key('parameters').optional(),
		this.key('curve').objid().optional()
	);
});

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
	this.seq().obj(
		this.key('algorithm').use(AlgorithmIdentifier),
		this.key('subjectPublicKey').bitstr()
	);
});

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
	this.setof(AttributeTypeValue);
});

var RDNSequence = asn.define('RDNSequence', function () {
	this.seqof(RelativeDistinguishedName);
});

var Name = asn.define('Name', function () {
	this.choice({
		rdnSequence: this.use(RDNSequence)
	});
});

var Validity = asn.define('Validity', function () {
	this.seq().obj(
		this.key('notBefore').use(Time),
		this.key('notAfter').use(Time)
	);
});

var Extension = asn.define('Extension', function () {
	this.seq().obj(
		this.key('extnID').objid(),
		this.key('critical').bool().def(false),
		this.key('extnValue').octstr()
	);
});

var TBSCertificate = asn.define('TBSCertificate', function () {
	this.seq().obj(
		this.key('version').explicit(0)['int']().optional(),
		this.key('serialNumber')['int'](),
		this.key('signature').use(AlgorithmIdentifier),
		this.key('issuer').use(Name),
		this.key('validity').use(Validity),
		this.key('subject').use(Name),
		this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
		this.key('issuerUniqueID').implicit(1).bitstr().optional(),
		this.key('subjectUniqueID').implicit(2).bitstr().optional(),
		this.key('extensions').explicit(3).seqof(Extension).optional()
	);
});

var X509Certificate = asn.define('X509Certificate', function () {
	this.seq().obj(
		this.key('tbsCertificate').use(TBSCertificate),
		this.key('signatureAlgorithm').use(AlgorithmIdentifier),
		this.key('signatureValue').bitstr()
	);
});

module.exports = X509Certificate;

},{"asn1.js":125}],345:[function(require,module,exports){
'use strict';

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = require('evp_bytestokey');
var ciphers = require('browserify-aes');
var Buffer = require('safe-buffer').Buffer;
module.exports = function (okey, password) {
	var key = okey.toString();
	var match = key.match(findProc);
	var decrypted;
	if (!match) {
		var match2 = key.match(fullRegex);
		decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
	} else {
		var suite = 'aes' + match[1];
		var iv = Buffer.from(match[2], 'hex');
		var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
		var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
		var out = [];
		var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
		out.push(cipher.update(cipherText));
		out.push(cipher['final']());
		decrypted = Buffer.concat(out);
	}
	var tag = key.match(startRegex)[1];
	return {
		tag: tag,
		data: decrypted
	};
};

},{"browserify-aes":147,"evp_bytestokey":293,"safe-buffer":391}],346:[function(require,module,exports){
'use strict';

var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
var ciphers = require('browserify-aes');
var compat = require('pbkdf2');
var Buffer = require('safe-buffer').Buffer;

function decrypt(data, password) {
	var salt = data.algorithm.decrypt.kde.kdeparams.salt;
	var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
	var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
	var iv = data.algorithm.decrypt.cipher.iv;
	var cipherText = data.subjectPrivateKey;
	var keylen = parseInt(algo.split('-')[1], 10) / 8;
	var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
	var cipher = ciphers.createDecipheriv(algo, key, iv);
	var out = [];
	out.push(cipher.update(cipherText));
	out.push(cipher['final']());
	return Buffer.concat(out);
}

function parseKeys(buffer) {
	var password;
	if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
		password = buffer.passphrase;
		buffer = buffer.key;
	}
	if (typeof buffer === 'string') {
		buffer = Buffer.from(buffer);
	}

	var stripped = fixProc(buffer, password);

	var type = stripped.tag;
	var data = stripped.data;
	var subtype, ndata;
	switch (type) {
		case 'CERTIFICATE':
			ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
			// falls through
		case 'PUBLIC KEY':
			if (!ndata) {
				ndata = asn1.PublicKey.decode(data, 'der');
			}
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
				case '1.2.840.10045.2.1':
					ndata.subjectPrivateKey = ndata.subjectPublicKey;
					return {
						type: 'ec',
						data: ndata
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
					return {
						type: 'dsa',
						data: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'ENCRYPTED PRIVATE KEY':
			data = asn1.EncryptedPrivateKey.decode(data, 'der');
			data = decrypt(data, password);
			// falls through
		case 'PRIVATE KEY':
			ndata = asn1.PrivateKey.decode(data, 'der');
			subtype = ndata.algorithm.algorithm.join('.');
			switch (subtype) {
				case '1.2.840.113549.1.1.1':
					return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
				case '1.2.840.10045.2.1':
					return {
						curve: ndata.algorithm.curve,
						privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
					};
				case '1.2.840.10040.4.1':
					ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
					return {
						type: 'dsa',
						params: ndata.algorithm.params
					};
				default: throw new Error('unknown key id ' + subtype);
			}
			// throw new Error('unknown key type ' + type)
		case 'RSA PUBLIC KEY':
			return asn1.RSAPublicKey.decode(data, 'der');
		case 'RSA PRIVATE KEY':
			return asn1.RSAPrivateKey.decode(data, 'der');
		case 'DSA PRIVATE KEY':
			return {
				type: 'dsa',
				params: asn1.DSAPrivateKey.decode(data, 'der')
			};
		case 'EC PRIVATE KEY':
			data = asn1.ECPrivateKey.decode(data, 'der');
			return {
				curve: data.parameters.value,
				privateKey: data.privateKey
			};
		default: throw new Error('unknown key type ' + type);
	}
}
parseKeys.signature = asn1.signature;

module.exports = parseKeys;

},{"./aesid.json":342,"./asn1":343,"./fixProc":345,"browserify-aes":147,"pbkdf2":349,"safe-buffer":391}],347:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"buffer":185,"dup":213}],348:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"./make-hash":347,"dup":214}],349:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./lib/async":350,"./lib/sync":353,"dup":207}],350:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"./default-encoding":351,"./precondition":352,"./sync":353,"./to-buffer":354,"dup":208,"safe-buffer":391}],351:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"_process":359,"dup":209}],352:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"dup":210}],353:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"./default-encoding":351,"./precondition":352,"./to-buffer":354,"create-hash/md5":348,"dup":211,"ripemd160":355,"safe-buffer":391,"sha.js":395}],354:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"dup":212,"safe-buffer":391,"to-buffer":413}],355:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"buffer":185,"dup":215,"hash-base":356,"inherits":324}],356:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"buffer":185,"dup":216,"inherits":324,"stream":406}],357:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = [
	'Float16Array',
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];

},{}],358:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))
},{"_process":359}],359:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],360:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":363,"./publicEncrypt":364}],361:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":202,"safe-buffer":391}],362:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"buffer":144,"dup":139}],363:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":361,"./withPublic":365,"./xor":366,"bn.js":362,"browserify-rsa":165,"create-hash":202,"parse-asn1":346,"safe-buffer":391}],364:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":361,"./withPublic":365,"./xor":366,"bn.js":362,"browserify-rsa":165,"create-hash":202,"parse-asn1":346,"randombytes":373,"safe-buffer":391}],365:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":362,"safe-buffer":391}],366:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],367:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],368:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};

},{}],369:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":368,"./parse":370,"./stringify":371}],370:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
    );

    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }

    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');

            val = utils.maybeMap(
                parseArrayValue(
                    part.slice(pos + 1),
                    options,
                    isArray(obj[key]) ? obj[key].length : 0
                ),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }

    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? { __proto__: null } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }

    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? { __proto__: null } : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};

},{"./utils":372}],371:[function(require,module,exports){
'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
            ? key.value
            : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];

        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(
            value,
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":368,"./utils":372,"side-channel":405}],372:[function(require,module,exports){
'use strict';

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (
                (options && (options.plainObjects || options.allowPrototypes))
                || !has.call(Object.prototype, source)
            ) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

},{"./formats":368}],373:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":359,"safe-buffer":391}],374:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":359,"randombytes":373,"safe-buffer":391}],375:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],376:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":378,"./_stream_writable":380,"_process":359,"inherits":324}],377:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":379,"inherits":324}],378:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":375,"./_stream_duplex":376,"./internal/streams/async_iterator":381,"./internal/streams/buffer_list":382,"./internal/streams/destroy":383,"./internal/streams/from":385,"./internal/streams/state":387,"./internal/streams/stream":388,"_process":359,"buffer":185,"events":292,"inherits":324,"string_decoder/":411,"util":144}],379:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":375,"./_stream_duplex":376,"inherits":324}],380:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":375,"./_stream_duplex":376,"./internal/streams/destroy":383,"./internal/streams/state":387,"./internal/streams/stream":388,"_process":359,"buffer":185,"inherits":324,"util-deprecate":416}],381:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":384,"_process":359}],382:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
},{"buffer":185,"util":144}],383:[function(require,module,exports){
(function (process){(function (){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":359}],384:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":375}],385:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],386:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":375,"./end-of-stream":384}],387:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":375}],388:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"dup":180,"events":292}],389:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":376,"./lib/_stream_passthrough.js":377,"./lib/_stream_readable.js":378,"./lib/_stream_transform.js":379,"./lib/_stream_writable.js":380,"./lib/internal/streams/end-of-stream.js":384,"./lib/internal/streams/pipeline.js":386}],390:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":185,"hash-base":307,"inherits":324}],391:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":185}],392:[function(require,module,exports){
// @preserve author Alexander Stetsyuk
// @preserve author Glenn Rempe <glenn@rempe.us>
// @license MIT

/*jslint passfail: false, bitwise: true, nomen: true, plusplus: true, todo: false, maxerr: 1000 */
/*global define, require, module, exports, window, Uint32Array */

// eslint : http://eslint.org/docs/configuring/
/*eslint-env node, browser, jasmine */
/*eslint no-underscore-dangle:0 */

// UMD (Universal Module Definition)
// Uses Node, AMD or browser globals to create a module. This module creates
// a global even when AMD is used. This is useful if you have some scripts
// that are loaded by an AMD loader, but they still want access to globals.
// See : https://github.com/umdjs/umd
// See : https://github.com/umdjs/umd/blob/master/returnExportsGlobal.js
//
;(function(root, factory) {
    "use strict"

    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function() {
            /*eslint-disable no-return-assign */
            return (root.secrets = factory())
            /*eslint-enable no-return-assign */
        })
    } else if (typeof exports === "object") {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require("crypto"))
    } else {
        // Browser globals (root is window)
        root.secrets = factory(root.crypto)
    }
})(this, function(crypto) {
    "use strict"

    var defaults, config, preGenPadding, runCSPRNGTest, CSPRNGTypes

    function reset() {
        defaults = {
            bits: 8, // default number of bits
            radix: 16, // work with HEX by default
            minBits: 3,
            maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!
            bytesPerChar: 2,
            maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)

            // Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30
            // The index of each term in the array corresponds to the n for that polynomial
            // i.e. to get the polynomial for n=16, use primitivePolynomials[16]
            primitivePolynomials: [
                null,
                null,
                1,
                3,
                3,
                5,
                3,
                3,
                29,
                17,
                9,
                5,
                83,
                27,
                43,
                3,
                45,
                9,
                39,
                39,
                9,
                5,
                3,
                33,
                27,
                9,
                71,
                39,
                9,
                5,
                83
            ]
        }
        config = {}
        preGenPadding = new Array(1024).join("0") // Pre-generate a string of 1024 0's for use by padLeft().
        runCSPRNGTest = true

        // WARNING : Never use 'testRandom' except for testing.
        CSPRNGTypes = [
            "nodeCryptoRandomBytes",
            "browserCryptoGetRandomValues",
            "testRandom"
        ]
    }

    function isSetRNG() {
        if (config && config.rng && typeof config.rng === "function") {
            return true
        }

        return false
    }

    // Pads a string `str` with zeros on the left so that its length is a multiple of `bits`
    function padLeft(str, multipleOfBits) {
        var missing

        if (multipleOfBits === 0 || multipleOfBits === 1) {
            return str
        }

        if (multipleOfBits && multipleOfBits > 1024) {
            throw new Error(
                "Padding must be multiples of no larger than 1024 bits."
            )
        }

        multipleOfBits = multipleOfBits || config.bits

        if (str) {
            missing = str.length % multipleOfBits
        }

        if (missing) {
            return (preGenPadding + str).slice(
                -(multipleOfBits - missing + str.length)
            )
        }

        return str
    }

    function hex2bin(str) {
        var bin = "",
            num,
            i

        for (i = str.length - 1; i >= 0; i--) {
            num = parseInt(str[i], 16)

            if (isNaN(num)) {
                throw new Error("Invalid hex character.")
            }

            bin = padLeft(num.toString(2), 4) + bin
        }
        return bin
    }

    function bin2hex(str) {
        var hex = "",
            num,
            i

        str = padLeft(str, 4)

        for (i = str.length; i >= 4; i -= 4) {
            num = parseInt(str.slice(i - 4, i), 2)
            if (isNaN(num)) {
                throw new Error("Invalid binary character.")
            }
            hex = num.toString(16) + hex
        }

        return hex
    }

    // Browser supports crypto.getRandomValues()
    function hasCryptoGetRandomValues() {
        if (
            crypto &&
            typeof crypto === "object" &&
            (typeof crypto.getRandomValues === "function" ||
                typeof crypto.getRandomValues === "object") &&
            (typeof Uint32Array === "function" ||
                typeof Uint32Array === "object")
        ) {
            return true
        }

        return false
    }

    // Node.js support for crypto.randomBytes()
    function hasCryptoRandomBytes() {
        if (
            typeof crypto === "object" &&
            typeof crypto.randomBytes === "function"
        ) {
            return true
        }

        return false
    }

    // Returns a pseudo-random number generator of the form function(bits){}
    // which should output a random string of 1's and 0's of length `bits`.
    // `type` (Optional) : A string representing the CSPRNG that you want to
    // force to be loaded, overriding feature detection. Can be one of:
    //    "nodeCryptoRandomBytes"
    //    "browserCryptoGetRandomValues"
    //
    function getRNG(type) {
        function construct(bits, arr, radix, size) {
            var i = 0,
                len,
                str = "",
                parsedInt

            if (arr) {
                len = arr.length - 1
            }

            while (i < len || str.length < bits) {
                // convert any negative nums to positive with Math.abs()
                parsedInt = Math.abs(parseInt(arr[i], radix))
                str = str + padLeft(parsedInt.toString(2), size)
                i++
            }

            str = str.substr(-bits)

            // return null so this result can be re-processed if the result is all 0's.
            if ((str.match(/0/g) || []).length === str.length) {
                return null
            }

            return str
        }

        // Node.js : crypto.randomBytes()
        // Note : Node.js and crypto.randomBytes() uses the OpenSSL RAND_bytes() function for its CSPRNG.
        //        Node.js will need to have been compiled with OpenSSL for this to work.
        // See : https://github.com/joyent/node/blob/d8baf8a2a4481940bfed0196308ae6189ca18eee/src/node_crypto.cc#L4696
        // See : https://www.openssl.org/docs/crypto/rand.html
        function nodeCryptoRandomBytes(bits) {
            var buf,
                bytes,
                radix,
                size,
                str = null

            radix = 16
            size = 4
            bytes = Math.ceil(bits / 8)

            while (str === null) {
                buf = crypto.randomBytes(bytes)
                str = construct(bits, buf.toString("hex"), radix, size)
            }

            return str
        }

        // Browser : crypto.getRandomValues()
        // See : https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-Crypto
        // See : https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues
        // Supported Browsers : http://caniuse.com/#search=crypto.getRandomValues
        function browserCryptoGetRandomValues(bits) {
            var elems,
                radix,
                size,
                str = null

            radix = 10
            size = 32
            elems = Math.ceil(bits / 32)
            while (str === null) {
                str = construct(
                    bits,
                    crypto.getRandomValues(new Uint32Array(elems)),
                    radix,
                    size
                )
            }

            return str
        }

        // /////////////////////////////////////////////////////////////
        // WARNING : DO NOT USE. For testing purposes only.
        // /////////////////////////////////////////////////////////////
        // This function will return repeatable non-random test bits. Can be used
        // for testing only. Node.js does not return proper random bytes
        // when run within a PhantomJS container.
        function testRandom(bits) {
            var arr,
                elems,
                int,
                radix,
                size,
                str = null

            radix = 10
            size = 32
            elems = Math.ceil(bits / 32)
            int = 123456789
            arr = new Uint32Array(elems)

            // Fill every element of the Uint32Array with the same int.
            for (var i = 0; i < arr.length; i++) {
                arr[i] = int
            }

            while (str === null) {
                str = construct(bits, arr, radix, size)
            }

            return str
        }

        // Return a random generator function for browsers that support
        // crypto.getRandomValues() or Node.js compiled with OpenSSL support.
        // WARNING : NEVER use testRandom outside of a testing context. Totally non-random!
        if (type && type === "testRandom") {
            config.typeCSPRNG = type
            return testRandom
        } else if (type && type === "nodeCryptoRandomBytes") {
            config.typeCSPRNG = type
            return nodeCryptoRandomBytes
        } else if (type && type === "browserCryptoGetRandomValues") {
            config.typeCSPRNG = type
            return browserCryptoGetRandomValues
        } else if (hasCryptoRandomBytes()) {
            config.typeCSPRNG = "nodeCryptoRandomBytes"
            return nodeCryptoRandomBytes
        } else if (hasCryptoGetRandomValues()) {
            config.typeCSPRNG = "browserCryptoGetRandomValues"
            return browserCryptoGetRandomValues
        }
    }

    // Splits a number string `bits`-length segments, after first
    // optionally zero-padding it to a length that is a multiple of `padLength.
    // Returns array of integers (each less than 2^bits-1), with each element
    // representing a `bits`-length segment of the input string from right to left,
    // i.e. parts[0] represents the right-most `bits`-length segment of the input string.
    function splitNumStringToIntArray(str, padLength) {
        var parts = [],
            i

        if (padLength) {
            str = padLeft(str, padLength)
        }

        for (i = str.length; i > config.bits; i -= config.bits) {
            parts.push(parseInt(str.slice(i - config.bits, i), 2))
        }

        parts.push(parseInt(str.slice(0, i), 2))

        return parts
    }

    // Polynomial evaluation at `x` using Horner's Method
    // NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i],
    //       so if fx===0, just set fx to coeff[i] because
    //       using the exp/log form will result in incorrect value
    function horner(x, coeffs) {
        var logx = config.logs[x],
            fx = 0,
            i

        for (i = coeffs.length - 1; i >= 0; i--) {
            if (fx !== 0) {
                fx =
                    config.exps[(logx + config.logs[fx]) % config.maxShares] ^
                    coeffs[i]
            } else {
                fx = coeffs[i]
            }
        }

        return fx
    }

    // Evaluate the Lagrange interpolation polynomial at x = `at`
    // using x and y Arrays that are of the same length, with
    // corresponding elements constituting points on the polynomial.
    function lagrange(at, x, y) {
        var sum = 0,
            len,
            product,
            i,
            j

        for (i = 0, len = x.length; i < len; i++) {
            if (y[i]) {
                product = config.logs[y[i]]

                for (j = 0; j < len; j++) {
                    if (i !== j) {
                        if (at === x[j]) {
                            // happens when computing a share that is in the list of shares used to compute it
                            product = -1 // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1
                            break
                        }
                        product =
                            (product +
                                config.logs[at ^ x[j]] -
                                config.logs[x[i] ^ x[j]] +
                                config.maxShares) %
                            config.maxShares // to make sure it's not negative
                    }
                }

                // though exps[-1] === undefined and undefined ^ anything = anything in
                // chrome, this behavior may not hold everywhere, so do the check
                sum = product === -1 ? sum : sum ^ config.exps[product]
            }
        }

        return sum
    }

    // This is the basic polynomial generation and evaluation function
    // for a `config.bits`-length secret (NOT an arbitrary length)
    // Note: no error-checking at this stage! If `secret` is NOT
    // a NUMBER less than 2^bits-1, the output will be incorrect!
    function getShares(secret, numShares, threshold) {
        var shares = [],
            coeffs = [secret],
            i,
            len

        for (i = 1; i < threshold; i++) {
            coeffs[i] = parseInt(config.rng(config.bits), 2)
        }

        for (i = 1, len = numShares + 1; i < len; i++) {
            shares[i - 1] = {
                x: i,
                y: horner(i, coeffs)
            }
        }

        return shares
    }

    function constructPublicShareString(bits, id, data) {
        var bitsBase36, idHex, idMax, idPaddingLen, newShareString

        id = parseInt(id, config.radix)
        bits = parseInt(bits, 10) || config.bits
        bitsBase36 = bits.toString(36).toUpperCase()
        idMax = Math.pow(2, bits) - 1
        idPaddingLen = idMax.toString(config.radix).length
        idHex = padLeft(id.toString(config.radix), idPaddingLen)

        if (typeof id !== "number" || id % 1 !== 0 || id < 1 || id > idMax) {
            throw new Error(
                "Share id must be an integer between 1 and " +
                    idMax +
                    ", inclusive."
            )
        }

        newShareString = bitsBase36 + idHex + data

        return newShareString
    }

    // EXPORTED FUNCTIONS
    // //////////////////

    var secrets = {
        init: function(bits, rngType) {
            var logs = [],
                exps = [],
                x = 1,
                primitive,
                i

            // reset all config back to initial state
            reset()

            if (
                bits &&
                (typeof bits !== "number" ||
                    bits % 1 !== 0 ||
                    bits < defaults.minBits ||
                    bits > defaults.maxBits)
            ) {
                throw new Error(
                    "Number of bits must be an integer between " +
                        defaults.minBits +
                        " and " +
                        defaults.maxBits +
                        ", inclusive."
                )
            }

            if (rngType && CSPRNGTypes.indexOf(rngType) === -1) {
                throw new Error("Invalid RNG type argument : '" + rngType + "'")
            }

            config.radix = defaults.radix
            config.bits = bits || defaults.bits
            config.size = Math.pow(2, config.bits)
            config.maxShares = config.size - 1

            // Construct the exp and log tables for multiplication.
            primitive = defaults.primitivePolynomials[config.bits]

            for (i = 0; i < config.size; i++) {
                exps[i] = x
                logs[x] = i
                x = x << 1 // Left shift assignment
                if (x >= config.size) {
                    x = x ^ primitive // Bitwise XOR assignment
                    x = x & config.maxShares // Bitwise AND assignment
                }
            }

            config.logs = logs
            config.exps = exps

            if (rngType) {
                this.setRNG(rngType)
            }

            if (!isSetRNG()) {
                this.setRNG()
            }

            if (
                !isSetRNG() ||
                !config.bits ||
                !config.size ||
                !config.maxShares ||
                !config.logs ||
                !config.exps ||
                config.logs.length !== config.size ||
                config.exps.length !== config.size
            ) {
                throw new Error("Initialization failed.")
            }
        },

        // Evaluates the Lagrange interpolation polynomial at x=`at` for
        // individual config.bits-length segments of each share in the `shares`
        // Array. Each share is expressed in base `inputRadix`. The output
        // is expressed in base `outputRadix'.
        combine: function(shares, at) {
            var i,
                j,
                len,
                len2,
                result = "",
                setBits,
                share,
                splitShare,
                x = [],
                y = []

            at = at || 0

            for (i = 0, len = shares.length; i < len; i++) {
                share = this.extractShareComponents(shares[i])

                // All shares must have the same bits settings.
                if (setBits === undefined) {
                    setBits = share.bits
                } else if (share.bits !== setBits) {
                    throw new Error(
                        "Mismatched shares: Different bit settings."
                    )
                }

                // Reset everything to the bit settings of the shares.
                if (config.bits !== setBits) {
                    this.init(setBits)
                }

                // Proceed if this share.id is not already in the Array 'x' and
                // then split each share's hex data into an Array of Integers,
                // then 'rotate' those arrays where the first element of each row is converted to
                // its own array, the second element of each to its own Array, and so on for all of the rest.
                // Essentially zipping all of the shares together.
                //
                // e.g.
                //   [ 193, 186, 29, 150, 5, 120, 44, 46, 49, 59, 6, 1, 102, 98, 177, 196 ]
                //   [ 53, 105, 139, 49, 187, 240, 91, 92, 98, 118, 12, 2, 204, 196, 127, 149 ]
                //   [ 146, 211, 249, 167, 209, 136, 118, 114, 83, 77, 10, 3, 170, 166, 206, 81 ]
                //
                // becomes:
                //
                // [ [ 193, 53, 146 ],
                //   [ 186, 105, 211 ],
                //   [ 29, 139, 249 ],
                //   [ 150, 49, 167 ],
                //   [ 5, 187, 209 ],
                //   [ 120, 240, 136 ],
                //   [ 44, 91, 118 ],
                //   [ 46, 92, 114 ],
                //   [ 49, 98, 83 ],
                //   [ 59, 118, 77 ],
                //   [ 6, 12, 10 ],
                //   [ 1, 2, 3 ],
                //   [ 102, 204, 170 ],
                //   [ 98, 196, 166 ],
                //   [ 177, 127, 206 ],
                //   [ 196, 149, 81 ] ]
                //
                if (x.indexOf(share.id) === -1) {
                    x.push(share.id)
                    splitShare = splitNumStringToIntArray(hex2bin(share.data))
                    for (j = 0, len2 = splitShare.length; j < len2; j++) {
                        y[j] = y[j] || []
                        y[j][x.length - 1] = splitShare[j]
                    }
                }
            }

            // Extract the secret from the 'rotated' share data and return a
            // string of Binary digits which represent the secret directly. or in the
            // case of a newShare() return the binary string representing just that
            // new share.
            for (i = 0, len = y.length; i < len; i++) {
                result = padLeft(lagrange(at, x, y[i]).toString(2)) + result
            }

            // If 'at' is non-zero combine() was called from newShare(). In this
            // case return the result (the new share data) directly.
            //
            // Otherwise find the first '1' which was added in the share() function as a padding marker
            // and return only the data after the padding and the marker. Convert this Binary string
            // to hex, which represents the final secret result (which can be converted from hex back
            // to the original string in user space using `hex2str()`).
            return bin2hex(
                at >= 1 ? result : result.slice(result.indexOf("1") + 1)
            )
        },

        getConfig: function() {
            var obj = {}
            obj.radix = config.radix
            obj.bits = config.bits
            obj.maxShares = config.maxShares
            obj.hasCSPRNG = isSetRNG()
            obj.typeCSPRNG = config.typeCSPRNG
            return obj
        },

        // Given a public share, extract the bits (Integer), share ID (Integer), and share data (Hex)
        // and return an Object containing those components.
        extractShareComponents: function(share) {
            var bits,
                id,
                idLen,
                max,
                obj = {},
                regexStr,
                shareComponents

            // Extract the first char which represents the bits in Base 36
            bits = parseInt(share.substr(0, 1), 36)

            if (
                bits &&
                (typeof bits !== "number" ||
                    bits % 1 !== 0 ||
                    bits < defaults.minBits ||
                    bits > defaults.maxBits)
            ) {
                throw new Error(
                    "Invalid share : Number of bits must be an integer between " +
                        defaults.minBits +
                        " and " +
                        defaults.maxBits +
                        ", inclusive."
                )
            }

            // calc the max shares allowed for given bits
            max = Math.pow(2, bits) - 1

            // Determine the ID length which is variable and based on the bit count.
            idLen = (Math.pow(2, bits) - 1).toString(config.radix).length

            // Extract all the parts now that the segment sizes are known.
            regexStr =
                "^([a-kA-K3-9]{1})([a-fA-F0-9]{" + idLen + "})([a-fA-F0-9]+)$"
            shareComponents = new RegExp(regexStr).exec(share)

            // The ID is a Hex number and needs to be converted to an Integer
            if (shareComponents) {
                id = parseInt(shareComponents[2], config.radix)
            }

            if (typeof id !== "number" || id % 1 !== 0 || id < 1 || id > max) {
                throw new Error(
                    "Invalid share : Share id must be an integer between 1 and " +
                        config.maxShares +
                        ", inclusive."
                )
            }

            if (shareComponents && shareComponents[3]) {
                obj.bits = bits
                obj.id = id
                obj.data = shareComponents[3]
                return obj
            }

            throw new Error("The share data provided is invalid : " + share)
        },

        // Set the PRNG to use. If no RNG function is supplied, pick a default using getRNG()
        setRNG: function(rng) {
            var errPrefix = "Random number generator is invalid ",
                errSuffix =
                    " Supply an CSPRNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's."

            if (
                rng &&
                typeof rng === "string" &&
                CSPRNGTypes.indexOf(rng) === -1
            ) {
                throw new Error("Invalid RNG type argument : '" + rng + "'")
            }

            // If RNG was not specified at all,
            // try to pick one appropriate for this env.
            if (!rng) {
                rng = getRNG()
            }

            // If `rng` is a string, try to forcibly
            // set the RNG to the type specified.
            if (rng && typeof rng === "string") {
                rng = getRNG(rng)
            }

            if (runCSPRNGTest) {
                if (rng && typeof rng !== "function") {
                    throw new Error(errPrefix + "(Not a function)." + errSuffix)
                }

                if (rng && typeof rng(config.bits) !== "string") {
                    throw new Error(
                        errPrefix + "(Output is not a string)." + errSuffix
                    )
                }

                if (rng && !parseInt(rng(config.bits), 2)) {
                    throw new Error(
                        errPrefix +
                            "(Binary string output not parseable to an Integer)." +
                            errSuffix
                    )
                }

                if (rng && rng(config.bits).length > config.bits) {
                    throw new Error(
                        errPrefix +
                            "(Output length is greater than config.bits)." +
                            errSuffix
                    )
                }

                if (rng && rng(config.bits).length < config.bits) {
                    throw new Error(
                        errPrefix +
                            "(Output length is less than config.bits)." +
                            errSuffix
                    )
                }
            }

            config.rng = rng

            return true
        },

        // Converts a given UTF16 character string to the HEX representation.
        // Each character of the input string is represented by
        // `bytesPerChar` bytes in the output string which defaults to 2.
        str2hex: function(str, bytesPerChar) {
            var hexChars,
                max,
                out = "",
                neededBytes,
                num,
                i,
                len

            if (typeof str !== "string") {
                throw new Error("Input must be a character string.")
            }

            if (!bytesPerChar) {
                bytesPerChar = defaults.bytesPerChar
            }

            if (
                typeof bytesPerChar !== "number" ||
                bytesPerChar < 1 ||
                bytesPerChar > defaults.maxBytesPerChar ||
                bytesPerChar % 1 !== 0
            ) {
                throw new Error(
                    "Bytes per character must be an integer between 1 and " +
                        defaults.maxBytesPerChar +
                        ", inclusive."
                )
            }

            hexChars = 2 * bytesPerChar
            max = Math.pow(16, hexChars) - 1

            for (i = 0, len = str.length; i < len; i++) {
                num = str[i].charCodeAt()

                if (isNaN(num)) {
                    throw new Error("Invalid character: " + str[i])
                }

                if (num > max) {
                    neededBytes = Math.ceil(Math.log(num + 1) / Math.log(256))
                    throw new Error(
                        "Invalid character code (" +
                            num +
                            "). Maximum allowable is 256^bytes-1 (" +
                            max +
                            "). To convert this character, use at least " +
                            neededBytes +
                            " bytes."
                    )
                }

                out = padLeft(num.toString(16), hexChars) + out
            }
            return out
        },

        // Converts a given HEX number string to a UTF16 character string.
        hex2str: function(str, bytesPerChar) {
            var hexChars,
                out = "",
                i,
                len

            if (typeof str !== "string") {
                throw new Error("Input must be a hexadecimal string.")
            }
            bytesPerChar = bytesPerChar || defaults.bytesPerChar

            if (
                typeof bytesPerChar !== "number" ||
                bytesPerChar % 1 !== 0 ||
                bytesPerChar < 1 ||
                bytesPerChar > defaults.maxBytesPerChar
            ) {
                throw new Error(
                    "Bytes per character must be an integer between 1 and " +
                        defaults.maxBytesPerChar +
                        ", inclusive."
                )
            }

            hexChars = 2 * bytesPerChar

            str = padLeft(str, hexChars)

            for (i = 0, len = str.length; i < len; i += hexChars) {
                out =
                    String.fromCharCode(
                        parseInt(str.slice(i, i + hexChars), 16)
                    ) + out
            }

            return out
        },

        // Generates a random bits-length number string using the PRNG
        random: function(bits) {
            if (
                typeof bits !== "number" ||
                bits % 1 !== 0 ||
                bits < 2 ||
                bits > 65536
            ) {
                throw new Error(
                    "Number of bits must be an Integer between 1 and 65536."
                )
            }

            return bin2hex(config.rng(bits))
        },

        // Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16)
        // into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`),
        // requiring `threshold` number of shares to reconstruct the secret.
        // Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.
        share: function(secret, numShares, threshold, padLength) {
            var neededBits,
                subShares,
                x = new Array(numShares),
                y = new Array(numShares),
                i,
                j,
                len

            // Security:
            // For additional security, pad in multiples of 128 bits by default.
            // A small trade-off in larger share size to help prevent leakage of information
            // about small-ish secrets and increase the difficulty of attacking them.
            padLength = padLength || 128

            if (typeof secret !== "string") {
                throw new Error("Secret must be a string.")
            }

            if (
                typeof numShares !== "number" ||
                numShares % 1 !== 0 ||
                numShares < 2
            ) {
                throw new Error(
                    "Number of shares must be an integer between 2 and 2^bits-1 (" +
                        config.maxShares +
                        "), inclusive."
                )
            }

            if (numShares > config.maxShares) {
                neededBits = Math.ceil(Math.log(numShares + 1) / Math.LN2)
                throw new Error(
                    "Number of shares must be an integer between 2 and 2^bits-1 (" +
                        config.maxShares +
                        "), inclusive. To create " +
                        numShares +
                        " shares, use at least " +
                        neededBits +
                        " bits."
                )
            }

            if (
                typeof threshold !== "number" ||
                threshold % 1 !== 0 ||
                threshold < 2
            ) {
                throw new Error(
                    "Threshold number of shares must be an integer between 2 and 2^bits-1 (" +
                        config.maxShares +
                        "), inclusive."
                )
            }

            if (threshold > config.maxShares) {
                neededBits = Math.ceil(Math.log(threshold + 1) / Math.LN2)
                throw new Error(
                    "Threshold number of shares must be an integer between 2 and 2^bits-1 (" +
                        config.maxShares +
                        "), inclusive.  To use a threshold of " +
                        threshold +
                        ", use at least " +
                        neededBits +
                        " bits."
                )
            }

            if (threshold > numShares) {
                throw new Error(
                    "Threshold number of shares was " +
                        threshold +
                        " but must be less than or equal to the " +
                        numShares +
                        " shares specified as the total to generate."
                )
            }

            if (
                typeof padLength !== "number" ||
                padLength % 1 !== 0 ||
                padLength < 0 ||
                padLength > 1024
            ) {
                throw new Error(
                    "Zero-pad length must be an integer between 0 and 1024 inclusive."
                )
            }

            secret = "1" + hex2bin(secret) // prepend a 1 as a marker so that we can preserve the correct number of leading zeros in our secret
            secret = splitNumStringToIntArray(secret, padLength)

            for (i = 0, len = secret.length; i < len; i++) {
                subShares = getShares(secret[i], numShares, threshold)
                for (j = 0; j < numShares; j++) {
                    x[j] = x[j] || subShares[j].x.toString(config.radix)
                    y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] || "")
                }
            }

            for (i = 0; i < numShares; i++) {
                x[i] = constructPublicShareString(
                    config.bits,
                    x[i],
                    bin2hex(y[i])
                )
            }

            return x
        },

        // Generate a new share with id `id` (a number between 1 and 2^bits-1)
        // `id` can be a Number or a String in the default radix (16)
        newShare: function(id, shares) {
            var share, radid

            if (id && typeof id === "string") {
                id = parseInt(id, config.radix)
            }

            radid = id.toString(config.radix)

            if (id && radid && shares && shares[0]) {
                share = this.extractShareComponents(shares[0])
                return constructPublicShareString(
                    share.bits,
                    radid,
                    this.combine(shares, id)
                )
            }

            throw new Error(
                "Invalid 'id' or 'shares' Array argument to newShare()."
            )
        },

        /* test-code */
        // export private functions so they can be unit tested directly.
        _reset: reset,
        _padLeft: padLeft,
        _hex2bin: hex2bin,
        _bin2hex: bin2hex,
        _hasCryptoGetRandomValues: hasCryptoGetRandomValues,
        _hasCryptoRandomBytes: hasCryptoRandomBytes,
        _getRNG: getRNG,
        _isSetRNG: isSetRNG,
        _splitNumStringToIntArray: splitNumStringToIntArray,
        _horner: horner,
        _lagrange: lagrange,
        _getShares: getShares,
        _constructPublicShareString: constructPublicShareString
        /* end-test-code */
    }

    // Always initialize secrets with default settings.
    secrets.init()

    return secrets
})

},{"crypto":206}],393:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');

var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};

},{"define-data-property":253,"es-errors/type":289,"get-intrinsic":297,"gopd":302,"has-property-descriptors":303}],394:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var toBuffer = require('to-buffer');

// prototype class for hash functions
function Hash(blockSize, finalSize) {
	this._block = Buffer.alloc(blockSize);
	this._finalSize = finalSize;
	this._blockSize = blockSize;
	this._len = 0;
}

Hash.prototype.update = function (data, enc) {
	/* eslint no-param-reassign: 0 */
	data = toBuffer(data, enc || 'utf8');

	var block = this._block;
	var blockSize = this._blockSize;
	var length = data.length;
	var accum = this._len;

	for (var offset = 0; offset < length;) {
		var assigned = accum % blockSize;
		var remainder = Math.min(length - offset, blockSize - assigned);

		for (var i = 0; i < remainder; i++) {
			block[assigned + i] = data[offset + i];
		}

		accum += remainder;
		offset += remainder;

		if ((accum % blockSize) === 0) {
			this._update(block);
		}
	}

	this._len += length;
	return this;
};

Hash.prototype.digest = function (enc) {
	var rem = this._len % this._blockSize;

	this._block[rem] = 0x80;

	/*
	 * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	 * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	 */
	this._block.fill(0, rem + 1);

	if (rem >= this._finalSize) {
		this._update(this._block);
		this._block.fill(0);
	}

	var bits = this._len * 8;

	// uint32
	if (bits <= 0xffffffff) {
		this._block.writeUInt32BE(bits, this._blockSize - 4);

		// uint64
	} else {
		var lowBits = (bits & 0xffffffff) >>> 0;
		var highBits = (bits - lowBits) / 0x100000000;

		this._block.writeUInt32BE(highBits, this._blockSize - 8);
		this._block.writeUInt32BE(lowBits, this._blockSize - 4);
	}

	this._update(this._block);
	var hash = this._hash();

	return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
	throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

},{"safe-buffer":391,"to-buffer":413}],395:[function(require,module,exports){
'use strict';

module.exports = function SHA(algorithm) {
	var alg = algorithm.toLowerCase();

	var Algorithm = module.exports[alg];
	if (!Algorithm) {
		throw new Error(alg + ' is not supported (we accept pull requests)');
	}

	return new Algorithm();
};

module.exports.sha = require('./sha');
module.exports.sha1 = require('./sha1');
module.exports.sha224 = require('./sha224');
module.exports.sha256 = require('./sha256');
module.exports.sha384 = require('./sha384');
module.exports.sha512 = require('./sha512');

},{"./sha":396,"./sha1":397,"./sha224":398,"./sha256":399,"./sha384":400,"./sha512":401}],396:[function(require,module,exports){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
];

var W = new Array(80);

function Sha() {
	this.init();
	this._w = W;

	Hash.call(this, 64, 56);
}

inherits(Sha, Hash);

Sha.prototype.init = function () {
	this._a = 0x67452301;
	this._b = 0xefcdab89;
	this._c = 0x98badcfe;
	this._d = 0x10325476;
	this._e = 0xc3d2e1f0;

	return this;
};

function rotl5(num) {
	return (num << 5) | (num >>> 27);
}

function rotl30(num) {
	return (num << 30) | (num >>> 2);
}

function ft(s, b, c, d) {
	if (s === 0) {
		return (b & c) | (~b & d);
	}
	if (s === 2) {
		return (b & c) | (b & d) | (c & d);
	}
	return b ^ c ^ d;
}

Sha.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 80; ++i) {
		w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
	}

	for (var j = 0; j < 80; ++j) {
		var s = ~~(j / 20);
		var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

		e = d;
		d = c;
		c = rotl30(b);
		b = a;
		a = t;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
};

Sha.prototype._hash = function () {
	var H = Buffer.allocUnsafe(20);

	H.writeInt32BE(this._a | 0, 0);
	H.writeInt32BE(this._b | 0, 4);
	H.writeInt32BE(this._c | 0, 8);
	H.writeInt32BE(this._d | 0, 12);
	H.writeInt32BE(this._e | 0, 16);

	return H;
};

module.exports = Sha;

},{"./hash":394,"inherits":324,"safe-buffer":391}],397:[function(require,module,exports){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
];

var W = new Array(80);

function Sha1() {
	this.init();
	this._w = W;

	Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
	this._a = 0x67452301;
	this._b = 0xefcdab89;
	this._c = 0x98badcfe;
	this._d = 0x10325476;
	this._e = 0xc3d2e1f0;

	return this;
};

function rotl1(num) {
	return (num << 1) | (num >>> 31);
}

function rotl5(num) {
	return (num << 5) | (num >>> 27);
}

function rotl30(num) {
	return (num << 30) | (num >>> 2);
}

function ft(s, b, c, d) {
	if (s === 0) {
		return (b & c) | (~b & d);
	}
	if (s === 2) {
		return (b & c) | (b & d) | (c & d);
	}
	return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 80; ++i) {
		w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
	}

	for (var j = 0; j < 80; ++j) {
		var s = ~~(j / 20);
		var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

		e = d;
		d = c;
		c = rotl30(b);
		b = a;
		a = t;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
};

Sha1.prototype._hash = function () {
	var H = Buffer.allocUnsafe(20);

	H.writeInt32BE(this._a | 0, 0);
	H.writeInt32BE(this._b | 0, 4);
	H.writeInt32BE(this._c | 0, 8);
	H.writeInt32BE(this._d | 0, 12);
	H.writeInt32BE(this._e | 0, 16);

	return H;
};

module.exports = Sha1;

},{"./hash":394,"inherits":324,"safe-buffer":391}],398:[function(require,module,exports){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Sha256 = require('./sha256');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var W = new Array(64);

function Sha224() {
	this.init();

	this._w = W; // new Array(64)

	Hash.call(this, 64, 56);
}

inherits(Sha224, Sha256);

Sha224.prototype.init = function () {
	this._a = 0xc1059ed8;
	this._b = 0x367cd507;
	this._c = 0x3070dd17;
	this._d = 0xf70e5939;
	this._e = 0xffc00b31;
	this._f = 0x68581511;
	this._g = 0x64f98fa7;
	this._h = 0xbefa4fa4;

	return this;
};

Sha224.prototype._hash = function () {
	var H = Buffer.allocUnsafe(28);

	H.writeInt32BE(this._a, 0);
	H.writeInt32BE(this._b, 4);
	H.writeInt32BE(this._c, 8);
	H.writeInt32BE(this._d, 12);
	H.writeInt32BE(this._e, 16);
	H.writeInt32BE(this._f, 20);
	H.writeInt32BE(this._g, 24);

	return H;
};

module.exports = Sha224;

},{"./hash":394,"./sha256":399,"inherits":324,"safe-buffer":391}],399:[function(require,module,exports){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x428A2F98,
	0x71374491,
	0xB5C0FBCF,
	0xE9B5DBA5,
	0x3956C25B,
	0x59F111F1,
	0x923F82A4,
	0xAB1C5ED5,
	0xD807AA98,
	0x12835B01,
	0x243185BE,
	0x550C7DC3,
	0x72BE5D74,
	0x80DEB1FE,
	0x9BDC06A7,
	0xC19BF174,
	0xE49B69C1,
	0xEFBE4786,
	0x0FC19DC6,
	0x240CA1CC,
	0x2DE92C6F,
	0x4A7484AA,
	0x5CB0A9DC,
	0x76F988DA,
	0x983E5152,
	0xA831C66D,
	0xB00327C8,
	0xBF597FC7,
	0xC6E00BF3,
	0xD5A79147,
	0x06CA6351,
	0x14292967,
	0x27B70A85,
	0x2E1B2138,
	0x4D2C6DFC,
	0x53380D13,
	0x650A7354,
	0x766A0ABB,
	0x81C2C92E,
	0x92722C85,
	0xA2BFE8A1,
	0xA81A664B,
	0xC24B8B70,
	0xC76C51A3,
	0xD192E819,
	0xD6990624,
	0xF40E3585,
	0x106AA070,
	0x19A4C116,
	0x1E376C08,
	0x2748774C,
	0x34B0BCB5,
	0x391C0CB3,
	0x4ED8AA4A,
	0x5B9CCA4F,
	0x682E6FF3,
	0x748F82EE,
	0x78A5636F,
	0x84C87814,
	0x8CC70208,
	0x90BEFFFA,
	0xA4506CEB,
	0xBEF9A3F7,
	0xC67178F2
];

var W = new Array(64);

function Sha256() {
	this.init();

	this._w = W; // new Array(64)

	Hash.call(this, 64, 56);
}

inherits(Sha256, Hash);

Sha256.prototype.init = function () {
	this._a = 0x6a09e667;
	this._b = 0xbb67ae85;
	this._c = 0x3c6ef372;
	this._d = 0xa54ff53a;
	this._e = 0x510e527f;
	this._f = 0x9b05688c;
	this._g = 0x1f83d9ab;
	this._h = 0x5be0cd19;

	return this;
};

function ch(x, y, z) {
	return z ^ (x & (y ^ z));
}

function maj(x, y, z) {
	return (x & y) | (z & (x | y));
}

function sigma0(x) {
	return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
}

function sigma1(x) {
	return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
}

function gamma0(x) {
	return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
}

function gamma1(x) {
	return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
}

Sha256.prototype._update = function (M) {
	var w = this._w;

	var a = this._a | 0;
	var b = this._b | 0;
	var c = this._c | 0;
	var d = this._d | 0;
	var e = this._e | 0;
	var f = this._f | 0;
	var g = this._g | 0;
	var h = this._h | 0;

	for (var i = 0; i < 16; ++i) {
		w[i] = M.readInt32BE(i * 4);
	}
	for (; i < 64; ++i) {
		w[i] = (gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16]) | 0;
	}

	for (var j = 0; j < 64; ++j) {
		var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + w[j]) | 0;
		var T2 = (sigma0(a) + maj(a, b, c)) | 0;

		h = g;
		g = f;
		f = e;
		e = (d + T1) | 0;
		d = c;
		c = b;
		b = a;
		a = (T1 + T2) | 0;
	}

	this._a = (a + this._a) | 0;
	this._b = (b + this._b) | 0;
	this._c = (c + this._c) | 0;
	this._d = (d + this._d) | 0;
	this._e = (e + this._e) | 0;
	this._f = (f + this._f) | 0;
	this._g = (g + this._g) | 0;
	this._h = (h + this._h) | 0;
};

Sha256.prototype._hash = function () {
	var H = Buffer.allocUnsafe(32);

	H.writeInt32BE(this._a, 0);
	H.writeInt32BE(this._b, 4);
	H.writeInt32BE(this._c, 8);
	H.writeInt32BE(this._d, 12);
	H.writeInt32BE(this._e, 16);
	H.writeInt32BE(this._f, 20);
	H.writeInt32BE(this._g, 24);
	H.writeInt32BE(this._h, 28);

	return H;
};

module.exports = Sha256;

},{"./hash":394,"inherits":324,"safe-buffer":391}],400:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var SHA512 = require('./sha512');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var W = new Array(160);

function Sha384() {
	this.init();
	this._w = W;

	Hash.call(this, 128, 112);
}

inherits(Sha384, SHA512);

Sha384.prototype.init = function () {
	this._ah = 0xcbbb9d5d;
	this._bh = 0x629a292a;
	this._ch = 0x9159015a;
	this._dh = 0x152fecd8;
	this._eh = 0x67332667;
	this._fh = 0x8eb44a87;
	this._gh = 0xdb0c2e0d;
	this._hh = 0x47b5481d;

	this._al = 0xc1059ed8;
	this._bl = 0x367cd507;
	this._cl = 0x3070dd17;
	this._dl = 0xf70e5939;
	this._el = 0xffc00b31;
	this._fl = 0x68581511;
	this._gl = 0x64f98fa7;
	this._hl = 0xbefa4fa4;

	return this;
};

Sha384.prototype._hash = function () {
	var H = Buffer.allocUnsafe(48);

	function writeInt64BE(h, l, offset) {
		H.writeInt32BE(h, offset);
		H.writeInt32BE(l, offset + 4);
	}

	writeInt64BE(this._ah, this._al, 0);
	writeInt64BE(this._bh, this._bl, 8);
	writeInt64BE(this._ch, this._cl, 16);
	writeInt64BE(this._dh, this._dl, 24);
	writeInt64BE(this._eh, this._el, 32);
	writeInt64BE(this._fh, this._fl, 40);

	return H;
};

module.exports = Sha384;

},{"./hash":394,"./sha512":401,"inherits":324,"safe-buffer":391}],401:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;

var K = [
	0x428a2f98,
	0xd728ae22,
	0x71374491,
	0x23ef65cd,
	0xb5c0fbcf,
	0xec4d3b2f,
	0xe9b5dba5,
	0x8189dbbc,
	0x3956c25b,
	0xf348b538,
	0x59f111f1,
	0xb605d019,
	0x923f82a4,
	0xaf194f9b,
	0xab1c5ed5,
	0xda6d8118,
	0xd807aa98,
	0xa3030242,
	0x12835b01,
	0x45706fbe,
	0x243185be,
	0x4ee4b28c,
	0x550c7dc3,
	0xd5ffb4e2,
	0x72be5d74,
	0xf27b896f,
	0x80deb1fe,
	0x3b1696b1,
	0x9bdc06a7,
	0x25c71235,
	0xc19bf174,
	0xcf692694,
	0xe49b69c1,
	0x9ef14ad2,
	0xefbe4786,
	0x384f25e3,
	0x0fc19dc6,
	0x8b8cd5b5,
	0x240ca1cc,
	0x77ac9c65,
	0x2de92c6f,
	0x592b0275,
	0x4a7484aa,
	0x6ea6e483,
	0x5cb0a9dc,
	0xbd41fbd4,
	0x76f988da,
	0x831153b5,
	0x983e5152,
	0xee66dfab,
	0xa831c66d,
	0x2db43210,
	0xb00327c8,
	0x98fb213f,
	0xbf597fc7,
	0xbeef0ee4,
	0xc6e00bf3,
	0x3da88fc2,
	0xd5a79147,
	0x930aa725,
	0x06ca6351,
	0xe003826f,
	0x14292967,
	0x0a0e6e70,
	0x27b70a85,
	0x46d22ffc,
	0x2e1b2138,
	0x5c26c926,
	0x4d2c6dfc,
	0x5ac42aed,
	0x53380d13,
	0x9d95b3df,
	0x650a7354,
	0x8baf63de,
	0x766a0abb,
	0x3c77b2a8,
	0x81c2c92e,
	0x47edaee6,
	0x92722c85,
	0x1482353b,
	0xa2bfe8a1,
	0x4cf10364,
	0xa81a664b,
	0xbc423001,
	0xc24b8b70,
	0xd0f89791,
	0xc76c51a3,
	0x0654be30,
	0xd192e819,
	0xd6ef5218,
	0xd6990624,
	0x5565a910,
	0xf40e3585,
	0x5771202a,
	0x106aa070,
	0x32bbd1b8,
	0x19a4c116,
	0xb8d2d0c8,
	0x1e376c08,
	0x5141ab53,
	0x2748774c,
	0xdf8eeb99,
	0x34b0bcb5,
	0xe19b48a8,
	0x391c0cb3,
	0xc5c95a63,
	0x4ed8aa4a,
	0xe3418acb,
	0x5b9cca4f,
	0x7763e373,
	0x682e6ff3,
	0xd6b2b8a3,
	0x748f82ee,
	0x5defb2fc,
	0x78a5636f,
	0x43172f60,
	0x84c87814,
	0xa1f0ab72,
	0x8cc70208,
	0x1a6439ec,
	0x90befffa,
	0x23631e28,
	0xa4506ceb,
	0xde82bde9,
	0xbef9a3f7,
	0xb2c67915,
	0xc67178f2,
	0xe372532b,
	0xca273ece,
	0xea26619c,
	0xd186b8c7,
	0x21c0c207,
	0xeada7dd6,
	0xcde0eb1e,
	0xf57d4f7f,
	0xee6ed178,
	0x06f067aa,
	0x72176fba,
	0x0a637dc5,
	0xa2c898a6,
	0x113f9804,
	0xbef90dae,
	0x1b710b35,
	0x131c471b,
	0x28db77f5,
	0x23047d84,
	0x32caab7b,
	0x40c72493,
	0x3c9ebe0a,
	0x15c9bebc,
	0x431d67c4,
	0x9c100d4c,
	0x4cc5d4be,
	0xcb3e42b6,
	0x597f299c,
	0xfc657e2a,
	0x5fcb6fab,
	0x3ad6faec,
	0x6c44198c,
	0x4a475817
];

var W = new Array(160);

function Sha512() {
	this.init();
	this._w = W;

	Hash.call(this, 128, 112);
}

inherits(Sha512, Hash);

Sha512.prototype.init = function () {
	this._ah = 0x6a09e667;
	this._bh = 0xbb67ae85;
	this._ch = 0x3c6ef372;
	this._dh = 0xa54ff53a;
	this._eh = 0x510e527f;
	this._fh = 0x9b05688c;
	this._gh = 0x1f83d9ab;
	this._hh = 0x5be0cd19;

	this._al = 0xf3bcc908;
	this._bl = 0x84caa73b;
	this._cl = 0xfe94f82b;
	this._dl = 0x5f1d36f1;
	this._el = 0xade682d1;
	this._fl = 0x2b3e6c1f;
	this._gl = 0xfb41bd6b;
	this._hl = 0x137e2179;

	return this;
};

function Ch(x, y, z) {
	return z ^ (x & (y ^ z));
}

function maj(x, y, z) {
	return (x & y) | (z & (x | y));
}

function sigma0(x, xl) {
	return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
}

function sigma1(x, xl) {
	return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
}

function Gamma0(x, xl) {
	return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
}

function Gamma0l(x, xl) {
	return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
}

function Gamma1(x, xl) {
	return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
}

function Gamma1l(x, xl) {
	return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
}

function getCarry(a, b) {
	return (a >>> 0) < (b >>> 0) ? 1 : 0;
}

Sha512.prototype._update = function (M) {
	var w = this._w;

	var ah = this._ah | 0;
	var bh = this._bh | 0;
	var ch = this._ch | 0;
	var dh = this._dh | 0;
	var eh = this._eh | 0;
	var fh = this._fh | 0;
	var gh = this._gh | 0;
	var hh = this._hh | 0;

	var al = this._al | 0;
	var bl = this._bl | 0;
	var cl = this._cl | 0;
	var dl = this._dl | 0;
	var el = this._el | 0;
	var fl = this._fl | 0;
	var gl = this._gl | 0;
	var hl = this._hl | 0;

	for (var i = 0; i < 32; i += 2) {
		w[i] = M.readInt32BE(i * 4);
		w[i + 1] = M.readInt32BE((i * 4) + 4);
	}
	for (; i < 160; i += 2) {
		var xh = w[i - (15 * 2)];
		var xl = w[i - (15 * 2) + 1];
		var gamma0 = Gamma0(xh, xl);
		var gamma0l = Gamma0l(xl, xh);

		xh = w[i - (2 * 2)];
		xl = w[i - (2 * 2) + 1];
		var gamma1 = Gamma1(xh, xl);
		var gamma1l = Gamma1l(xl, xh);

		// w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
		var Wi7h = w[i - (7 * 2)];
		var Wi7l = w[i - (7 * 2) + 1];

		var Wi16h = w[i - (16 * 2)];
		var Wi16l = w[i - (16 * 2) + 1];

		var Wil = (gamma0l + Wi7l) | 0;
		var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
		Wil = (Wil + gamma1l) | 0;
		Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
		Wil = (Wil + Wi16l) | 0;
		Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

		w[i] = Wih;
		w[i + 1] = Wil;
	}

	for (var j = 0; j < 160; j += 2) {
		Wih = w[j];
		Wil = w[j + 1];

		var majh = maj(ah, bh, ch);
		var majl = maj(al, bl, cl);

		var sigma0h = sigma0(ah, al);
		var sigma0l = sigma0(al, ah);
		var sigma1h = sigma1(eh, el);
		var sigma1l = sigma1(el, eh);

		// t1 = h + sigma1 + ch + K[j] + w[j]
		var Kih = K[j];
		var Kil = K[j + 1];

		var chh = Ch(eh, fh, gh);
		var chl = Ch(el, fl, gl);

		var t1l = (hl + sigma1l) | 0;
		var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
		t1l = (t1l + chl) | 0;
		t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
		t1l = (t1l + Kil) | 0;
		t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
		t1l = (t1l + Wil) | 0;
		t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

		// t2 = sigma0 + maj
		var t2l = (sigma0l + majl) | 0;
		var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

		hh = gh;
		hl = gl;
		gh = fh;
		gl = fl;
		fh = eh;
		fl = el;
		el = (dl + t1l) | 0;
		eh = (dh + t1h + getCarry(el, dl)) | 0;
		dh = ch;
		dl = cl;
		ch = bh;
		cl = bl;
		bh = ah;
		bl = al;
		al = (t1l + t2l) | 0;
		ah = (t1h + t2h + getCarry(al, t1l)) | 0;
	}

	this._al = (this._al + al) | 0;
	this._bl = (this._bl + bl) | 0;
	this._cl = (this._cl + cl) | 0;
	this._dl = (this._dl + dl) | 0;
	this._el = (this._el + el) | 0;
	this._fl = (this._fl + fl) | 0;
	this._gl = (this._gl + gl) | 0;
	this._hl = (this._hl + hl) | 0;

	this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
	this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
	this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
	this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
	this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
	this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
	this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
	this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
};

Sha512.prototype._hash = function () {
	var H = Buffer.allocUnsafe(64);

	function writeInt64BE(h, l, offset) {
		H.writeInt32BE(h, offset);
		H.writeInt32BE(l, offset + 4);
	}

	writeInt64BE(this._ah, this._al, 0);
	writeInt64BE(this._bh, this._bl, 8);
	writeInt64BE(this._ch, this._cl, 16);
	writeInt64BE(this._dh, this._dl, 24);
	writeInt64BE(this._eh, this._el, 32);
	writeInt64BE(this._fh, this._fl, 40);
	writeInt64BE(this._gh, this._gl, 48);
	writeInt64BE(this._hh, this._hl, 56);

	return H;
};

module.exports = Sha512;

},{"./hash":394,"inherits":324,"safe-buffer":391}],402:[function(require,module,exports){
'use strict';

var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};

},{"es-errors/type":289,"object-inspect":341}],403:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');
var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};

},{"call-bound":197,"es-errors/type":289,"get-intrinsic":297,"object-inspect":341}],404:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');
var inspect = require('object-inspect');
var getSideChannelMap = require('side-channel-map');

var $TypeError = require('es-errors/type');
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) {
						$m = getSideChannelMap();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap;

},{"call-bound":197,"es-errors/type":289,"get-intrinsic":297,"object-inspect":341,"side-channel-map":403}],405:[function(require,module,exports){
'use strict';

var $TypeError = require('es-errors/type');
var inspect = require('object-inspect');
var getSideChannelList = require('side-channel-list');
var getSideChannelMap = require('side-channel-map');
var getSideChannelWeakMap = require('side-channel-weakmap');

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};

},{"es-errors/type":289,"object-inspect":341,"side-channel-list":402,"side-channel-map":403,"side-channel-weakmap":404}],406:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":292,"inherits":324,"readable-stream/lib/_stream_duplex.js":376,"readable-stream/lib/_stream_passthrough.js":377,"readable-stream/lib/_stream_readable.js":378,"readable-stream/lib/_stream_transform.js":379,"readable-stream/lib/_stream_writable.js":380,"readable-stream/lib/internal/streams/end-of-stream.js":384,"readable-stream/lib/internal/streams/pipeline.js":386}],407:[function(require,module,exports){
(function (global){(function (){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":409,"./lib/response":410,"builtin-status-codes":189,"url":415,"xtend":435}],408:[function(require,module,exports){
(function (global){(function (){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],409:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null
	self._socketTimeout = null
	self._socketTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	if ('timeout' in opts && opts.timeout !== 0) {
		self.setTimeout(opts.timeout)
	}

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._resetTimers(false)
			self._connect()
		}, function (reason) {
			self._resetTimers(true)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self._resetTimers(true)
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	self._resetTimers(false)

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress(self._resetTimers.bind(self))
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype._resetTimers = function (done) {
	var self = this

	global.clearTimeout(self._socketTimer)
	self._socketTimer = null

	if (done) {
		global.clearTimeout(self._fetchTimer)
		self._fetchTimer = null
	} else if (self._socketTimeout) {
		self._socketTimer = global.setTimeout(function () {
			self.emit('timeout')
		}, self._socketTimeout)
	}
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
	var self = this
	self._destroyed = true
	self._resetTimers(true)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()

	if (err)
		self.emit('error', err)
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.setTimeout = function (timeout, cb) {
	var self = this

	if (cb)
		self.once('timeout', cb)

	self._socketTimeout = timeout
	self._resetTimers(false)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":408,"./response":410,"_process":359,"buffer":185,"inherits":324,"readable-stream":389}],410:[function(require,module,exports){
(function (process,global,Buffer){(function (){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					resetTimers(false)
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					resetTimers(true)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				resetTimers(result.done)
				if (result.done) {
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				resetTimers(true)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				resetTimers(true)
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		resetTimers(true)
		self.push(null)
	}
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":408,"_process":359,"buffer":185,"inherits":324,"readable-stream":389}],411:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183,"safe-buffer":391}],412:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":359,"timers":412}],413:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var isArray = require('isarray');
var typedArrayBuffer = require('typed-array-buffer');

var isView = ArrayBuffer.isView || function isView(obj) {
	try {
		typedArrayBuffer(obj);
		return true;
	} catch (e) {
		return false;
	}
};

var useUint8Array = typeof Uint8Array !== 'undefined';
var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
	&& typeof Uint8Array !== 'undefined';
var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

module.exports = function toBuffer(data, encoding) {
	/*
	 * No need to do anything for exact instance
	 * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed
	 */
	if (data instanceof Buffer) {
		return data;
	}

	if (typeof data === 'string') {
		return Buffer.from(data, encoding);
	}

	/*
	 * Wrap any TypedArray instances and DataViews
	 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
	 */
	if (useArrayBuffer && isView(data)) {
		// Bug in Node.js <6.3.1, which treats this as out-of-bounds
		if (data.byteLength === 0) {
			return Buffer.alloc(0);
		}

		// When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
		if (useFromArrayBuffer) {
			var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
			/*
			 * Recheck result size, as offset/length doesn't work on Node.js <5.10
			 * We just go to Uint8Array case if this fails
			 */
			if (res.byteLength === data.byteLength) {
				return res;
			}
		}

		// Convert to Uint8Array bytes and then to Buffer
		var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
		var result = Buffer.from(uint8);

		/*
		 * Let's recheck that conversion succeeded
		 * We have .length but not .byteLength when useFromArrayBuffer is false
		 */
		if (result.length === data.byteLength) {
			return result;
		}
	}

	/*
	 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
	 * Doesn't make sense with other TypedArray instances
	 */
	if (useUint8Array && data instanceof Uint8Array) {
		return Buffer.from(data);
	}

	var isArr = isArray(data);
	if (isArr) {
		for (var i = 0; i < data.length; i += 1) {
			var x = data[i];
			if (
				typeof x !== 'number'
				|| x < 0
				|| x > 255
				|| ~~x !== x // NaN and integer check
			) {
				throw new RangeError('Array items must be numbers in the range 0-255.');
			}
		}
	}

	/*
	 * Old Buffer polyfill on an engine that doesn't have TypedArray support
	 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
	 * Convert to our current Buffer implementation
	 */
	if (
		isArr || (
			Buffer.isBuffer(data)
				&& data.constructor
				&& typeof data.constructor.isBuffer === 'function'
				&& data.constructor.isBuffer(data)
		)
	) {
		return Buffer.from(data);
	}

	throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
};

},{"isarray":327,"safe-buffer":391,"typed-array-buffer":414}],414:[function(require,module,exports){
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */
var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);

var isTypedArray = require('is-typed-array');

/** @type {import('.')} */
// node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
module.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
	if (!isTypedArray(x)) {
		throw new $TypeError('Not a Typed Array');
	}
	return x.buffer;
};

},{"call-bound":197,"es-errors/type":289,"is-typed-array":326}],415:[function(require,module,exports){
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

var punycode = require('punycode/');

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = require('qs');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

},{"punycode/":367,"qs":369}],416:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],417:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":420,"./parse.js":421,"./stringify.js":425,"./v1.js":426,"./v3.js":427,"./v4.js":429,"./v5.js":430,"./validate.js":431,"./version.js":432}],418:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],419:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default = {
  randomUUID
};
exports.default = _default;
},{}],420:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],421:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":431}],422:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],423:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],424:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],425:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.unsafeStringify = unsafeStringify;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":431}],426:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = require("./stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.unsafeStringify)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":423,"./stringify.js":425}],427:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":418,"./v35.js":428}],428:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URL = exports.DNS = void 0;
exports.default = v35;

var _stringify = require("./stringify.js");

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":421,"./stringify.js":425}],429:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _native = _interopRequireDefault(require("./native.js"));

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = require("./stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }

  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.unsafeStringify)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./native.js":419,"./rng.js":423,"./stringify.js":425}],430:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":424,"./v35.js":428}],431:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":422}],432:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":431}],433:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],434:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBind = require('call-bind');
var callBound = require('call-bound');
var gOPD = require('gopd');
var getProto = require('get-proto');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		}
	});
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName} */ ($slice(typedArray, 1));
					}
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName} */ ($slice(name, 1));
				} catch (e) { /**/ }
			}
		}
	);
	return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		/** @type {string} */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":140,"call-bind":196,"call-bound":197,"for-each":294,"get-proto":300,"gopd":302,"has-tostringtag/shams":306}],435:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],436:[function(require,module,exports){
// smartledger-sdk/src/bsv.js

const sdk = require('@bsv/sdk');
const { PrivateKey, PublicKey, SignedMessage, Utils } = sdk;

function generateKeyPair() {
  const privateKey = PrivateKey.fromRandom();
  const publicKey = privateKey.toPublicKey();
  return { privateKey, publicKey };
}

function signMessage(message, privateKey, recipientPubKey = null) {
  const messageBytes = Utils.toArray(message, 'utf8');
  if (recipientPubKey) {
    return SignedMessage.sign(messageBytes, privateKey, recipientPubKey);
  }
  return SignedMessage.sign(messageBytes, privateKey);
}

function verifySignature(message, signature, verifierKey = null) {
  const messageBytes = Utils.toArray(message, 'utf8');
  if (verifierKey) {
    return SignedMessage.verify(messageBytes, signature, verifierKey);
  }
  return SignedMessage.verify(messageBytes, signature);
}

function isValidPrivateKey(privateKey) {
  try {
    PrivateKey.fromString(privateKey);
    return true;
  } catch (e) {
    return false;
  }
}

function isValidPublicKey(publicKey) {
  try {
    PublicKey.fromString(publicKey);
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = {
  generateKeyPair,
  signMessage,
  verifySignature,
  isValidPrivateKey,
  isValidPublicKey,
};

},{"@bsv/sdk":1}],437:[function(require,module,exports){
// smartledger-sdk/src/crypto.js

const CryptoJS = require('crypto-js');

function encrypt(message, secret) {
  return CryptoJS.AES.encrypt(message, secret).toString();
}

function decrypt(ciphertext, secret) {
  const bytes = CryptoJS.AES.decrypt(ciphertext, secret);
  return bytes.toString(CryptoJS.enc.Utf8);
}

function hash(data, algorithm = 'SHA256') {
  switch (algorithm.toUpperCase()) {
    case 'SHA256':
      return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex);
    case 'SHA512':
      return CryptoJS.SHA512(data).toString(CryptoJS.enc.Hex);
    case 'MD5':
      return CryptoJS.MD5(data).toString(CryptoJS.enc.Hex);
    default:
      throw new Error(`Unsupported hash algorithm: ${algorithm}`);
  }
}

function base64Encode(text) {
  const words = CryptoJS.enc.Utf8.parse(text);
  return CryptoJS.enc.Base64.stringify(words);
}

function base64Decode(base64text) {
  const words = CryptoJS.enc.Base64.parse(base64text);
  return CryptoJS.enc.Utf8.stringify(words);
}

function getRandomBytes(size) {
    return CryptoJS.lib.WordArray.random(size).toString(CryptoJS.enc.Hex);
}

module.exports = {
  encrypt,
  decrypt,
  hash,
  base64Encode,
  base64Decode,
  getRandomBytes,
};

},{"crypto-js":227}],438:[function(require,module,exports){
// smartledger-sdk/src/index.js

const crypto = require('./crypto');
const wallet = require('./wallet');
const bsv = require('./bsv');
const utils = require('./utils');
const storage = require('./storage');

const SmartLedger = {
  ...crypto,
  ...wallet,
  ...bsv,
  ...utils,
  ...storage,
};

module.exports = SmartLedger;

},{"./bsv":436,"./crypto":437,"./storage":439,"./utils":440,"./wallet":441}],439:[function(require,module,exports){
// smartledger-sdk/src/storage.js

const { encrypt, decrypt } = require('./crypto');

const STORAGE_PREFIX = 'smartledger_';

function checkLocalStorage() {
  if (typeof localStorage === 'undefined') {
    throw new Error('localStorage is not available in this environment.');
  }
}

function storeMnemonic(id, mnemonic, metadata, storageKey) {
  checkLocalStorage();
  const data = { mnemonic, metadata };
  const encryptedData = encrypt(JSON.stringify(data), storageKey);
  localStorage.setItem(`${STORAGE_PREFIX}${id}`, encryptedData);
}

function storeKey(id, key, metadata, storageKey) {
  checkLocalStorage();
  const data = { key, metadata };
  const encryptedData = encrypt(JSON.stringify(data), storageKey);
  localStorage.setItem(`${STORAGE_PREFIX}${id}`, encryptedData);
}

function listKeys() {
  checkLocalStorage();
  const keys = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key.startsWith(STORAGE_PREFIX)) {
      keys.push(key.replace(STORAGE_PREFIX, ''));
    }
  }
  return keys;
}

function retrieveMnemonic(id, storageKey) {
  checkLocalStorage();
  const encryptedData = localStorage.getItem(`${STORAGE_PREFIX}${id}`);
  if (!encryptedData) return null;
  const decryptedData = decrypt(encryptedData, storageKey);
  return JSON.parse(decryptedData);
}

function retrieveKey(id, storageKey) {
  checkLocalStorage();
  const encryptedData = localStorage.getItem(`${STORAGE_PREFIX}${id}`);
  if (!encryptedData) return null;
  const decryptedData = decrypt(encryptedData, storageKey);
  return JSON.parse(decryptedData);
}

module.exports = {
  storeMnemonic,
  storeKey,
  listKeys,
  retrieveMnemonic,
  retrieveKey,
};

},{"./crypto":437}],440:[function(require,module,exports){
(function (Buffer){(function (){
// smartledger-sdk/src/utils.js

const { v5: uuidv5 } = require('uuid');
const secrets = require('secrets.js-grempe');

const UUID_NAMESPACE = '9e7a4900-0e54-4dc4-9c5a-4b0c8d523745';

function generateUUID(domain) {
  return uuidv5(domain, UUID_NAMESPACE);
}

function splitSecret(secret, numShares, threshold) {
    const secretHex = Buffer.from(secret).toString('hex');
    return secrets.share(secretHex, numShares, threshold);
}

function combineShares(shares) {
    const combinedHex = secrets.combine(shares);
    return Buffer.from(combinedHex, 'hex').toString('utf8');
}

module.exports = {
  generateUUID,
  splitSecret,
  combineShares,
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":185,"secrets.js-grempe":392,"uuid":417}],441:[function(require,module,exports){
// smartledger-sdk/src/wallet.js

const sdk = require('@bsv/sdk');
const { Mnemonic, HD } = sdk;

function generateMnemonic() {
  const mnemonic = Mnemonic.fromRandom();
  return mnemonic.toString();
}

function validateMnemonic(mnemonic) {
  return Mnemonic.isValid(mnemonic);
}

async function mnemonicToSeedHex(mnemonic, passphrase = '') {
  const mnemonicObj = Mnemonic.fromString(mnemonic);
  const seed = await mnemonicObj.toSeed(passphrase);
  return seed.toString('hex');
}

async function derivePath(mnemonic, path) {
  const seed = await Mnemonic.fromString(mnemonic).toSeed();
  const master = HD.fromSeed(seed);
  const child = master.derive(path);

  return {
    path: path,
    privateKey: child.privKey, // Return the object, not the string
    publicKey: child.pubKey,   // Return the object, not the string
    wif: child.privKey.toWif(),
  };
}

async function deriveStandardPaths(mnemonic) {
  const paths = [
    "m/44'/236'/0'/0/0",
    "m/44'/236'/0'/0/1",
    "m/44'/236'/0'/1/0",
    "m/44'/236'/0'/1/1",
  ];

  const derivedKeys = [];
  for (const path of paths) {
    const key = await derivePath(mnemonic, path);
    derivedKeys.push(key);
  }
  return derivedKeys;
}

module.exports = {
  generateMnemonic,
  validateMnemonic,
  mnemonicToSeedHex,
  derivePath,
  deriveStandardPaths,
};

},{"@bsv/sdk":1}]},{},[438])(438)
});
